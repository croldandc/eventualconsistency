% !TEX root = main.tex

\documentclass[envcountsect,runningheads,orivec]{llncs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ENLARGED STYLE FOR SUBMISSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\setlength{\textwidth}{15cm}

%\setlength{\textheight}{21cm}
%\addtolength{\oddsidemargin}{-1.25cm}pu
%\setlength{\evensidemargin}{\oddsidemargin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[all]{xy}\CompileMatrices
\usepackage[english]{babel}
%\usepackage[mathcal]{euscript}
%\usepackage{latexsym}
\usepackage{amssymb}
%\usepackage{pslatex}

\usepackage{dsfont}
\usepackage{alltt}
\usepackage{bbm}
\usepackage{url}
\usepackage{subfigure}
%\usepackage{stmaryrd,amsmath,amsfonts,amstext,amssymb,fancybox}

\usepackage{bussproofs}
\usepackage{mathtools}
\usepackage{color} %para los comentarios
\usepackage[dvipsnames]{xcolor}

\usepackage{xargs}

\input{macros}
\bibliographystyle{plain}

\title{GSP-Calculus}

\author{Hern\'an Melgratti\inst{1,2} \and Christian Rold\'an\inst{1} 
        }

\institute{
  Departamento de Computaci\'on, FCEyN, Universidad de Buenos Aires.
 %\email{hmelgra@dc.uba.ar} 
\\
\and CONICET.}

%\titlerunning{Correlation sets}

%\authorrunning{R. Bruni, H. Melgratti, U. Montanari}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\input{abstractgsp}


\section{Implementation of GSP}

The \tgspcalculus\ model formalised in the previous section corresponds to an idealised system that
abstracts away from important implementation details, mainly, the  problem of maintaining a constantly growing 
sequence of updates to represent states.  A realistic implementation for such model has been 
proposed in\henote{~\cite{}}, in which states and updates have a compact representation in 
terms of two different objects: a {\em state} and {\em delta}. Their precise definition highly depends
on the datatype of the values kept in the store. \henote{agregar ejemplo?}. 
In order to keep the description of the model as general as possible, they have been
characterised \henote{in~\cite{}} with 
two abstract types, namely $\statetype$ and $\deltatype$, which are equipped with the following  operations.
\[
\begin{array}{lll}
	\textbf{const} & \initialstate & : \statetype \\
	\textbf{function} & \ireadname & : \partialfunction{\readtype \times \statetype}{\valuetype} \\
	\textbf{function} & \iapplyname & : \partialfunction{\statetype \times \deltatype^*}{\statetype} \\
	\textbf{const} & \emptydelta & : \deltatype \\
	\textbf{function} & \iappendname & : \partialfunction{\deltatype \times \updatetype}{\deltatype} \\
	\textbf{function} & \ireducename & : \partialfunction{\deltatype^*}{\deltatype} \\
\end{array}
\] 

Operations $\initialstate$ and $\emptydelta$ are the constructors for the respective types. Function $\ireadname$ is the 
interpretation function for read operations (\ie, the implementation counterpart of the operation $\rvalue{\_}{\_}$  in the 
idealised model) while $\iapplyname$ is for state transformations. The remaining operations $\iappendname$ and
$\ireducename$ account for compacting the description of several updates. 
%
We shall use  $\astate,\astate['],\ldots, \astate[{_1}],\ldots$ to denote values of  type $\statetype$ and 
$\adelta,\adelta['],\ldots, \adelta[{_1}],\ldots$ for values of type $\pushbuffertype$.

In addition,  we will use partial functions  $\amxrf,\amxrf['],\ldots, \amxrf[{_1}],\ldots$ in  $\idset\rightarrow \nat$
assigning clients with a natural number denoting \henote{the number of the last round exchanged with ...}

%Let $\idset$ be a set of clients' name ranged over by $b$, $b_1$, $b_2$, $\ldots$; 

The global state of the store is now represented by a pair $\gsprefixtype$ be a set over sets \statetype\ $\times$ $\idset$ $\rightarrow$ $\mathbb{N}$, \gssegmenttype\ be a set operation over sets \deltatype $\times$ $\idset$ $\rightarrow$ $\mathbb{N}$ and \roundtype\ the set over sets $\idset$ $\times$ $\mathbb{N}$ $\times$ \deltatype; $\emptygssegment$\ is a fresh element of \gssegmenttype.
%
\henote{Explain gsspref... round}

For convenience, notational conventions are in~\figref{}
\begin{figure}
  \[
   \begin{array}{lrll}
%       &\astate,\astate['],\ldots, \astate[{_1}],\ldots &{\ \in\ }& \statetype
%       \\
%       &\adelta,\adelta['],\ldots, \adelta[{_1}],\ldots &{\ \in\ }& \deltatype
%       \\
%       &,\amxrf['],\ldots, \amxrf[{_1}],\ldots &{\ \in\ }& \idset\rightarrow \nat 
       & \cid & \in & \idset
       \\
       & n & \in & \nat
       \\
       &\astate & \in & \statetype
       \\
       &\adelta & \in & \deltatype \cup \{\nodelta\}
       \\
       &\pendingtype & \in & \deltatype^* \quad \mbox{\henote{antes $\rho$ y $\sigma$}}\\
       &\amxrf & \in & \idset\rightarrow \nat
       \\
%       \rName{GSprefix}
%       &
%       \agspref & ::= & \agsprefpair
%       \\
%       \rName{GSSegment}
%       &
%       \agsseg & ::= & \agssegpair
%       \\
%       \rName{Segment}
%       &
%       \aseg & ::= & \agspref \; |\;  \agsseg
%        \\
       \rName{Segment}
       &
       \aseg & ::= & \agsprefpair \; |\;  \agssegpair
        \\
       \rName{Round}
       &
       \around &::= & \aroundtuple
        \\
       \rName{Round Seq}
       &
       \aseqround &\in & \around^*
        \\
       \rName{Seg Seq}
       &
       \aseqseg &\in & \aseg^*
        \\
       &
       {\inclient} &::= &  \aseqseg%{{\agsseg}^* \cup \agspref}
%       \\
%       & 
%       \outclient &\in & {\aseqround}
      \\
       &
       {\inserver} & \in  & \partialfunction{\idset}\aseqround%\outclient
       \\
       & 
       \outserver &\in & \partialfunction{\idset}\aseqseg%\inclient
   \end{array}
  \]
  \caption{Syntax}
  \label{fig:syntax-implementation}
\end{figure}

%Furthermore, we assume the following parametric functions defined over the abstract data types above borrowed from :


%Let $\pendingtype$, $\sigma$ be sequence defined:

%$\pendingtype$,$\sigma$ := $\epsilon$ \text{\textbar} [$\delta$]$\cdot$ $\pendingtype$
 

We assume the following countable sets of persisted state $\gsprefixtype$ ranged over by $\agspref$, $\agspref_1$, $\ldots$; 

Let \\



\subsection{Syntax}
 \begin{definition}[Implementation of GSP] 
	The syntax of clients and server is given by the following grammar 
  \[
    \begin{array}{l@{\quad}r@{\;::=\;}l}
	\rName{system} & \isystemterm &  \iserver\ \bigpar\ \iclient \\
	\rName{server} & \iserver & \server{\astate}{\inqueue}{\outqueue} \\
	\rName{clients}& \iclient & \zero \;|\; 
	 						%\client{P}{<\astate,\pendingtype,\pushbuffertype,\transactionbuffertype,\receivebuffertype,n,\inqueue,\outqueue>} 
							\addid{\iclientsyntax}
							\;|\; \ 
							\iclient \bigpar \iclient  \\
%			 (\textsc{program}) & P & \zero \;|\; \readins{x}{r} \;|\; \updateins{u} \;|\; 	\pushins \;|\; \pullins
     \end{array}
  \]
 \end{definition}
 
The implementation of a system is a server and clients interacting concurrently. A server will be represented with a persisted state denoted by $\persistedstate$, input messages $\inserver$ and output messages $\outserver$.
We will refer to clients, as tuple of program $P$ and set of states and sequences $E$. A program client stores a state ($E.\known$), a pending queue ($E.\pending$),i.e., updates sent to the server without confirmation of their reception, a push buffer ($E.\pushbuffer$) which holds updates that were pushed by the client but have not been sent to the server, a transaction buffer ($E.\transactionbuffer$) which holds updates for sending with another ones, a receive buffer ($E.\receivebuffertype$) for updates which were sent by the server, the number of round sent ($E.\nround$), a input message queue ($E.\inclient$) and a output message queue ($E.\outclient$).


\subsection{Operational Semantics}

The operational semantics of \gspcalculus\ is defined by a labeled transition system 
over well-formed terms, up-to the structural congruence.

%The labeled transition system considers the following actions:
%\[ 
%\begin{array}{r@{\ ::= \ }l}
%  \alpha & \tau \ | \ \readtran{r} \ | \  \updatetran{u} \ | \ \pulltran \ | \ \pushtran \ | \ \confirmedtran 
%  \\
%\end{array}
%\]



% \[
% \begin{array}{l}
%   \hspace{-.3cm} \textsc{CLIENTS}\\
%%		\mathax{update}{\clientr{\updateins{u}}{\stateclient} \arro{\updatetran{u}} \clientr{P}{\update{E}{\transactionbuffer}{\appendplus{E.\transactionbuffer}{u}}}} \\[15pt]
%%		
%	\mathax{update}
%		{\begin{array}{l}
%		\addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm
%		\arro{\updatetran{u}} 
%		\\[5pt]
%		\hspace{5.5cm}
%		{\addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm}
%		\end{array}}
%\\
%% 		\mathax{push}{\clientr{\pushins}{\stateclient} \arro{\pushtran} \clientr{P}{\updatethree{E}{\pushbuffer}{\reduce{E.\pushbuffer\cdot E.\transactionbuffer}}{\transactionbuffer}{\epsilon}{\nround}{E.\nround+1}  }} \\[25pt]
%	\mathax{push}
%		{\begin{array}{l}
%		\addid{\iclientinst[\tpushins]} \ \bigpar \ \isystemterm
%		\arro{\pushtran} 
%		\\[5pt]
%		\hspace{5cm}
%		{\addid{\iclientinst[P][@][@][\ireduce{\pushbuffer\cdot \transactionbuffer}][\epsilon][@][n+1]}\ \bigpar \ \isystemterm}
%		\end{array}}
%%\updatethree{E}{\pushbuffer}{\appendplus{\pushbuffer}{\transactionbuffer}}{\transactionbuffer}{\epsilon}{\nround}{\nround+1}
%\\
%%	 {\clientr{P}{\stateclient} \arro{\sendtran} \clientr{P}{\updatethree{E}{\pending}{E.\pending \cdot E.\pushbuffer}{\pushbuffer}{\epsilon}{\outclient(i)}{\outclient(i) \cdot \round{i}{E.\nround}{E.\pushbuffer}}}}
%
%	 \mathrule{send}
%	         {\pushbuffer \neq \epsilon}
% 		{\begin{array}{l}
%		\addid{\iclientinst} \ \bigpar \ \isystemterm
%		\arro{\tau} 
%		\\[5pt]
%		\hspace{5.3cm}
%		\addid{\iclientinst[@][@][\pending \cdot \pushbuffer][\epsilon][@][@][@][@][\outclient \cdot {\aroundtuple[\cid][\nround][\pushbuffer]}]}\ \bigpar \ \isystemterm
%	 	\end{array}
%		}	
%\\
%%		\mathrule{receive}{E.\inclient = \gs_0 \cdot \gs_t}{\clientr{P}{\stateclient} \arro{\receive} \clientr{P}{\updatetwo{E}{\receivebuffer}{E.\receivebuffer \cdot \gs_0)}{\inclient}{\gs_t)}}}\\[25pt]
%	\mathax{receive}
% 		{\begin{array}{l}
%		\addid{\iclientinst[@][@][@][@][@][@][@][\aseg \cdot \inclient]} \ \bigpar \ \isystemterm
%		\arro{\tau} 
%		\\[5pt]
%		\hspace{6.4cm}
%		\addid{\iclientinst[@][@][@][@][@][\receivebuffer \cdot \aseg]}\ \bigpar \ \isystemterm
%	 	\end{array}
%		}	
%\\
%
%%		\mathrule{pull}{E.\inclient(i) \neq \undefined \qquad E.\outclient(i) \neq \undefined \qquad |E.\receivebuffer| > 0}{\clientr{\pullins}{\stateclient}\arro{\pulltran} \clientr{P}{\updatethree{E}{\known}{\reducestate{E.\known}{E.\receivebuffer}}{\receivebuffer}{\epsilon}{E.\pending}{\remove{E.\pending}{E.\receivebuffer}}}}
%	\mathaxiom{pull}
%		 {\begin{array}{l}
%			\addid{\iclientinst[\tpullins][@][@][@][@][{\agssegpair[x]}\cdot\receivebuffer]}\ \bigpar \ \isystemterm
%			\arro{\pulltran} 
%			\\[5pt]
%			\hspace{5.2cm}
%			\addid{\iclientinst[P]
%						 [\iapply{\known}{x}]
%						 [{\pending}\setminus x]
%						 [@][@]
%						 [{\receivebuffer}]}\ \bigpar \ \isystemterm
%	 	\end{array}
%		}
%		\\
%\henote{\mbox{el apply no está en el paper, ellos usan reducestate}}
%\\
%
%%		\mathrule{read}{\readplus{r}{\curstate{\known}{\pending}{\pushbuffer}{\transactionbuffer}}}{\clientr{\readins{x}{r}}{\stateclient} \arro{\readtran{r}} \clientr{\update{P}{x}{v}}{\stateclient}}
%	\mathrule{read}
%		{\iread{r}{\curstate{\known}{\pending}{\pushbuffer}{\transactionbuffer}}}
%		{\begin{array}{l}
%		\addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm
%		\arro{\readtran{r}} 
%		\\[5pt]
%		\hspace{6.1cm}
%		\addid{\iclientinst[{P}\subst{x}{v}]}\ \bigpar \ \isystemterm
%		\end{array}
%		}
%\\
%%		\mathrule{pull}{E.\inclient(i) \neq \undefined \qquad E.\outclient(i) \neq \undefined \qquad |E.\receivebuffer| > 0}{\clientr{\pullins}{\stateclient}\arro{\pulltran} \clientr{P}{\updatethree{E}{\known}{\reducestate{E.\known}{E.\receivebuffer}}{\receivebuffer}{\epsilon}{E.\pending}{\remove{E.\pending}{E.\receivebuffer}}}}
%%	\mathrule{pull}
%%		{\appf{\inqueue}{\cid} \neq \undefined \qquad\qquad \appf{\outqueue}{\cid} \neq \undefined \qquad\qquad |\receivebuffer| > 0}
%%		{
%%			\addid{\iclientinst[\tpullins]}
%%			\arro{\pulltran} 
%%			\addid{\iclientinst[P]
%%						 [\reducestate{\known}{\receivebuffer}]
%%						 [\remove{\pending}{\receivebuffer}]
%%						 [@][@]
%%						 [{\epsilon}]
%%				}
%%		}
%%		\\
%%\\[15pt]
%%		\mathax{confirmed}{\clientr{\confirmedins{x}}{\stateclient} \arro{\confirmedtran}
% %\clientr{\update{P}{x \mapsto E.\pending = \epsilon \lor E.\pushbuffer = \epsilon \lor E.\transactionbuffer = \epsilon}{\textbf{true}}}{\stateclient}} 
%		\mathrule{confirm}
%		{ v = (\pending \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) }
%		{\begin{array}{l}
%			\addid{\iclientinst[\tconfirmedins]} \bigpar \ \isystemterm
%			\arro{\confirmedtran} 
%			\\[5pt]
%			\hspace{6.1cm}
%			\addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm
%		\end{array}
%		}
%\\[25pt]
%\mathrule{while-true}
%	{\eval \cond {true}}
%	{
%		{\begin{array}{l}
%			\addid{\iclientinst[\pwhile{\cond}{P}[Q]]} \bigpar \ \isystemterm
%			\arro{\confirmedtran} 
%			\\[5pt]
%			\hspace{4.5cm}
%			\addid{\iclientinst[P;\pwhile{\cond}{P}[Q]]} \bigpar \ \isystemterm
%		\end{array}
%		}
%%	\tsystem{\tclienti{\pwhile{\cond}{\tprogram}[Q]}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}
%%	\arro{\tau} 
%%	\tsystem{\tclienti{\tprogram;\pwhile{\cond}{\tprogram}[Q]}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1}}
%	}
%
%\\[25pt]
%\mathrule{while-false}
%	{\eval \cond {false}}
%	{
%		{\begin{array}{l}
%			\addid{\iclientinst[\pwhile{\cond}{P}[Q]]} \bigpar \ \isystemterm
%			\arro{\confirmedtran} 
%			\\[5pt]
%			\hspace{7cm}
%			\addid{\iclientinst[Q]} \bigpar \ \isystemterm
%		\end{array}
%%	\tsystem{\tclienti{\pwhile{\cond}{\tprogram}[Q]}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}} 
%%	\arro{\tau} 
%%	\tsystem{\tclienti{Q}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1}}
%	}}
%	\\
%
%
%
%
%%	\mathrule{receive}
%%		{\inclient(\cid) = \gs_0 \cdot \gs_t}
%%		{\begin{array}{l}
%%			{\addid{\iclientinst[@]}} \arro{\tau}
%%			\\
%%			\hspace{5cm} 
%%			{\addid{\iclientinst[@][@][@][@][@][\receivebuffer \cdot \gs_0.gssegment][@][\inclient{[\cid\mapsto\gs_t]}]}}
%%		\end{array}}
%
%\end{array}
% \]





% \[
% \begin{array}{l}
%    \hspace{-.3cm} \textsc{SERVER}\\
%    
%\mathrule{drop-conn}{b_i \in \inserver \qquad  b_i \in \outserver}{\server{\persistedstate}{\inserver}{\outserver} \auxarro{\dropconn{b_i}} \server{\persistedstate}{\inserver \setminus b_i}{\outserver \setminus b_i}} 
%\hfill
%\mathax{crash-and-recover}{\server{\persistedstate}{\inserver}{\outserver} \auxarro{\crashandrecover} \server{\persistedstate}{\undefined}{\undefined}}
%
%\\[25pt]
%
%\mathrule{batch}{rs=\receiveroundsname{\inserver} \qquad \agssegpair[@][{\amxrf[{'}]}] =\append{\emptygssegment}{rs} \qquad 
%  \astate[']=\iapply{\astate}{\adelta}}{\server{\agsprefpair }{\inserver}{\outserver} \arro{\tau} 
%  \server{\agsprefpair[{\astate[']}][{\amxrf[{'}]}] }{\clean{\inserver}}{\notify{dom(\outserver)}{\outserver}{gs}}}
%
%\\[25pt]
%
%\mathrule{accept-conn}{b_i \notin \inserver \qquad b_i \notin \outserver}{\server{\persistedstate}{\inserver}{\outserver} \auxarro{\acceptconn{b_i}} \server{\persistedstate}{\inserver}{\update{\outserver}{b_i}{\persistedstate}}}
%
%    \\[35pt]
%    \hspace{-.3cm} \textsc{COMMUNICATION}
%		
%\\
%    \mathrule{comm server-client}{\outserver(i)=\gs \cdot \gss}{\server{\state}{\inserver}{\outserver} \bigpar \clientr{P}{\stateclient} \arro{\tau} \server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
%		\clientr{P}{\update{E}{\inclient}{E.\inclient \cdot \gs}}}
%		
%\\[25pt]
%
%	    \mathrule{comm client-server}{\outclient=\headerround \cdot \tailround}{\server{\state}{\inserver}{\outserver} \bigpar \clientr{P}{\stateclient} \arro{\tau} \server{\state}{\update{\inserver}{i}{\inserver(i) \cdot \headerround}}{\outserver} \bigpar 
%		\clientr{P}{\update{E}{\outclient}{\tailround}}}	
% \\
%
% \end{array}
% \]

 \[
 \begin{array}{l}
   \hspace{-.3cm} \textsc{CLIENTS}\\
	\mathax{update}
		{\begin{array}{l}
		\addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm
		\arro{\updatetran{u}} 
		\\
		\hspace{5.5cm}
		{\addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm}
		\end{array}}
\\
	\mathax{push}
		{\begin{array}{l}
		\addid{\iclientinst[\tpushins]} \ \bigpar \ \isystemterm
		\arro{\pushtran} 
		\\
		\hspace{5cm}
		{\addid{\iclientinst[P][@][@][\ireduce{\pushbuffer\cdot \transactionbuffer}][\epsilon][@][n+1]}\ \bigpar \ \isystemterm}
		\end{array}}
\\
	 \mathrule{send}
	         {\pushbuffer \neq \epsilon \qquad \cid\in\dom\inserver \qquad \around = \aroundtuple[\cid][\nround][\pushbuffer]}
 		{\begin{array}{l}
		\addid{\iclientinst} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient
		\arro{\tau} 
		\\
		\hspace{2cm}
		\addid{\iclientinst[@][@][\pending \cdot \around][\epsilon]}
		\ \bigpar \ \iserverins[{\astate[']}][@][\inserver\upd{\cid}{\inserver(\cid)\cdot\around}]
		\ \bigpar\ \iclient
	 	\end{array}
		}	
\\
	\mathrule{receive}
	         { \outserver(\cid) = \aseg\cdot\aseqseg}
		{\begin{array}{l}
		\addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient
		\arro{\tau} 
		\\
		\hspace{2.1cm}
		\addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient
	 	\end{array}
		}	
\\
	\mathrule{pull-1}
	{\aseqround['] = filter\ (\geq \amxrf[_k](\cid)) \ \aseqround \qquad \inclient = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]}
		 {\begin{array}{l}
			\addid{\iclientinst[\tpullins][@]
			[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
			[@][@][@][n][{\agssegpair[{\adelta[']}]}\cdot\inclient]}
			    \ \bigpar \ \isystemterm
			\arro{\pulltran} 
			\\
			\hspace{5.5cm}
			\addid{\iclientinst[P]
						 [\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}][n][\epsilon]}\ \bigpar \ \isystemterm
	 	\end{array}
		}
\\

	\mathrule{read}
		{\iread{r}{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}=v}
		{\begin{array}{l}
		\addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm
		\arro{\readtran{r}} 
		\\
		\hspace{6.1cm}
		\addid{\iclientinst[{P}\subst{x}{v}]}\ \bigpar \ \isystemterm
		\end{array}
		}
\\
		\mathrule{confirm}
		{ v = (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) }
		{\begin{array}{l}
			\addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm
			\arro{\confirmedtran} 
			\\
			\hspace{6.1cm}
			\addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm
		\end{array}
		}
\\[25pt]
\mathrule{while-true}
	{\eval \cond {true}}
	{
		{\begin{array}{l}
			\addid{\iclientinst[\pwhile{\cond}{P}[Q]]} \bigpar \ \isystemterm
			\arro{\tau} 
			\\
			\hspace{4.5cm}
			\addid{\iclientinst[P;\pwhile{\cond}{P}[Q]]} \bigpar \ \isystemterm
		\end{array}
		}
	}
\\[25pt]
\mathrule{while-false}
	{\eval \cond {false}}
	{
		{\begin{array}{l}
			\addid{\iclientinst[\pwhile{\cond}{P}[Q]]} \bigpar \ \isystemterm
			\arro{\tau} 
			\\
			\hspace{7cm}
			\addid{\iclientinst[Q]} \bigpar \ \isystemterm
		\end{array}
	}}
	\\
\end{array}
 \]

 \[
 \begin{array}{l}
    \hspace{-.3cm} \textsc{SERVER}\\
    

\mathrule{batch}
{\begin{array}{c}
  \agssegpair[@][{\amxrf[{'}]}] =\receiveroundsname{\inserver} \qquad\qquad %=\append{\emptygssegment}{rs} \qquad 
  \astate[']=\iapply{\astate}{\adelta} \\
  \forall\cid.(\outserver['] (\cid)= \outserver(\cid)\cdot\agssegpair[@][{\amxrf[{'}]}] \quad \land\quad 
  \inserver['](\cid) = \epsilon)
\end{array}
  }
  {\iserverins\ \bigpar \ \iclient
  \tr{\tau} 
  {\iserverins[{\astate[']}][{\amxrf[{'}]}][{\inserver[']}][{\outserver[']}]}\ \bigpar \ \iclient}
\\
\mbox{\henote{este receiveRounds es distinto al tuyo, hace todo de una}}
\\
\mathrule{accept-conn}
{\cid\notin \inserver \qquad \cid \notin \outserver}
{\server{\astate}{\inserver}{\outserver} \ \bigpar\  \iclient 
\tr{\tau} 
\server{\astate}{\inserver\upd\cid\epsilon}{\update{\outserver}{\cid}{\agsprefpair}}\ \bigpar\  \iclient }
\\
\mathrule{drop-conn}
{\cid \in \inserver \qquad  \cid \in \outserver}
{\server{\astate}{\inserver}{\outserver} \ \bigpar \ \iclient
\tr{\tau} 
\server{\astate}{\inserver \setminus\cid}{\outserver \setminus\cid}\ \bigpar \ \iclient} 
\\
\mathax{crash}{\server{\astate}{\inserver}{\outserver}\ \bigpar \ \iclient
 \tr{\tau} \server{\astate}{\undefined}{\undefined}\ \bigpar \ \iclient}
\\
	\mathrule{pull-2}
	{\aseqround['] = filter\ (\geq \amxrf(\cid)) \ \aseqround}
		 {\begin{array}{l}
			\addid{\iclientinst[\tpullins][@][\aseqround][@][@][@][@][{\agssegpair[{\astate[']}]}\cdot\inclient]}
			     \ \bigpar \ \iserverins[{\astate['']}][{\amxrf[']}] \ \bigpar\ \iclient
 %[]\ \bigpar \ \isystemterm
			\arro{\pulltran} 
			\\
			\hspace{1.5cm}
			\addid{\iclientinst[P]
						 [{\astate[']}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}]}
		\ \bigpar \ \iserverins[{\astate['']}][{\amxrf[']}][\inserver\upd{\cid}{\inserver(\cid)\cdot\aseqround[']}]
		\ \bigpar\ \iclient
	 	\end{array}
		}
\\
\mbox{\henote{Este se necesita para el crash y recover y el inicial}}
\\

%    \\[35pt]
%    \hspace{-.3cm} \textsc{COMMUNICATION}
%		
%\\
%    \mathrule{comm server-client}{\outserver(i)=\gs \cdot \gss}{\server{\state}{\inserver}{\outserver} \bigpar \clientr{P}{\stateclient} \arro{\tau} \server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
%		\clientr{P}{\update{E}{\inclient}{E.\inclient \cdot \gs}}}
%		
%\\[25pt]
%
%	    \mathrule{comm client-server}{\outclient=\headerround \cdot \tailround}{\server{\state}{\inserver}{\outserver} \bigpar \clientr{P}{\stateclient} \arro{\tau} \server{\state}{\update{\inserver}{i}{\inserver(i) \cdot \headerround}}{\outserver} \bigpar 
%		\clientr{P}{\update{E}{\outclient}{\tailround}}}	
% \\
%
 \end{array}
 \]


Rule $\textsc{(drop-conn)}$ removes from the server's queues the client called $b_i$. Rule $\textsc{(crash-and-recover)}$ leaves undefined the server's queues and preserves the server's persistent state.  Rule $\textsc{(accept-conn)}$ show how to add a new connecti(Read)send to its the persistent state. Last rule from \textbf{\textsc{(server)}} is Rule $\textsc{(batch)}$, the most interesting of this group. Its has three hypothesis, the first one, is responsible for receiving rounds from the queue of in-messages. Se\cond one, let $\emptygssegment$ be a empty segment, it gives back a delta object who represents the combination of numbers of rounds into a single object. Finally, this object is applied to the persistent state. As result, the persistent state is putted into the queues messages-out.

There are two \textbf{\textsc{(communications)}} rules. Rule $\textsc{(comm-server-client)}$ when the server has a message for client $i^{th}$, this is removed from the server's queue message-out and is putted into the queue message-in from client $i^{th}$. Rule $\textsc{(comm-client-server)}$ states when a round from client $i^{th}$ is left into server queue message-in.

Rule $\textsc{(Read)}$ gives the result of performing a lecture on messages queues from the client. Rule $\textsc{(update)}$ adds an update to the transaction buffer. Rule $\textsc{(push)}$ leaves into push buffer a delta object resulted of reducing the push buffer with transaction buffer. The transaction buffer is cleaned and the number of rounds sent is incremented by one. Rule $\textsc{(pull)}$ shows when a persisted state from a client is modified. The hypothesis are that a channel have been accepted, i.e., these must be defined for client $i^{th}$ besides the receive buffer should have an element at least. $\textsc{(confirmed)}$
computes the states of the internal queues,i.e., if these has any element. Rules $\textsc{(while-true)}$ and $\textsc{(while-false)}$ are standard. Rule $\textsc{(send)}$ creates a new round setting who is the client ($i^{th}$), how many rounds client ($i^{th}$) has sent and content from the push buffer. Finally rule $\textsc{(receive)}$ move out segments from the client's queue message-in to receive buffer.

\section{Equivalence}

We have introduced an abstract GSP protocol and a robust streaming server-client implementation of GSP. There exists a relation represented by $\triangleleft$ [~ref:] which relates state and delta objects to the update sequences. 
\begin{itemize}
	\item On $\mathit{Delta} \times \mathit{Update}^*$, let $\triangleleft$ be the smallest relation such that (1) $\emptydelta \triangleleft []$, and
(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates $u$, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$ and (4) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $\remove{d_1 \ldots d_{n}}{d_n} \triangleleft a_1 \cdots a_{n-1}$. \marginpar{El (4) lo agregamos nosotros. Â¿Se aclara? Â¿C\'omo?}
  
\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $\initialstate \triangleleft []$, and
(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
\end{itemize}

Next theorem states one of most important result of the paper, saying that abstract GSP protocol and the implementation of GSP are weak bisimulation equivalent (or weakly bisimilar). 

\begin{definition} Let  $\systemterm = \abstsyst[@][@][{\abstcliJ}]$ be a \tgspcalculus\ system and $\isystemterm = \concsyst$ an implementation
system. We say $\isystemterm$ implements $\systemterm$ if the following conditions hold:

\begin{enumerate}
	\item $\rvalue{r}{\flatten{\queuemessage_{A}[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}}$
	\item $\queuemessage_C.\state \triangleleft \queuemessage_A$
	\item $\ E_{i}.\transactionbuffer \triangleleft [\ttransactionbuffer_i]$
	\item $E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i - 1]$
	\item $E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1]$
	\item $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$
	\item For all natural $l$, such that $1 \leq l < |\inclient|$ then $E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l]$
	\item $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$
	\item For all update sequence $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$
		\item For all natural $m$, such that $0 \leq m < |\outserver(i)| - 1$ then $\outserver(i)[m] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient| + m]$
\end{enumerate}
 
\end{definition}
\begin{theorem}
Let $A$ be a system from abstract GSP Protocol, defined as  then both system are weakly bisimilar, written $A \approx C$, if $(A,C)  \in \ \mathcal{R}$, where $\mathcal{R}$ be a binary relation defined as $\{ (\parallel_{i \ \in\ I_{\{0 \ldots n\}}} A_i \parallel \ \queuemessage_A),(\parallel_{i \ \in\ I_{\{0 \ldots n\}}} C_i \parallel \ \queuemessage_C) \ | \ \forall i \ \in\ \mathbb{N}, \forall r: \readtype, A_i = \ \tclient{\tprogram_i}{\tknown_i}{\tpending_i}{\ttransactionbuffer_i}{\tsent_i}{\treceivebuffer_i} \land C_i = \client{P_i}{\stateclient_i}$ and the conjunction of the following properties: %\land \ \rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}} \land \ \queuemessage_C.\state \triangleleft \queuemessage_A \land \ E_{i}.\transactionbuffer = [\ttransactionbuffer_i] \land \ E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i] - 1 \ \land \ E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \ \land \  E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i \ \land \ \forall l, 1 \leq l < |\inclient|, E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l] \ \land \ \tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0 \ \land \ \forall \beta \ \in \ \tsent_i, \beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver
\marginpar{Ac\'Ã¡ deber\'ia decir que R cumple las propiedades de weak bisimulation. C\'omo lo escribo mejor?}
\end{theorem}



\begin{proof}

The proof follows by induction on the length of the derivation $\arro{} ^*$. We use $\tilde{A}$ and $\tilde{C}$ to denote clients, except client $i^{th}$, interacting concurrently, i.e., $\parallel_{j \ \in\ I_{\{0 \ldots n\} - i}}$ $A_j$ or $C_j$ respectively.

\begin{itemize}
   
	
   \item{\bf n=k+1}. $\forall (A,C) \ \in \ \mathcal{R}$
	
			
			\begin{itemize}
				\item {\bf rule (\textsc{t-read})}. If $A \arroi{\readtran{r}} A'$, then by rule (\textsc{\footnotesize{t-read}}), $A$ must be the following term: $ \tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\update{\tprogram}{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. As $(A,C)$ belongs $\mathcal{R}$ then $C$ must be $\clientr{\readins{x}{r}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $C$ could perform.
				Then, looking at the rule, $C' = \clientr{\update{P}{x}{v}}{\stateclient}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					\begin{enumerate}
						\item It is easy to see, since $P$ is the same in both clients and the value got back by each read operations is equals because of $(A,C) \ \in \ \mathcal{R}$ then property 1 is worth. 
						\item to 9. Do not change.
						

					\end{enumerate}
	
			\item {\bf rule (\textsc{t-update})}. If $A \arroi{\updatetran{u}} A'$, then by rule (\textsc{\footnotesize{t-update}}), $A$ must be the following term: $ \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. We know that $(A,C)$ belongs $\mathcal{R}$, then $C$ must be $\clientr{\updateins{u}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the update transition is the only one that $C$ could perform. Then, $C' = \clientr{P}{\update{E}{\transactionbuffer}{\appendplus{E.\transactionbuffer}{u}}}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if ten properties introduced are keeping.					
						\begin{enumerate}
							\item States $\rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown_i-1] \cdot \tpending_i) \cdot \ttransactionbuffer_i} = \readp{r}{\applyplus{E_{i}.\known}{E_{i}.\pending \cdot E_{i}.\pushbuffer \cdot E_{i}.\transactionbuffer}}$ however after applying rules, the transaction buffers change. Then, performing a read action in abstract GSP, $\rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown_i-1] \cdot \tpending_i) \cdot \ttransactionbuffer_i \cdot \tupdate}$ and the implementation, $\readp{r}{\applyplus{E_{i}.\known}{E_{i}.\pending \cdot E_{i}.\pushbuffer \cdot \appendplus{E.\transactionbuffer}{u}}}$. We rename $\ttransactionbuffer \cdot \tupdate$ by $\ttransactionbuffer$' and  $\appendplus{E.\transactionbuffer}{u}$ by $E_{i}.\transactionbuffer$'. If we show that $\forall u: Update$ such that $\appendplus{E.\transactionbuffer}{u} \triangleleft \ttransactionbuffer \cdot \tupdate$, we will prove that $(A',C') \ \in \ \mathcal{R}$. By property 3, we know that $\ E_{i}.\transactionbuffer \triangleleft [\ttransactionbuffer_i]$, using the property of relation between Delta and Update, $\appendplus{E.\transactionbuffer}{u} \triangleleft \ttransactionbuffer \cdot \tupdate$.
							\item to 9. Do not change.
						
						\end{enumerate}
	
\item {\bf rule (\textsc{t-push})}. If $A \arroi{\pushtran} A'$, then by rule (\textsc{\footnotesize{t-push}}), $A$ must be the following term: $ \tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot [\ttransactionbuffer]}{\ttransactionbuffer \cdot \tupdate}{\tsent \cdot [\ttransactionbuffer]}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. We know that $(A,C)$ belongs $\mathcal{R}$, then $C$ must be $\clientr{\pushins}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the push transition is the only one that $C$ could perform. Then, after applying the rule, $C' = \clientr{P}{\updatethree{E}{\pushbuffer}{\reduce{E.\pushbuffer\cdot E.\transactionbuffer}}{\transactionbuffer}{\epsilon}{\nround}{E.\nround+1}}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if ten properties introduced are keeping.					
						\begin{enumerate}
							\item We have to prove that after push transitions, the operations $rvalue$ and $read$ get back the same value. Then $\rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown_i-1] \cdot \tpending_i) \cdot \ttransactionbuffer_i} = \rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown_i-1] \cdot (\tpending_i \cdot [\ttransactionbuffer_i])) \cdot \epsilon}$ by Lemma XX besides $\readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}}$ = $
						\readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{ \reduce{E.\pushbuffer\cdot E.\transactionbuffer}}{\epsilon}}$ by Lemma YY.
							\item It does not change.
							\item $E_{i}.\transactionbuffer = \epsilon$ and $\ttransactionbuffer_i = \epsilon$. Using the property of the relation $\triangleleft$, $\epsilon \triangleleft \epsilon$ 
							\item It does not change.
							\item It does not change.
							\item States $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$ besides by 3. $\ E_{i}.\transactionbuffer \triangleleft [\ttransactionbuffer_i]$. Finally, applying the property of the relation $\triangleleft$, $\reduce{E_i.\pending \cdot E_i.\pushbuffer \cdot E_i.\transactionbuffer} \triangleleft \tpending_i \cdot [\ttransactionbuffer_i]$.
						  \item to 9. do not change.
						\end{enumerate}
						\item {\bf rule (\textsc{t-pull})}. If $A \arroi{\pulltran} A'$, then by rule (\textsc{\footnotesize{t-pull}}), $A$ must be the following term: $ \tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]}{\ttransactionbuffer}{\tsent}{0} \bigpar \ \tilde{A} \bigpar\ \queuemessage_A$. Due to $(A,C)$ belongs $\mathcal{R}$, then $C$ must be $\clientr{\pullins}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the pull transition is the only one that $C$ could perform. Then, after applying the rule, $C' = \clientr{P}{\updatethree{E}{\known}{\reducestate{E.\known}{E.\receivebuffer}}{\receivebuffer}{\epsilon}{E.\pending}{\remove{E.\pending}{E.\receivebuffer}}} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if ten properties introduced are keeping.	
						
						\begin{enumerate}
							\item We have to prove that after push transitions, the operations $rvalue$ and $read$ get back the same value. Then 
							$\rvalue{r}{\flatten{\queuemessage_{A}[0..\tknown_i+\treceivebuffer-1] \cdot (\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer])} \cdot \ttransactionbuffer_i} = \readp{r}{\curstate{\reducestate{E.\known}{E.\receivebuffer}}{\remove{E.\pending}{E.\receivebuffer}}{E.\pushbuffer}{E.\transactionbuffer}}$ = $\readp{r}{\applyplus{\reducestate{E.\known}{E.\receivebuffer}}{\remove{E.\pending}{E.\receivebuffer} \cdot E.\pushbuffer \cdot E.\transactionbuffer}}$. On the one hand, property 5 states that $E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1]$, on the other hand by property 4, $E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i -1]$, after, using the property of the relation $\triangleleft$ between state and updates, we know that $\applyplus{E_{i}.\known}{E_{i}.\receivebuffer[0].delta \cdots \ E_{i}.\receivebuffer[\treceivebuffer_i-1].delta} \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \cdot  \cdots  \cdot \ \queuemessage_A[\tknown_i + \treceivebuffer_i -1]$. As you note, the left side is reducestate's definition, then $\reducestate{E.\known}{E.\receivebuffer} u\triangleleft \queuemessage_A[0 \ldots \tknown_i + \treceivebuffer_i -1]$. Next, property by 6., we know that $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$, if we apply the extra axiom of $\triangleleft$, we will get that $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer[0].delta} \triangleleft \tpending \setminus \queuemessage[\tknown]$, so that, $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer} \triangleleft \tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]$. Therefore it is guaranteed.
							\item It does not change.
							\item It does not change.
							\item $E_{i}.\receivebuffer$ is $\epsilon$ and $\treceivebuffer$ is 0, therefore it property is guaranteed.
							\item It does not change.
							\item We know that $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$, if we apply the extra axiom of $\triangleleft$, we will get that $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer[0].delta} \triangleleft \tpending \setminus \queuemessage[\tknown]$, so that, $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer} \triangleleft \tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]$.
							\item to 9. do not change.
						\end{enumerate}
					\item {\bf rule (\textsc{t-confirmed})} If $A \arroi{\confirmedtran} A'$, then by rule (\textsc{\footnotesize{t-confirmed}}), $A$ must be the following term: $ \tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\update{\tprogram}{x}{\tpending \neq \emptysequence \vee\ \ttransactionbuffer \neq \epsilon}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. As $(A,C)$ belongs $\mathcal{R}$ then $C$ must be $\clientr{\confirmedins{x}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $C$ could perform.
				Then, looking at the rule, $C' = \clientr{\update{P}{x \mapsto E.\pending = \epsilon \lor E.\pushbuffer = \epsilon \lor E.\transactionbuffer = \epsilon}{\textbf{true}}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					\begin{enumerate}
						\item Both clients has the same program $P$. By 6. we know that the value of $E.\pending \cdot E.\pushbuffer$ is related to $\tpending$, thereby, when E.$\pending$ or E.$\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\ E_{i}.\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has by property 3.
						\item to 9. Do not change.
					\end{enumerate}
					\item {\bf rule (\textsc{t-receive})} If $A \arroi{\tau} A'$, then by internal rule (\textsc{\footnotesize{t-receive}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + 1}\bigpar\ C}{\queuemessage}$. As	$(A,C)$ belongs $\mathcal{R}$ then $C$ must be $\clientr{\tprogram}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, such that after internal transitions $\tau$, it will become $C'$. By Hypothesis of (\textsc{\footnotesize{t-receive}}, we know that $\tknown + \treceivebuffer + 1 \leq \text{\textbar} S_A \text{\textbar}$, then, by Property 8., $|E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$. We will consider two cases:
						
						\begin{itemize}
							\item $|E_{i}.\inclient| > 0$, then $|E_{i}.\inclient|$ has a $GsSegment$ at least, i.e., $E.\inclient = \gs_0 \cdot \gs_t$. If $C$ took the internal rule (\textsc{\footnotesize{RECEIVE}}), we will get the following $C'$ termn, $\clientr{P}{\updatetwo{E}{\receivebuffer}{E.\receivebuffer \cdot \gs_0.gssegment)}{\inclient}{\gs_t)}}$. Now, we will check if $(A',C')$ belongs to $\mathcal{R}$.
							
							\begin{enumerate}
								\item The inputs term in read operation have not changed.
								\item It does not change.
								\item It does not change.
								\item Term $\treceivebuffer$ was incremented by 1. Then, we should prove that $E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[(j+1) - 1].delta \triangleleft \queuemessage_A[\tknown_i + (\treceivebuffer_i+1) - 1]$ is guaranteed. By Property 4., we only should prove $E_{i}.\receivebuffer[j].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i]$ allow $(A',C')$ to belong to $\mathcal{R}$. It worths by Property 7., in particular with $l$ = 1.  
								\item It does not change.
								\item It does not change.
							  \item It is easy to see such that $|\inclient'| < |\inclient|$, then we use Property 7.
								\item to 9. They do not change.
							\end{enumerate}
						\end{itemize}
					\item $|\queuemessage_C.\outserver| > 0$, then $|\queuemessage_C.\outserver|$ has a $GsSegment$ at least, i.e., $\queuemessage_C.\outserver(i)$ = $\gs \cdot \gss$. Then, by internal rule (\textsc{\footnotesize{comm-server-client}} we get $\update{\outserver}{i}{\gss}$ and $\update{E}{\inclient}{E.\inclient \cup \{\gs\}}$. Then, by internal rule (\textsc{\footnotesize{recieve}}), we get a term who has $|E_{i}.\inclient| > 0$. The rest of the prove is equivalent to above case.
						
\item {\bf rule (\textsc{t-process})} If $A \arroi{\tau} A'$, then by rule (\textsc{\footnotesize{t-process}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\tsenthead] \cdot \tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage \cdot \tsenthead}$. Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. Analyzing cases:
					
					
					
					\begin{itemize}
						\item If $\beta \ \in\ E_{i}.\outclient$ then, by rule (\textsc{\footnotesize{comm-client-server}}), $C \arroi{\tau} C'$, so that, $C'$ = $\clientr{P}{\update{E}{\outclient}{\tailround}} \bigpar\ \tilde{C} \ \bigpar\ \ \server{\state}{\update{\inserver}{i}{\headerround}}{\outserver}_C$ and $\delta_0 \triangleleft \beta$. Performing a new internal action by rule (\textsc{\footnotesize{batch}}),i.e., $C' \arroi{\tau} C''$, then $C''$ = $\server{\apply{\persistedstate}{d}}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}  \bigpar\ \tilde{C} \bigpar \clientr{P}{\stateclient}$. We have to prove that $(A',C'')$ belongs $\mathcal{R}$.
						
						\begin{enumerate}
							\item Theirs terms do not change.
							\item Our hypothesis is $\queuemessage_C.\state \triangleleft \queuemessage_A$ besides $\delta_0 \triangleleft \beta$, then using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item $\queuemessage_A$  has incremented by one, so that, by Hypothesis, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$, besides, $\Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$ because of neither $E_{i}.\inclient$ nor $\queuemessage_C.\outserver$ have changed.
\item By Hypothesis, for all element in $\tsent$, those belongs to $E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$, in particular, $\tsent$ without a element keeps these guarantee.
						\end{enumerate}
\item If $\beta \ \in\ E_{i}.\inserver$ then, applying rule (\textsc{\footnotesize{batch}}), we can see that we are at above case.
					\end{itemize}
					
\end{itemize}

\end{itemize}

We have prove that if $A$ perform an action, $C$ also can perform an action, the terms after both transitions are in $\mathcal{R}$. Now, we will prove the opposite side. When $C$ perform an action, then A can perform an action and the news terms are in $\mathcal{R}$.


\begin{itemize}
   \item{\bf n=0}. Then $C$ = $\clientr{E}{\initialstate}$ and $A$ = $\tsystem{\tclienti{0}{\emptyset}{\emptyset}{\emptyset}{\emptyset}{0}\ \bigpar\ \tilde{A}}{\queuemessage_A}$. It is analogous to the base case previously proved.
			
   \item{\bf n=k+1}. $\forall (C,A) \ \in \ \mathcal{R}$
	
			
			\begin{itemize}
				\item {\bf rule (\textsc{comm-server-client})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-server-client}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					\begin{enumerate}
						\item to 6. Their terms do not changed.
						\setcounter{enumi}{6}	
							\item $l'$ = $(|E_{i}.\inclient| + 1)$, so that, we have to prove that $E_{i}.\inclient[l'] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 + l']$, however, it easy to see because by property 10. when $m$ = 0 then $\outserver(i)[0] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient|]$.
						\item It is easy to see that $(|E_{i}.\inclient| + 1) + (|\queuemessage_C.\outserver|-1) > 0$.
						\item It does not change.
						\item It is easy to see, because, Property 10 is guaranteed with $0 \leq l$ therefore $1 \leq l$. 
					\end{enumerate}
					
					
				\item {\bf rule (\textsc{comm-client-server})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-client-server}}), $C'$ must be the following term: $\server{ps'}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}$, therefore, the client $i^{th}$ is the only one who has changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.				
					\begin{enumerate}
						\item to 8. Their terms do not changed.
						\setcounter{enumi}{8}	
						\item It is easy to see, because, we have exchanged a sequence from $\outclient$ to $\inserver$. 
						\item It does not change.
						\end{enumerate}
				


				
						\item {\bf rule (\textsc{batch})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{batch}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. Hence	$(C,A)$ belongs to $\mathcal{R}$ then $A$ after of internal transition $\tau$ is $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ S_C}{\queuemessage \cdot \tsenthead}$. We will prove that $(C',A') \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.	
				\begin{enumerate}
						\item Their terms do not change.
						\item Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. In particular, we consider $\beta \ \in \ \queuemessage_C.\inserver$, then there exists $\delta_o$ such that $\delta_0 \triangleleft \beta$, besides by Property 2., $\queuemessage_C.\state \triangleleft \queuemessage_A$, so that using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item $\queuemessage_C.\outserver$ is updated with the new persisted state however its size does not change. By Hypothesis 9, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$.
							\item It does not change.
							\item It does not change.

						\end{enumerate}
		

				
			\end{itemize}
		\end{itemize}
		
\end{proof}


\section{Consistency Guarantees}
\label{sec:properties-gsp}

We shall introduce a series of store-level consistency guarantees and then we shall show which are captured by application written in GSP. We start identifying three kinds of relations between actions of update and read:

 \paragraph{Session Order} relates whatever pair of actions from the same client, indicating the program order. It is a total order on actions. 

 \paragraph{Visibility} relates Updates with Reads. It is used to indicate is if an action of Update is visible for an action of Read.

 \paragraph{Arbitration} relates Updates with Updates. It is used to resolve update conflicts. It is a total order on actions of update.




We extend the GSP language with a new term which capture the relations amount operation in our system. 
 
\[
    \begin{array}{l@{\quad}r@{\;::=\;}l}
			 (\textsc{environment}) & \environmentterm &  \environment{\systemterm}{\op}{\so}{\vis}{\arb} \\
	    \end{array}
  \]
	
Let $\environmentterm$, a new term, where $\systemterm$ represents our system introduced in Definition 1.1, $\op$ is a mapping of vertices to actions, $\so$ is a session order relation defined from vertices to relations of vertices $\verticesets$ $\times$ ($\verticesets$ $\times$ $\verticesets$) and $\vis$,$\arb$ are visibility and arbitration relation.


 \paragraph{Notation.} Given a session order relation $\so$ from client $i$ and a vertex $v$, we shall write $\soby{\so}{v}$  meaning that $\soby{(\mathcal{V}, \mathcal{R})}{v} = (\mathcal{V} \ \cup \ \{v\}, \mathcal{R}\ \cup \ \{(x,v) / x \in \verticesets\})$. We shall refer to an update action on the queue message as $\updateinqueuemessage{n}{i}$.The arbitration relation $\arb$ is defined as $\{ (v,w) / \{v \mapsto \updateinqueuemessage{m}{h}\} \in \op \land \ \{w \mapsto \updateinqueuemessage{n}{i} \} \in \op \land \ m < n \}$. A transition $\arroi{\alpha}$ denotes the fact that action $\alpha$ is perfomed by client $i$.

 
The following operational semantic allow to understand how working the environment when the actions are executed.

 \[
 \begin{array}{l}
		
\mathrule{e-read}{\systemterm \arroi{\readtran{r}} \systemterm' \qquad v \notin 
dom(\op) \qquad \ \vis' = \vis \ \cup \ \{ (x,v) / \{x \mapsto \updatebyclient{h}\} \in \op \ \land \  u^x \in \ \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer] \}}{\environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\readtran{r}} \environment{\systemterm'}{\op \ \cup \ \{v \mapsto \readtran{r}\} }{\soby{\so}{v}}{\vis'}{\arb}}

 \\[35pt]

		\mathrule{e-update}{\systemterm \arroi{\updatevtran{u}{v}} \systemterm' \qquad v \notin 
dom(\op)}{\environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\updatevtran{u}{v}} \environment{\systemterm'}{\op \ \cup \ \{v \mapsto \updatetran{u} \}}{\soby{\so}{v}}{\vis}{\arb}}
 
 \end{array}
 \]

\subsection{Ordering Guarantees}

We now prove what ordering guarantees are assured by GSP language and what do not. 


First, we prove a useful lemma: 
\begin{lemma}\label{lemma:update-ever-belong} Let u an update action, $\queuemessage$ a message queue, $\tpending_i$ and $\ttransactionbuffer_i$ a pending queue and transaction queue from the client i, if $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $\{x \mapsto \updatebyclient{i} \}\ \in \ \op\ \Rightarrow\ u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$

\end{lemma}

\begin{proof} The proof follows by induction on the length of the derivation $\arro{} ^*$.
\begin{itemize}
   \item{\bf n=0}. Then $\op$ is $\emptyset$, so that antecedent is false, then the preoposition is true.
   \item{\bf n=k+1}. Then $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{} \{x \mapsto \updatebyclient{i} \}\ \in \ \op\ \Rightarrow\ u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. We proceed by 
case analysis on the last transition:
	
	\begin{itemize}
        \item {\bf rule (\textsc{E-READ})}. As $x$ is an update operation then it must not be $v$, so that $\{x \mapsto \updatebyclient{i} \} \in\ \op$, then by inductive hypothesis $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. When $\systemterm \arroi{\readtran{r}} \systemterm'$, $\tknown_i$, $\tpending_i$,$\ttransactionbuffer_i$ do not change.
				\item {\bf rule (\textsc{E-UPDATE})}. There are two possibilities:
				
				
					\begin{itemize}
						\item {\bf $x \neq v$}. Then we can use inductive hypothesis, so that it is easy to see that if $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$ then $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i] \cdot u_{t}^v$ too.
						\item {\bf $x =\ v$}. When $\systemterm \arroi{\updatevtran{u}{v}} \systemterm'$, $u^v \in \ttransactionbuffer'_i$ (with $\ttransactionbuffer'_i$ transaction queue in $\systemterm'$) because $\ttransactionbuffer'_i = \ttransactionbuffer_i \cdot u^v$. It is immediate to note that $u^x \in\  \queuemessage[0..\tknown'_i-1] \cdot \tpending'_i \cdot [\ttransactionbuffer'_i]$.
					\end{itemize}
				\item {\bf rule (\textsc{E-PUSH})}. As $\op$ do not change, then by inductive hypothesis, $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i] \equiv\ u^x \in\  \queuemessage[0..\tknown_i-1] \cdot (\tpending_i \cdot [\ttransactionbuffer_i]) \cdot \epsilon$. When $\systemterm \arroi{\pushtran} \systemterm'$, $\tknown_i$' = $\tknown_i$, $\tpending_i$' = $\tpending_i \cdot [\ttransactionbuffer_i]$ and $\ttransactionbuffer_i$' = $\epsilon$.
\item {\bf rule (\textsc{E-PULL})}. As $\op$ do not change, then by inductive hypothesis, $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. We should prove that it is equivalent to $u^x \in\  \queuemessage[0..\tknown_i - 1 + \treceivebuffer_i] \cdot \tpending_i \setminus \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i] \cdot [\ttransactionbuffer_i]$. There are two interesting cases to consider:
		\begin{itemize}
			\item If $u^x \in\ \tpending_i\  \land\ u^x \notin\ \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i]$, then $u^x \in \ \tpending_i$'.
			\item If $u^x \in\ \tpending_i\  \land\ u^x \in\ \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i]$, then $u^x \notin \ \tpending_i$' but $u^x \in\ \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i]$. 
		\end{itemize}
\end{itemize}
\end{itemize}

The proof for the remaining cases is by inductive hypothesis because $\op$, $\tknown_i$, $\tpending_i$ and $\ttransactionbuffer_i$ do not change.

\end{proof}

\begin{theorem}[\textsc{Read My Writes}]\label{theorem:read-my-writes}

Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $\textsc{\small{SO}}_R \cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS}}$

\end{theorem}


\begin{proof} The proof follows by induction on the length of the derivation $\arro{} ^*$.
\begin{itemize}
   \item{\bf n=0}. In particular $\op$ and $\vis$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Then $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\alpha} \environment{\systemterm'}{\op'}{\so'}{\vis'}{\arb}$. We proceed by 
definition:
	
	\begin{itemize}
        \item $\textsc{\small{SO}}_R$' = $\textsc{\small{SO}}_R \cup\ \{(w,v) / \{w \mapsto \readtran{r}\} \lor\ \{w \mapsto \ \updatebyclient{j}\} \}$. Applying the intersection $(\mathbb{U}\ \times \ \mathbb{R})$, we shall obtain $\textsc{\small{SO}}_R \ \cup\ \{(w,v) / \{w \mapsto \updatebyclient{j}\} \}$.				
				\item $\vis' = \vis \ \cup \ \{ (x,v) / \{x \mapsto \updatebyclient{h}\} \in \op \ \land \  u^x \in \ \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer] \}$.
\end{itemize}
By inductive hypothesis, $\textsc{\small{SO}}_R \ \cup\ (\mathbb{U}\ \times \ \mathbb{R}) \subseteq \vis$. We only have to prove that $\{(w,v) / \{w \mapsto \updatebyclient{j}\} \in \op  \ \} \subseteq \{ (x,v) / \{x \mapsto \updatebyclient{h}\} \in \op \ \land \  u^x \in \ \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer] \}$. When $j = h$ and $w = x$, we can use Lemma~\ref{lemma:update-ever-belong}. So that, we have proved that $\textsc{\small{SO}}_R$' $\cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS'}}$.
\end{itemize}
\end{proof}



\begin{theorem}[\textsc{Monotonic Read}]
\label{theorem:monotonic-read}
Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $(\textsc{\small{VIS}};\textsc{\small{SO}}_R) \cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS}}$

\end{theorem}


\begin{proof} The proof follows by induction on the length of the derivation $\arro{} ^*$.
\begin{itemize}
   \item{\bf n=0}. In particular $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Then $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\alpha} \environment{\systemterm'}{\op'}{\so'}{\vis'}{\arb}$. Let $R$ be a composition of relations. We shall say that if $(x,y) \in \ R $ iff $\ \exists y \in\ \verticesets\ $ such that $(x,y) \in\ \textsc{\small{VIS}}' \land \ (y,z) \in\  \textsc{\small{SO}}_R$'. We have to prove that $(x,z) \in \ \textsc{\small{VIS}}$'. We proceed by 
case analysis on the last transition:
	
	\begin{itemize}
        \item {\bf rule (\textsc{E-READ})}. We know that $v$ is fresh, therefore, $v$ have not be neither $x$ nor $y$ because there exists $z$ such that, $z$ happens after from $x$ and $y$. There are only two possibilities:
					
					\begin{itemize}
						\item $z = v$. As $(y,z) \in \ \textsc{\small{SO}}_R$, then $y$ and $z$ are from the same client, called $i$. We are only interested in relations of $update \times\ read$. We know that $v$ is associated to an read action besides $x$ have to be an update action. As $(x,y) \in \ \textsc{\small{VIS}}$' then $y$ is an read action,i.e., $\{y \mapsto \readbyclient{i} \}\ \in \ \op$.By Lemma xx, there exists an update $u$ such that $u^x \in\ \ \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. Substituting $w$ by $v$ in $\textsc{\small{VIS}}$', we prove that $(x,z) \in \textsc{\small{VIS}}$'.
						item $z \neq v$. This case follows immediately by inductive hypothesis.
					\end{itemize}
					
			  \item{\bf rule (\textsc{E-UPDATE})}. Visibility relation does not change,i.e.,$\textsc{\small{VIS}}$ = $\textsc{\small{VIS}}$'. Let $v$ be a vertex associated an update action, then $\textsc{\small{SO}}_R$' = $\textsc{\small{SO}}_R \cup\ \{(w,v) / \{w \mapsto \readtran{r}\} \lor\ \{w \mapsto \ \updatebyclient{j}\} \}$. As we are only interested in relations of $update \times\ read$, then $(\textsc{\small{VIS}}';\textsc{\small{SO}'}_R) \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \equiv \ (\textsc{\small{VIS}};\textsc{\small{SO}}_R) \cap \ (\mathbb{U}\ \times \ \mathbb{R})$. By inductive hypothesis we can prove that $(\textsc{\small{VIS}}';\textsc{\small{SO}}_R)' \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \ \subseteq \ \textsc{\small{VIS}} \subseteq \ \textsc{\small{VIS}}$'.				
				The proof for the remaining cases follow are not interesting because the relations does not change.
\end{itemize}
\end{itemize}
\end{proof}



\begin{theorem}[\textsc{No Circular Causality}]

Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $\textbf{acyclic}(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^+$.

\end{theorem}

\begin{proof}

Since $\textsc{\small{VIS}}$ is acyclic and $\textsc{\small{SO}}_R \cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS}}$ by Theorem~\ref{lemma:update-ever-belong}, we have to prove that $\textsc{\small{VIS}} ^+$ is acyclic. In particular, the transitive closure of an acyclic graph is the reachability relation of the directed acyclic graph and a strict partial order.

\end{proof}





\begin{theorem}[\textsc{Causal Visibility}]

Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{+} \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \subseteq \textsc{\small{VIS}}.$ 

\end{theorem}
 

\begin{proof} The proof follows by induction on the number of union sets between $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$. Then, $\bigcup_{n=1}^{\infty} (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{n} \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \subseteq \textsc{\small{VIS}}.$
\begin{itemize}
   \item{\bf n=0}. This means that $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Suppose that we have proved that the number of union sets $< k+1$. Now, we have to prove that: $\forall (a,b) \mid (a,b \in \verticesets \Rightarrow\ (a,b)\ \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1} \cap \ (\mathbb{U}\ \times \ \mathbb{R})) \Rightarrow\ (a,b) \in \textsc{\small{VIS}}$.
	
Assume $(a, x_1),(x_1, x_2),\ldots(x_{k{-}1}, x_k),(x_{k}, b)$ are relations from $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$. Then $(a, x_1),(x_1, x_2),\ldots(x_{k{-}1}, x_k)$ are relations from $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$. By the induction hypothesis, $(a, x_k) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$, and we also have $(x_k, b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} )$. Thus by the definition of $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$, $(a, b) \in
(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$.
Conversely, assume $(a,b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$ = $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k} \circ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}})$. Then there is a vertex $c \in \verticesets$ such
that $(a,c) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$ and $(c, b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} )$.

We are only interested when $a$ is an update action and $b$ a read action. It is because of the intersection with $(Update \times Read)$. We have two possible cases:

\begin{itemize}
	\item c is a read action. It means that $(c, b)$ only can be in $\textsc{\small{SO}}_R$ because $\textsc{\small{VIS}}$ requires that $c$ will be an update action. In particular, if  $(c, b) \in\ \textsc{\small{SO}}_R$, they belong to the same client. 
	
	\begin{itemize}
		\item if $(a,c) \in\ \textsc{\small{VIS}}$ and $(c,b) \in\ \textsc{\small{SO}}_R$, by Theorem~\ref{theorem:monotonic-read}, $(a,b) \in\ \textsc{\small{VIS}}$.
		
		\item if $(a,c) \in\ \textsc{\small{SO}}_R$ then by Theorem~\ref{theorem:read-my-writes}, $(a,c) \in\ \textsc{\small{VIS}}$- Then, it is analogous to the previous case.
		
	\end{itemize}
	\item c is an update action. It means that $(a, c)$ only can be in $\textsc{\small{SO}}_R$ because $\textsc{\small{VIS}}$ requires that $c$ will be an read action. In particular, if  $(a,c) \in\ \textsc{\small{SO}}_R$, they belong to the same client.
	
	\begin{itemize}
		\item if $(a,c) \in\ \textsc{\small{SO}}_R$ and $(c,b) \in \textsc{\small{VIS}}$, by Theorem Monotonic Writes (Falta probar!), $(a,b) \in\ \textsc{\small{VIS}}$.
		\item if $(a,c) \in\ \textsc{\small{VIS}}$ ... VER.
	\end{itemize}
\end{itemize}


	
	
\end{itemize}
\end{proof}


\begin{theorem}[\textsc{Causal Arbitration}]

Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$, $\textsc{\small{VIS}}$ a visibility relation and $\textsc{\small{AR}}$ an arbitration relation then $(\mathbb{U}\ \times \ \mathbb{U}) \cap \ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{+} - \textsc{\small{SO}}_R \subseteq \textsc{\small{AR}}.$ 

\end{theorem}
 

\begin{proof} 
The proof follows by induction on the number of union sets between $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$. Then, $(\mathbb{U}\ \times \ \mathbb{U}) \cap \ \bigcup_{n=1}^{\infty} (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{n} - \textsc{\small{SO}}_R \subseteq \textsc{\small{AR}}.$


\begin{itemize}
   \item{\bf n=0}. This means that $\textsc{\small{SO}}_R$, $\textsc{\small{VIS}}$ and  $\textsc{\small{AR}}$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Suppose that we have proved that the number of union sets $< k+1$. Now, we have to prove that: $\forall (a,b) \mid (a,b \in \verticesets \Rightarrow\ (a,b)\ \in\ (\mathbb{U}\ \times \ \mathbb{U}) \cap \ \bigcup_{n=1}^{\infty} (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1} - \textsc{\small{SO}}_R \Rightarrow\ (a,b) \in \textsc{\small{AR}}$. 

Assume $(a,b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1} $ = $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k} \circ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}})$. Then there is a vertex $c \in \verticesets$ such
that $(a,c) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$ and $(c, b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} )$.

We are only interested when $a$ and $b$ are an update actions. It is because of the intersection with $(Update \times Update)$. We have two possible cases:
\begin{itemize}
	\item c is a read action. It means that $(c,b)$ only can be in $\textsc{\small{SO}}_R$ because $\textsc{\small{VIS}}$ requires that $c$ will be an update action. In particular, if  $(c,b) \in\ \textsc{\small{SO}}_R$, they belong to the same client. COMPLETAR
	
	\item c is an update action. COMPLETAR
\end{itemize}
\end{itemize}

\end{proof}


\begin{example}[Consistent Prefix] 
\label{consistent-prefix}Consider the following system built-up from two 
different client:

\[
\begin{array}{l}
E = \environment{\tclient{\textit{update(aList.add('a'));push();}}{0}{\epsilon}{\epsilon}{\epsilon}{0}[1]\ \bigpar\
\\
\tclient{\textit{update(aList.add('b'));push();let v = read(x);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}[2]  \bigpar\ \epsilon}{\emptyset}{\emptyset}{\emptyset}{\emptyset}
\end{array}
\]
\end{example}
		
Environment has a system $\systemterm$ with two clients and a message queue $S$ without updates. Relation sets $\op$,$\so$,$\vis$,$\arb$ are empty, i.e.,there were not an execution in $\systemterm$ captured by the relation sets. The update action add a string to an object called $aList$ which has not elements. 
In this state, $C_1$ and $C_2$ can perform their update actions. E may non-deterministically choose to do $update(aList.add('a')$ or $update(aList.add('b')$. If the first communication takes place over $update(aList.add('a')$, then the system evolves as follows:

\[
\begin{array}{l}
E \arrobyclient{\updatevtran{aList.add('a')}{{v_0}}}{1} \environment{\tclient{push();}{0}{\epsilon}{[aList.add('a')]}{\epsilon}{0}[1]\ \bigpar\
\\
\tclient{\textit{update(aList.add('b'));push();let x = read(aList);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}[2]  \bigpar\ \epsilon} 
{\\ \emptyset}{\{( \{ v_0 \} , \emptyset ) \}}{\emptyset}{\emptyset} 
\end{array}
\]

The action $\updatetran{aList.add('a')}$ of the client $1$ will be identified by vertex $v_0$ by rule $\textsc{\small{E-UPDATE}}$. In particular, the update action will be left into the transactional queue of Client $1$ besides the new vertex will be added to vertices in $\so$. Now, Client 1 performs $\pushtran$: 

\[
\begin{array}{l}
E \arrobyclient{\pushtran}{1} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{[aList.add('a')]}{0}[1]\ \bigpar\
\\
\tclient{\textit{update(aList.add('b'));push();let x = read(aList);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}[2]  \bigpar\ \epsilon} 
{\\ \emptyset}{\{( \{ v_0 \} , \emptyset ) \}}{\emptyset}{\emptyset} 
\end{array}
\]
		
When it happens, $aList.add('a')$ is moved to the sent queue and pending queue. At this moment, Client 2 can perform an update action however Client 1 will realize an internal action which is given by $\textsc{\small{E-PROCESS}}$.  			

\[
\begin{array}{l}
E \arrobyclient{\tau}{1} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}[1]\ \bigpar\ \\
\tclient{\textit{update(aList.add('b'));push();let x = read(aList);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}[2]  \bigpar\ \\ 
aList.add('a')} 
{\emptyset}{\{( \{ v_0 \} , \emptyset ) \}}{\emptyset}{\emptyset} 
\end{array}
\]

Analogously, Client 2 realize its actions leaving to environment evolves as below:

\[
\begin{array}{l}
E \arrobyclient{\updatetran{aList.add('b')}}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}[1]\ \bigpar\
\\
\tclient{\textit{push();let x = read(aList);}}{0}{\epsilon}{[aList.add('b')]}{\epsilon}{0}[2]  \bigpar\ 
\\ aList.add('a')} {\emptyset}{\{( \{ v_0,v_1 \} , \{\ (v_0,v_1) \} ) \}}{\emptyset}{\emptyset} 
\\
\\
\arrobyclient{\pushtran}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}[1]\ \bigpar\
\\
\tclient{\textit{let x = read(aList);}}{0}{[aList.add('b')]}{\epsilon}{[aList.add('b')]}{0}[2]  \bigpar\ 
\\ aList.add('a')}{\emptyset}{\{( \{ v_0,v_1 \} , \{\ (v_0,v_1) \} ) \}}{\emptyset}{\emptyset} 
\\
\\
\arrobyclient{\tau}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}[1]\ \bigpar\
\\
\tclient{\textit{let x = read(aList);}}{0}{[aList.add('b')]}{\epsilon}{\epsilon}{0}[2]  \bigpar\ 
\\aList.add('a') \cdot [aList.add('b')]} {\emptyset}{\{( \{ v_0,v_1 \} , \{\ (v_0,v_1) \} ) \}}{\emptyset}{\{ (v_0,v_1) \}} 
\\
\\
\arrobyclient{\readtran{aList}}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}[1]\ \bigpar\
\\
\tclient{\update{0}{x}{['b']}}{0}{[aList.add('b')]}{\epsilon}{\epsilon}{0}[2]  \bigpar\ aList.add('a') \cdot [aList.add('b')]} 
\\
{\emptyset}{\emptyset}{\emptyset}{\emptyset} 
\end{array}
\]
		
Note that $\arb$ is modified because the message queue has two elements. The value returned will be the list with a only element, ['b'], because of the internal action associated to the rule $\textsc{\small{e-receive}}$ did not perform it. Then, if the rule $\textsc{\small{e-receive}}$ were performed, the value of the list would be ['a','b']. It is because the content of the pending queue is removed when the server left their message. 

The guarantee Consistent Prefix, which rules is $(\textsc{\small{ar}};\textsc{\small{vis}}) \subseteq \ \textsc{\small{ar}};\textsc{\small{VIS}}$, states that if we see an result from a client in a particular order, we will never see this result in a different order.


 \input{extending_gsp_stronger}
 \appendix
 
 \section{Functions for implementing datatypes}
 \subsection{Auxiliar Function}

Before describing the implementation of GSP, we will introduce the following auxiliars functions which will be used when we define the operational semantic.

\footnotesize
\ttfamily


\begin{flushleft}
\specfunction{append}{\gssegmenttype}{$\roundtype^*$}{\gssegmenttype} \\
\append{\gssegmentins{$\delta$}{\maxround}}{$\epsilon$} = \gssegmentins{$\delta$}{\maxround} \\
\append{\gssegmentins{$\delta$}{\maxround}}{$\headerround$:\tailround} = \append{\textless\reduce{$\delta$ $\cdot$ $\delta_0$ $\cdot$ $\epsilon$}, $\update{\maxround}{b_0}{n_0}$\textgreater}{\tailround} 
\end{flushleft}

\begin{flushleft}
\specfunction{apply}{\gsprefixtype}{\gssegmenttype}{\gsprefixtype} \\
\apply{$\gsprefixins{\state}{\maxround}$}{\gssegmentins{$\delta$}{$\maxround'$}} =  \gsprefixins{\applyplus{\state}{$\delta$ $\cdot$ $\epsilon$}}{\maxround[$\maxround'$]}  \\
\end{flushleft}

\begin{flushleft}
\specfunctiononeparameter{receivedrounds}{($\partialfunction{\idset}{\textless \dominserver \textgreater^*}$)}{$\roundtype^*$}\\
receivedrounds($\undefined$) = $\epsilon$ \\
receivedrounds($\partialfunction{b}{\textless n_0,\ \delta_0 \textgreater} \cdot\ f$) = \textless $b$, \ $n_0$, \ $\delta_0$\textgreater\ $\cdot$ receivedrounds($f$)
\end{flushleft}

\begin{flushleft}
\henote{arreglar las lineas comentadas}
\chnote{hecho}
\specfunctionforparameters{curstate}{\statetype}{$\roundtype^*$}{\deltatype}{\deltatype}{\statetype} \\
$curstate(\state, \pending, \pushbuffer, \transactionbuffer$) = $\applyplus{\state}{getdeltas(\pending) \cdot\pushbuffer\cdot \transactionbuffer}$
\end{flushleft}


\begin{flushleft}
\specfunctiononeparameter{getdeltas}{$\roundtype^*$}{$\deltatype^*$} \\
getdeltas($\epsilon$) = $\epsilon$ \\
getdeltas(\textless $n_0$,$\delta_0$ \textgreater $\cdot$ $\delta$) = $\delta_0$ $\cdot$ getdeltas($\delta$)\\
\end{flushleft}

\begin{flushleft}
\specfunctiononeparameter{remove}{$\deltatype^*$}{$\deltatype^*$} \\
remove(rs,$\epsilon$) = $\epsilon$ \\
remove(rs, xs) = $(foldr (\backslash x\ rec\ ys\to h \ (filter \ (/$=$x) ys))\ id) xs \ rs$\\
\end{flushleft}


\begin{flushleft}
\specfunctionthreeparameters{notify}{$\idset^*$}{($\partialfunction{\idset}{\gssegmenttype^* \cup \gsprefixtype}$)}{$\gssegmenttype$}{$(\partialfunction{\idset}{\gssegmenttype^* \cup \gsprefixtype})$}\\
notify($\{\cid\}$, $\outserver$, gs) = $\outserver[\cid \mapsto gss \cdot gs]$\\
notify($\cid \cdot bs$, $\outserver$, gs) = $\notify{bs}{\outserver}{gs}[\cid \mapsto gss \cdot gs]$ 
\end{flushleft}

\begin{flushleft}
\specfunction{\cleannamefun}{$\idset^*$}{$(\partialfunction{\idset}{\dominserver}$)}{$(\partialfunction{\idset}{\dominserver})$}\\
\cleannamefun($\{\cid\}$, $\outserver$, gs) = $\inserver[\cid \mapsto \emptyset]$\\
\cleannamefun($\cid \cdot bs$, $\outserver$, gs) = $\clean{bs}{\inserver[\cid \mapsto \emptyset]$}
\end{flushleft}


\normalfont
\normalsize

\paragraph{Notation.} Let $f$ and $g$ be a partial function, we define the update operator $\_[\_]$ such that
  $dom(f[g])  = dom(f) \cup dom(g)$ and 
 \[
   \begin{array}{l@{\ = \ \Bigg\{}l}
     f[g](x) & 
     \begin{array}{ll}
        f(x) & \mbox{if }\ x\not\in dom(g) \wedge x\in dom(f) \\
        g(x) & \mbox{if }\ x\in dom(g)\\
        \mathit{\undefined}  & \mbox{Otherwise} 
     \end{array}
   \end{array}
 \]    

 We write $[x_1 \mapsto y_1, \ldots, x_n \mapsto y_n]$ for the partial function $f$ such that $dom(f)=\{x_1,\ldots,x_n\}$ and $f(x_i)=y_i$; $A \setminus B$ to denote the usual difference of sets.



The functions \textbf{reduce} and \textbf{apply} are abstract and depend on the data model used. 


\end{document}
