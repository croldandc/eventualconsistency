\documentclass[envcountsect,runningheads,orivec]{llncs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ENLARGED STYLE FOR SUBMISSION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\setlength{\textwidth}{15cm}

%\setlength{\textheight}{21cm}
%\addtolength{\oddsidemargin}{-1.25cm}pu
%\setlength{\evensidemargin}{\oddsidemargin}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage[all]{xy}\CompileMatrices
\usepackage[english]{babel}
\usepackage[mathcal]{euscript}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{pslatex}
\usepackage{alltt}

\usepackage{url}
\usepackage{subfigure}
\usepackage{stmaryrd,amsmath,amsfonts,amstext,amssymb,fancybox}

\usepackage{bussproofs}
\usepackage{mathtools}

\newcommand{\powerset}{\mathcal{P}_f}
\newcommand{\compatible}{compatible}
\newcommand{\compatibility}{compatibility}

\newcommand{\bn}{\mathop{\mathrm{bn}}}
\newcommand{\initial}{\mathop{I}}
\newcommand{\fn}{\mathop{\mathrm{fn}}}
\newcommand{\struct}{\equiv}
%\newcommand{\rec}[2]{\mathsf{rec}\;{#1}.{#2}}
\newcommand{\sep}{\;\;\mid\;\;}
\newcommand{\locpar}{|}
\newcommand{\install}[1]{\mathsf{install}[{#1}]}
\newcommand{\sedef}{\Rightarrow}
\newcommand{\merg}[2]{\mathsf{merge}^{#1}\ {#2}}
\newcommand{\invoke}[1]{\mathsf{invoke}\ {#1}}

\newcommand{\arro}[1]{\xrightarrow[]{#1}}
\newcommand{\arroi}[1]{\arro{#1}_i}
\newcommand{\arrobyclient}[2]{\arro{#1}_#2}

\newcommand{\auxarro}[1]{\xmapsto{#1}}

\newcommand{\typearro}[1]{\stackrel{#1}{\mapsto}}
\newcommand{\labdef}[1]{\top #1}
\newcommand{\session}{\rhd}
\newcommand{\labinv}[1]{\bot #1}
\newcommand{\labmerg}[2]{#1^{#2}}
\newcommand{\deduce}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
\newcommand{\equal}[2]{#1 \stackrel{\cdot}{=} #2}
\newcommand{\n}{\mathop{\mathrm{n}}}
\newcommand{\muse}{$\mu\mathsf{se}$}
\newcommand{\var}{{\mathcal A}}
\newcommand{\varb}{{\mathcal B}}
\newcommand{\subst}[2]{\{#1 / #2\}}
\newcommand{\judge}[4]{#1\vdash #4:\{{#2}\,\nearrow\,{#3}\}}
\newcommand{\judges}[3]{#1\vdash #3 :\{#2 \}}
\newcommand{\compliance}{\thickapprox}

%\newcommand{\topfigrule}{\vskip2pt\noindent\rule{\textwidth}{1pt}}
\newcommand{\olds}[1]{\oldstylenums{#1}}
\newcommand{\oldsb}[1]{{\bfseries\olds{#1}}}
\newif{\ifcomments}
\commentsfalse \ifcomments
\newcommand{\comment}[1]{\stepcounter{ncomm}%
\vbox to0pt{\vss\llap{\tiny\oldsb{\arabic{ncomm}}}\vskip6pt}%
\marginpar{\tiny\bf\raggedright%
{\oldsb{\arabic{ncomm}}}.\hskip0.5em#1}}
\newcounter{ncomm}
\else
\newcommand{\comment}[1]{}
\fi
\newcommand{\marginnote}[2]{\hrule\smallskip\textbf{#1}:{\sf #2}\smallskip\hrule}
\newcommand{\rest}[1]{(\nu #1)}
\newcommand{\pinull}{\mathbf{0}}
\newcommand{\typenull}{\mathsf{0}}
\newcommand{\subt}{\; \mbox{{{\tt <}} \hspace{-.29cm} \raisebox{.25ex}{\tt :}}\,}
\newcommand{\bigfract}[2]{\frac{^{\textstyle #1}}{_{\textstyle #2}}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}}
\def \mathax #1#2{\begin{array}{l} {\mbox{\scriptsize {{\sc (#1)}}} } \\ #2
\end{array}}

\def \mathrule #1#2#3{\begin{array}{l}
        {\mbox{\scriptsize {\ruleName{#1}}} }
        \\ \deduce{#2}{#3}
\end{array}}

\def \mathrulean #1#2#3{\begin{array}{l}
        {\mbox{\scriptsize {\ruleName{#1}}} }
        \, \deduce{#2}{#3}
\end{array}}

\def \mathanrule #1#2{\begin{array}{l}
				\deduce{#1}{#2}
\end{array}}

\def \mathaxiom #1#2{\begin{array}{l}%
    {\mbox{\scriptsize ({\sc #1})} }%
    \\ \iaxiom{#2}%
    \end{array}}
\newcommand{\iaxiom}[1]{\textstyle\rule[-1.3ex]{0cm}{3ex}#1}
        
\newcommand{\wsdl}{{\sc wsdl}}
\newcommand{\lredm}[1]{\stackrel{#1}{\longmapsto}}
\newcommand{\ruleName}[1]{{\sc (#1)}}


\newcommand{\bla}{\fbox{bla, bla, bla...}}
\newcommand{\replace}[2]{{\fbox{#2}}\marginpar{$\star\star$}}
%\newcommand{\replace}[2]{{#2}}



%
% MACRO FOR COMMENTS
%
%\newcommand{\nota}[1]{\noindent \fbox{ \parbox{\textwidth}{#1} }  }
\newcommand{\nota}[1]{}

%
% ABBREVIATIONS AND SYMBOLS
%
\newcommand{\eg}{e.g.}
\newcommand{\ie}{i.e.}
\newcommand{\wrt}{w.r.t.}
\newcommand{\tdot}{..}



\newcommand{\emptysequence}{[]}

\newcommand{\tsystem}[2]{#1\ \bigpar\ #2}
\newcommand{\tclient}[6]{\{#1 , #2, #3, #4, #5, #6\}}
\newcommand{\tclienti}[6]{\tclient{#1}{#2}{#3}{#4}{#5}{#6}_{i}}

\newcommand{\tknown}{\textit{k}}
\newcommand{\tpending}{\rho}
\newcommand{\ttransactionbuffer}{\alpha}
\newcommand{\tsent}{\sigma}
\newcommand{\tsenthead}{\beta}

\newcommand{\treceivebuffer}{\textit{j}}
\newcommand{\rvalue}[2]{\textit{rvalue}(#1, #2)}

\newcommand{\tupdateins}{\textit{\tupdins;P}}
\newcommand{\tupdins}{\textit{update(u)}}

\newcommand{\tpushins}{\textit{push();P}}
\newcommand{\tconfirmedins}[1]{\textit{let}\ #1 = \textit{confirmed}();P}

\newcommand{\tpullins}{\textit{pull();P}}
\newcommand{\treadins}[2]{\textit{let}\ #1 = \textit{read}(#2);P}
\newcommand{\treceivetran}{\textit{receive()}}

\newcommand{\queuemessage}{S}
\newcommand{\system}{C}
\newcommand{\systemterm}{N}
\newcommand{\environmentterm}{E}


%
% SERVER AND CLIENT
%
\newcommand{\gsp}{\textit{gsp}}
\newcommand{\tgspcalculus}{\textit{tgsp-calculus}}
\newcommand{\gspcalculus}{\textit{gsp-calculus}}

\newcommand{\server}[3]{\{#1 , #2, #3\}}
\newcommand{\clientr}[2]{\client{#1}{#2}_i}
\newcommand{\client}[2]{\{#1 , #2\}}



\newcommand{\clienti}[9]{\{#1 , #2, #3, #4, #5, #6, #7, #8\}_#9}

\newcommand{\inserver}{\textit{$in_s$}}
\newcommand{\outserver}{\textit{$out_s$}}
\newcommand{\inclient}{\textit{$in_c$}}
\newcommand{\outclient}{\textit{$out_c$}}
\newcommand{\outclientlist}{\textit{\headerround} \cdot \textit{\tailround}}

\newcommand{\state}{\textit{ps}}
\newcommand{\stateclient}{E}


\newcommand{\persistedstate}{\textit{ps}}
\newcommand{\statetype}{\textit{State}}
\newcommand{\updatetype}{\textit{Update}}
\newcommand{\readtype}{\textit{Read}}
\newcommand{\valuetype}{\textit{Value}}

\newcommand{\deltatype}{\textit{Delta}}
\newcommand{\known}{\textit{k}}
\newcommand{\pending}{\textit{p}}
\newcommand{\transactionbuffer}{\textit{tb}}
\newcommand{\pushbuffer}{\textit{pb}}
\newcommand{\receivebuffer}{\textit{rb}}

\newcommand{\knowntype}{\statetype}
\newcommand{\pendingtype}{\rho}
\newcommand{\transactionbuffertype}{\delta}
\newcommand{\pushbuffertype}{\delta}
\newcommand{\receivebuffertype}{\gssegmenttype \cup \gsprefixtype}
\newcommand{\nroundtype}{\mathbb{N}}

\newcommand{\maxround}{\textit{mr}}
\newcommand{\append}[2]{append(#1, #2)}
\newcommand{\apply}[2]{apply(#1, #2)}
\newcommand{\remove}[2]{remove(#1, #2)}

\newcommand{\gs}{\textit{gs}}
\newcommand{\gss}{\textit{gss}}
\newcommand{\gssegment}{\textless	\delta,\maxround \textgreater}
\newcommand{\emptygssegment}{\theta}
\newcommand{\gsprefix}{\textless	\state,\maxround \textgreater}
\newcommand{\round}[3]{\textless	#1, #2, #3 \textgreater}

\newcommand{\specfunction}[4]{#1 :: #2 $x$ #3 $\rightarrow$ #4}
\newcommand{\specfunctiononeparameter}[3]{#1 :: #2 $\rightarrow$ #3}
\newcommand{\specfunctionforparameters}[6]{#1 :: #2 $x$ #3 $x$ #4 $x$ #5 $\rightarrow$ #6}




\newcommand{\gssegmenttype}{\textit{GSSegment}}
\newcommand{\gsprefixtype}{\textit{GSPrefix}}
\newcommand{\roundtype}{\textit{Round}}
\newcommand{\headerround}{\textless	i, n_0, \delta_0\textgreater}

\newcommand{\tailround}{\textit{rs}}

\newcommand{\partialfunction}[2]{#1 \rightarrow #2}

\newcommand{\reduce}[1]{\textbf{\textit{reduce}}(#1)}
\newcommand{\applyplus}[2]{\textbf{\textit{apply}}(#1, #2)}

\newcommand{\readplus}[2]{\readp{#1}{#2} = \textit{v}}

\newcommand{\readp}[2]{\textbf{\textit{read}}(#1, #2)}

\newcommand{\appendplus}[2]{\textbf{\textit{append}}(#1, #2)}

\newcommand{\reducestate}[2]{\textbf{\textit{reducestate}}(#1, #2)}


\newcommand{\gsprefixins}[2]{\textless #1, #2\textgreater}
\newcommand{\gssegmentins}[2]{\textless #1, #2\textgreater}

\newcommand{\receive}{\textit{receive()}}

\newcommand{\confirmedtran}{\textit{confirmed()}}
\newcommand{\pushtran}{\textit{push()}}
\newcommand{\updatetran}[1]{\textit{update}(#1)}
\newcommand{\processtran}{\textit{process}()}

\newcommand{\updatevtran}[2]{\textit{update}(#1^#2)}
\newcommand{\syncupdtran}[2]{\textit{sync\_update}(#1^#2)}

\newcommand{\updatebyclient}[1]{\textit{update}(u)_#1}
\newcommand{\readbyclient}[1]{\textit{read}(r)_#1}

\newcommand{\pulltran}{\textit{pull()}}
\newcommand{\sendtran}{\textit{send()}}
\newcommand{\dropconn}[1]{\dagger(#1)}
\newcommand{\dropconnectionclient}{\dagger}
\newcommand{\tprogram}{P}
\newcommand{\tflush}{\textit{flush()}}
\newcommand{\tsyncupd}[1]{\textit{sync\_update(#1)}}

\newcommand{\acceptconn}[1]{\oplus(#1)}
\newcommand{\crashandrecover}{\ddagger}
\newcommand{\undefined}{\perp}
\newcommand{\receiveroundsname}[1]{\textit{receivedRounds}(#1)}
\newcommand{\updatein}[2]{#1^#2}
\newcommand{\update}[3]{#1[#2 \mapsto #3]}
\newcommand{\updatethree}[7]{#1[#2 \mapsto #3; #4 \mapsto #5; #6 \mapsto #7]}
\newcommand{\updatetwo}[5]{#1[#2 \mapsto #3; #4 \mapsto #5]}
\newcommand{\updatefour}[9]{#1[#2 \mapsto #3; #4 \mapsto #5; #6 \mapsto #7; #8 \mapsto #9]}


\newcommand{\tupdate}{\textit{u}}
\newcommand{\readins}[2]{\textit{let}\ #1 = \textit{read}(#2);P}
\newcommand{\readtran}[1]{\textit{read}(#1)}

\newcommand{\startsynctran}{\dagger}
\newcommand{\finishsynctran}{\ddagger}




\newcommand{\twhile}[2]{\textit{while} (#1)\ \textbf{do}\ #2}


\newcommand{\updateins}[1]{\textit{update}(#1);P}
\newcommand{\pushins}{\textit{push}();P}
\newcommand{\pullins}{\textit{pull}();P}
\newcommand{\curstate}[4]{\textit{curstate}(#1, #2, #3, #4)}
\newcommand{\nround}{\textit{n}}
\newcommand{\confirmedins}[1]{\textit{let}\ #1 = \textit{confirmed}();P}
\newcommand{\domround}{\mathcal{N} \times \mathbb{N} \times \deltatype}
\newcommand{\dominserver}{\mathbb{N} \times \deltatype}




\newcommand{\tuple}[1]{\vec{#1}}
\newcommand{\zero} {0}
\newcommand{\outp}[2]{\overline{#1}\langle #2 \rangle}
\newcommand{\inp}[2]{#1(#2)}
\newcommand{\ifte}[3]{{\bf if}\ #1\ {\bf then}\ #2\ {\bf else}\ #3}
\newcommand{\rec}[2]{{\bf rec}_{#1}\ #2}

\newcommand{\corrinst}[2]{#1\triangleright[#2]}

\newcommand{\service}[4]{#1_{#2}\{#3\ ,\ #4\}}

\newcommand{\bigpar}{|\!|}


\newcommand{\denote}[1]{\llbracket #1\rrbracket}

 \newcommand{\unexcplbl}[1]{[#1]}
 \newcommand{\unexcp}{\circledast 	}

 \newcommand{\mayhandle}[2]{#1\downarrow_{#2}}
 \newcommand{\maynothandle}[2]{#1\not\downarrow_{#2}}

\newcommand{\Arro}{\Rightarrow}

\newcommand{\verticesets}{\mathbb{V}}
\newcommand{\updatesets}{\mathbb{U}}

\newcommand{\condition}[2]{\neg(#1\downarrow)=#2}

%CONSISTENCY GRAMMAR

\newcommand{\environment}[5]{\{#1 , #2, #3, #4, #5\}}
\newcommand{\environmenttran}[8]{\{#1 , #2, #3, #4, #5, #6, #7, #8\}}

\newcommand{\vis}{\textsc{\scriptsize{VIS}}}
\newcommand{\op}{\textsc{\scriptsize{OP}}}
\newcommand{\arb}{\textsc{\scriptsize{AR}}}
\newcommand{\so}{\textsc{\scriptsize{SO}}}
\newcommand{\soby}[2]{#1\triangleright_i{#2}}
\newcommand{\updateinqueuemessage}[2]{\queuemessage[#1]_#2}
\newcommand{\rb}{\textsc{\scriptsize{RB}}}
\newcommand{\tx}{\textsc{\scriptsize{TO}}}
\newcommand{\tc}{\textsc{\scriptsize{TC}}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cf}[2]{
    \fontsize{#1}{#1}{\selectfont{#2}}
  }

\newcommand{\hernan}[1]{{\marginpar{\cf{6}{{HM: #1}}}}}
%\newcommand{\emi}[1]{{\marginpar{\cf{6}{{#1}}}}}
%  \newcommand{\cf}[2]{
%    \fontsize{#1}{#1}{\selectfont{#2}}
%  }
%\newcommand{\emic}[2]{\shadowbox{\fbox{\parbox{.8\textwidth}{\begin{description}\item[\cf{8}{\sc\bf #2}]\cf{8}{#1}\end{description}}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para Borrar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ignorar}[1]{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type system
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\type}{\mathcal{T}}
\newcommand{\patternmtch}{\owedge}
\newcommand{\tjudge}[4]{#1 \vdash #2 : {#3} ,#4}

\title{GSP-Calculus}

\author{Hern\'an Melgratti\inst{1,2} \and Christian Rold\'an\inst{1} 
        }

\institute{
  Departamento de Computaci\'on, FCEyN, Universidad de Buenos Aires.
 %\email{hmelgra@dc.uba.ar} 
\\
\and CONICET.}

%\titlerunning{Correlation sets}

%\authorrunning{R. Bruni, H. Melgratti, U. Montanari}


\bibliographystyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}


\section{Abstract Global Sequence Protocol Language}

\subsection{Syntax}

We assume the following countable sets of vertex names $\verticesets$ ranged over by $v$;$v_0$;$v_1$, \ldots;
We shall use $\ttransactionbuffer$, $\beta$ to denote sequence of updates $\updatesets$ ranged over by $u^v$,$u^{v_0}_0$,$u^{v_1}_1$,$\ldots$; Let $\mathcal{U}$=$u^{v_0}_0$ $\cdot$ $u^{v_1}_1$ $\cdot$,$\dotsc$,$\cdot$ $u^{v_n}_n$. For the sake of clarity, we shall only use vertices as update's decoration whenever it would be necessary.

Let $\tpending$, $\sigma$ be sequence defined as $\epsilon$ \text{\textbar} [$\alpha$]$\cdot$ $\tpending$. We use $\epsilon$ to denote the empty sequence, \ie, the sequence of length 0.
 
Let $\tpending$ and $\ttransactionbuffer$ be sequence, we write $\setminus$ as relative complement of $\tpending$ in $\ttransactionbuffer$, \ie\ ,$\tpending$ $\setminus$ $\ttransactionbuffer$ = [$u_i$ $|$ $u_i$ $\in$ $\tpending$ $\wedge$\ $u_i$ $\notin$ $\ttransactionbuffer$]. 


 \begin{definition}[Global Sequence Protocol Language] 
The set of \tgspcalculus\ expressions is defined by the following syntax:
 
  \[
    \begin{array}{l@{\quad}r@{}l}
			 (\textsc{system}) & N \::=\ & \tsystem{C}{\queuemessage} \\
       (\textsc{client}) & C \::=\ & \zero \;|\; \tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \;|\; C\ \bigpar\ C \qquad where $ $ \tknown\ and $ $ \treceivebuffer\ \in \mathbb{N} \\
			 (\textsc{state}) & S \::=\ & \epsilon \;|\; \queuemessage \cdot \tpending \\
			 (\textsc{program}) & \tprogram \::=\ & \tupdateins \;|\; \treadins{x}{v} \;|\; \tpullins \;|\; \tpushins \;|\; \\
			&  \ \ & \tconfirmedins{x} \;|\; \twhile{cond}{\tprogram} 
     \end{array}
  \]
\end{definition}

We model the system $N$ as several clients interacting with a message queue $S$. This message queue will represent the program state. We formalize an $i^{\ th}$ client as a tuple $\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}$
where $P$, called Program, is a set of programming primitives that allow programmer to interact with the distributed store by invoking of actions on objects, a index $\tknown$ which denotes the maximum index of update that reading in $S$, a sequence of updates sent but unconfirmed their reception $\tpending$, a transaction buffer $\ttransactionbuffer$, a sequence of all the updates sent by the client to the RTOB $\tsent$ and finally $\treceivebuffer$ which represents a amount of received updates. 

\subsection{Operational Semantics}

The operational semantics of \tgspcalculus\ is defined by a labeled transition system 
over well-formed terms, up-to the structural congruence.

The labeled transition system considers the following actions:
\[ 
\begin{array}{r@{\ ::= \ }l}
  \alpha & \tau \ | \ \readtran{r} \ | \  \updatetran{u} \ | \ \pulltran \ | \ \pushtran \ | \ \confirmedtran 
\end{array}
\]

 \[
 \begin{array}{l}
\mathrule{t-read}{\rvalue{r}{\textit{flatten}(\queuemessage[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = v}{\tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arro{\readtran{r}} \tsystem{\tclienti{\update{\tprogram}{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage}}
\\[25pt]

\mathax{t-update}{\tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arro{\updatetran{u}} \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer\ \cdot \tupdate}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage}}

\\[15pt]

\mathax{t-push}{\tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \bigpar\ \system}{\queuemessage} \arro{\pushtran} \tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot [\ttransactionbuffer]}{\epsilon}{\tsent \cdot [\ttransactionbuffer]}{\treceivebuffer} \bigpar\ \system}{\queuemessage}}
\\[15pt]

\mathax{t-pull}{\tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \bigpar\ \system}{\queuemessage} \arro{\pulltran} \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]}{\ttransactionbuffer}{\tsent}{0} \bigpar\ \system}{\queuemessage}}
\\[15pt]


\mathax{t-confirmed}{\tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arro{\confirmedtran} \tsystem{\tclienti{\update{\tprogram}{x}{\tpending \neq \emptysequence \vee\ \ttransactionbuffer \neq \epsilon}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage}}

\\[20pt]

\mathrule{t-while-true}{\condition{cond}{false}}{\tsystem{\tclienti{\twhile{cond}{\tprogram}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \bigpar \system}{\queuemessage} \arro{\tau} \tsystem{\tclienti{\tprogram;\twhile{cond}{\tprogram}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1} \bigpar\ \system}{\queuemessage}}


\\[25pt]

\mathrule{t-while-false}{\condition{cond}{true}}{\tsystem{\tclienti{\twhile{cond}{\tprogram}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \bigpar \system}{\queuemessage} \arro{\tau} \tsystem{\tclienti{0}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1} \bigpar\ \system}{\queuemessage}}


\\[20pt]
\mathrule{t-receive}{\tknown + \treceivebuffer + 1 \leq \text{\textbar} S \text{\textbar} }{\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \bigpar \system}{\queuemessage} \arro{\tau} \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1} \bigpar\ \system}{\queuemessage}}

\\[25pt]

\mathax{t-process}{\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\tsenthead] \cdot \tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arro{\tau} \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage \cdot \tsenthead}}
\\
 \end{array}
\]


The meaning of $\tau$ is standard. A \tgspcalculus\ program is given by a Labeled Transition System (LTS) before introducing. Transitions for systems are labeled by actions $\alpha$ as usual.

Rule $\textsc{(T-READ)}$ states that a client $i$ can perform an action $\readtran{r}$, substituting each occurrence of $x$ in $P$ with the value $v$. Notice that $v$ is got from the queue message and the client's internal queues. Rule \textsc{(T-UPDATE)} describes effects performed by an update operation. The update $u$ is saving in the temporal queue $\ttransactionbuffer$. After \textsc{(T-PUSH)} the content of the transaction queue $\ttransactionbuffer$ is moved to the pending queue, $\tpending$, and the sent queue, $\tsent$. Rule $\textsc{(T-PULL)}$ increases the amount of updates that client $i$ can read in the message queue $S$. This increase is given by the amount of update receiving.The pending queue removes those updates which belong between index $\tknown$ and the amount of update receiving $\treceivebuffer$ in $S$. Besides, $\treceivebuffer$ is restarted in 0. $\textsc{(T-CONFIRMED)}$ sets $x$ in false whether updates are in pending queue or transaction queue, true in otherwise. Rule $\textsc{(T-WHILE-TRUE)}$ and $\textsc{(T-WHILE-fALSE)}$ are standard. Rule $\textsc{(T-RECEIVE)}$ states that a counter $\treceivebuffer$ is incremented (by 1). Finally, the last one rule, $\textsc{(T-PROCESS)}$, moves updates from sent queue to the message queue.  

 \paragraph{Notation.} Let $f$ and $g$ be a partial function, we define the update operator $\_[\_]$ such that
  $dom(f[g])  = dom(f) \cup dom(g)$ and 
 \[
   \begin{array}{l@{\ = \ \Bigg\{}l}
     f[g](x) & 
     \begin{array}{ll}
        f(x) & \mbox{if }\ x\not\in dom(g) \wedge x\in dom(f) \\
        g(x) & \mbox{if }\ x\in dom(g)\\
        \mathit{\undefined}  & \mbox{Otherwise} 
     \end{array}
   \end{array}
 \]    

 We write $[x_1 \mapsto y_1, \ldots, x_n \mapsto y_n]$ for the partial function $f$ such that $dom(f)=\{x_1,\ldots,x_n\}$ and $f(x_i)=y_i$; $A \setminus B$ to denote the usual difference of sets.\\
 

\section{Implementation of GSP}

The GSP model introduced in the previous section is an abstract protocol which does not consider implementation details. Problems like space explosion caused by the growing of the update sequence have to allow for implementing these protocol. 

Instead of storing update sequence, the implementation to present reduce such sequence to in two differents objects. $\statetype$ when the update sequence reduced represents a prefix of the global queue message or $\deltatype$ when the update sequence reduced represents a interval or segment of the global queue message.

The \gsprefixtype\ the set over sets \statetype\ $\times$ $\mathcal{N}$ $\rightarrow$ $\mathbb{N}$, \gssegmenttype\ the set operation over sets \deltatype $\times$ $\mathcal{N}$ $\rightarrow$ $\mathbb{N}$ and \roundtype\ the set over sets $\mathcal{N}$ $\times$ $\mathbb{N}$ $\times$ \deltatype; $\emptygssegment$\ is a fresh element of \gssegmenttype.

Furthermore, we assume the following parametric functions defined over the abstract data types above borrowed from[1]:

\[\begin{array}{lll}
\textbf{const} & \textit{initialstate} & :$\statetype$ \\
\textbf{function} & \textit{read} & :\partialfunction{\readtype \times \statetype}{\valuetype} \\
\textbf{function} & \textit{apply} & :\partialfunction{\statetype \times \deltatype^*}{\statetype} \\
\textbf{const} & \textit{emptydelta} & :\deltatype \\
\textbf{function} & \textit{append} & :\partialfunction{\deltatype \times \updatetype}{\deltatype} \\
\textbf{function} & \textit{reduce} & :\partialfunction{\deltatype^*}{\deltatype} \\
\end{array}\] 

Let \statetype\ be a set of state ranged over by $s$, $s_1$, $s_2$, $\ldots$;
We shall use $\pushbuffertype$ to denote sequence of $Delta$ ranged over by $d$, $d_0$, $d_1$ $\ldots$; Let $\pendingtype$, $\sigma$ be sequence defined:

$\pendingtype$,$\sigma$ := $\epsilon$ \text{\textbar} [$\delta$]$\cdot$ $\pendingtype$
 

We assume the following countable sets of persisted state $\gsprefixtype$ ranged over by $ps$, $ps_1$, $\ldots$; 

Let $\inserver$\ be a partial function in $\partialfunction{\mathcal{N}}{\dominserver}$

Let $\outserver$\ be a partial function in $\partialfunction{\mathcal{N}}{\gssegmenttype^* \cup \gsprefixtype}$ \\


\subsection{Auxiliar Function}

Before describing the implementation of GSP, we will introduce the following auxiliars functions which will be used when we define the operational semantic.

\footnotesize
\ttfamily
\begin{flushleft}
\specfunction{append}{\gssegmenttype}{$\roundtype^*$}{\statetype} \\
\append{\gssegmentins{$\delta$}{\maxround}}{$\epsilon$} = \gssegmentins{$\delta$}{\maxround} \\
\append{\gssegmentins{$\delta$}{\maxround}}{$\headerround$:\tailround} = \append{\textless\reduce{$\delta$ $\cdot$ $\delta_0$ $\cdot$ $\epsilon$}, $\update{\maxround}{b_0}{n_0}$\textgreater}{\tailround} 
\end{flushleft}

\begin{flushleft}
\specfunction{apply}{\gsprefixtype}{\gssegmenttype}{\gsprefixtype} \\
\apply{$\gsprefixins{\state}{\maxround}$}{\gssegmentins{$\delta$}{$\maxround'$}} =  \gsprefixins{\applyplus{\state}{$\delta$ $\cdot$ $\epsilon$}}{\maxround[$\maxround'$]}  \\
\end{flushleft}

\begin{flushleft}
\specfunctiononeparameter{receivedrounds}{($\partialfunction{\mathcal{N}}{\textless \dominserver \textgreater^*}$)}{$\roundtype^*$}\\
receivedrounds($\undefined$) = $\epsilon$ \\
receivedrounds($\partialfunction{b}{\textless n_0,\ \delta_0 \textgreater} \cdot\ f$) = \textless $b$, \ $n_0$, \ $\delta_0$\textgreater\ $\cdot$ receivedrounds($f$)
\end{flushleft}


\begin{flushleft}
\specfunctionforparameters{curstate}{\statetype}{$\roundtype^*$}{\deltatype}{\deltatype}{\statetype} \\
curstate(\state, \pending, \pushbuffer, \transactionbuffer) = \applyplus{\state}{getdeltas(\pending) $\cdot$ \pushbuffer $\cdot$ \transactionbuffer}
\end{flushleft}


\begin{flushleft}
\specfunctiononeparameter{getdeltas}{$\roundtype^*$}{$\deltatype^*$} \\
getdeltas($\epsilon$) = $\epsilon$ \\
getdeltas(\textless $n_0$,$\delta_0$ \textgreater $\cdot$ $\delta$) = $\delta_0$ $\cdot$ getdeltas($\delta$)\\
\end{flushleft}

\begin{flushleft}
\specfunctiononeparameter{remove}{$\deltatype^*$}{$\deltatype^*$} \\
remove(rs,$\epsilon$) = $\epsilon$ \\
remove(rs, xs) = $(foldr (\backslash x\ rec\ ys\to h \ (filter \ (/$=$x) ys))\ id) xs \ rs$\\
\end{flushleft}

\normalfont
\normalsize

The functions \textbf{reduce} and \textbf{apply} are abstract and depend on the data model used. 

\subsection{Sintax}
 \begin{definition}[Implementation of GSP] 
	The syntax of clients and server is given by the following grammar 
  \[
    \begin{array}{l@{\quad}r@{\;::=\;}l}
			 (\textsc{system}) & \systemterm & \zero \;|\; S\ \bigpar\ C \\
			 (\textsc{server}) & S & \zero \;|\; \server{\persistedstate}{\inserver}{\outserver} \\
       (\textsc{clients}) & C & \emptyset \;|\; \client{P}{<\statetype,\pendingtype,\pushbuffertype,\transactionbuffertype,\receivebuffertype,\nroundtype,\inclient,\outclient>} \;|\; C\ \bigpar\ C  \\
			 (\textsc{program}) & P & \zero \;|\; \readins{x}{r} \;|\; \updateins{u} \;|\; 	\pushins \;|\; \pullins
     \end{array}
  \]
 \end{definition}
 
The implementation of a system is a server and clients interacting concurrently. A server will be represented with a persisted state denoted by $\persistedstate$, input messages $\inserver$ and output messages $\outserver$.
We will refer to clients, as tuple of program $P$ and set of states and sequences $E$. A program client stores a state ($E.\known$), a pending queue ($E.\pending$),i.e., updates sent to the server without confirmation of their reception, a push buffer ($E.\pushbuffer$) which holds updates that were pushed by the client but have not been sent to the server, a transaction buffer ($E.\transactionbuffer$) which holds updates for sending with another ones, a receive buffer ($E.\receivebuffertype$) for updates which were sent by the server, the number of round sent ($E.\nround$), a input message queue ($E.\inclient$) and a output message queue ($E.\outclient$).


\subsection{Operational Semantics}

The operational semantics of \gspcalculus\ is defined by a labeled transition system 
over well-formed terms, up-to the structural congruence.

The labeled transition system considers the following actions:
\[ 
\begin{array}{r@{\ ::= \ }l}
  \alpha & \tau \ | \ \readtran{r} \ | \  \updatetran{u} \ | \ \pulltran \ | \ \pushtran \ | \ \confirmedtran 
  \\
\end{array}
\]

 \[
 \begin{array}{l}
    \hspace{-.3cm} \textsc{SERVER}\\
    
\mathrule{drop\_conn}{b_i \in \inserver \qquad  b_i \in \outserver}{\server{\persistedstate}{\inserver}{\outserver} \auxarro{\dropconn{b_i}} \server{\persistedstate}{\inserver \setminus b_i}{\outserver \setminus b_i}} 
\hfill
\mathax{crash\_and\_recover}{\server{\persistedstate}{\inserver}{\outserver} \auxarro{\crashandrecover} \server{\persistedstate}{\undefined}{\undefined}}

\\[25pt]

\mathrule{batch}{ps'=\apply{\persistedstate}{d} \qquad d=\append{\emptygssegment}{rs} \qquad rs=\receiveroundsname{\inserver}}{\server{\persistedstate}{\inserver}{\outserver} \arro{\tau} \server{ps'}{\updatein{\inserver}{ps'}}{\outserver}}

\\[25pt]

\mathrule{accept\_conn}{b_i \notin \inserver \qquad b_i \notin \outserver}{\server{\persistedstate}{\inserver}{\outserver} \auxarro{\acceptconn{b_i}} \server{\persistedstate}{\inserver}{\update{\outserver}{b_i}{\persistedstate}}}

    \\[35pt]
    \hspace{-.3cm} \textsc{COMMUNICATION}
		
\\
    \mathrule{comm server-client}{\outserver(i)=\gs \cdot \gss}{\server{\state}{\inserver}{\outserver} \bigpar \clientr{P}{\stateclient} \arro{\tau} \server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}}
		
\\[25pt]

	    \mathrule{comm client-server}{\outclient=\headerround \cdot \tailround}{\server{\state}{\inserver}{\outserver} \bigpar \clientr{P}{\stateclient} \arro{\tau} \server{\state}{\update{\inserver}{i}{\headerround}}{\outserver} \bigpar 
		\clientr{P}{\update{E}{\outclient}{\tailround}}}	
 \\

 \end{array}
 \]

\newpage


 \[
 \begin{array}{l}
    \hspace{-.3cm} \textsc{CLIENTS}\\
		
\mathrule{read}{\readplus{r}{\curstate{\known}{\pending}{\pushbuffer}{\transactionbuffer}}}{\clientr{\readins{x}{r}}{\stateclient} \arro{\readtran{r}} \clientr{\update{P}{x}{v}}{\stateclient}}
\\[25pt]

		\mathax{update}{\clientr{\updateins{u}}{\stateclient} \arro{\updatetran{u}} \clientr{P}{\update{E}{\transactionbuffer}{\appendplus{E.\transactionbuffer}{u}}}} \\[15pt]


		\mathax{push}{\clientr{\pushins}{\stateclient} \arro{\pushtran} \clientr{P}{\updatethree{E}{\pushbuffer}{\reduce{E.\pushbuffer\cdot E.\transactionbuffer}}{\transactionbuffer}{\epsilon}{\nround}{E.\nround+1}  }} \\[25pt]

%\updatethree{E}{\pushbuffer}{\appendplus{\pushbuffer}{\transactionbuffer}}{\transactionbuffer}{\epsilon}{\nround}{\nround+1}

		\mathrule{pull}{E.\inclient \neq \emptyset \qquad E.\outclient \neq \emptyset \qquad |E.\receivebuffer| > 0}{\clientr{\pullins}{\stateclient}\arro{\pulltran} \clientr{P}{\updatethree{E}{\known}{\reducestate{E.\known}{E.\receivebuffer}}{\receivebuffer}{\epsilon}{E.\pending}{\remove{E.\pending}{E.\receivebuffer}}}}
\\[25pt]

		\mathrule{confirmed-true}{E.\pending = \epsilon \qquad E.\pushbuffer = \epsilon \qquad E.\transactionbuffer = \epsilon}{\clientr{\confirmedins{x}}{\stateclient} \arro{\confirmedtran} \clientr{\update{P}{x}{\textbf{true}}}{\stateclient}} \\[25pt]


		\mathrule{confirmed-false}{E.\pending \neq \epsilon   \  ||  \ E.\pushbuffer \neq \epsilon  \  ||  \ E.\transactionbuffer  \neq \epsilon}{\clientr{\confirmedins{x}}{\stateclient} \arro{\confirmedtran} \clientr{\update{P}{x}{\textbf{false}}}{\stateclient}} \\[25pt]


\mathax{send}{\clientr{P}{\stateclient} \arro{\sendtran} \clientr{P}{\updatethree{E}{\pending}{E.\pending \cdot E.\pushbuffer}{\pushbuffer}{\epsilon}{\outclient}{\outclient \cdot \round{i}{E.\nround}{E.\pushbuffer}}}}

\\[25pt]

		\mathrule{receive}{E.\inclient = \gs_0 \cdot \gs_t}{\clientr{P}{\stateclient} \arro{\receive} \clientr{P}{\updatetwo{E}{\receivebuffer}{E.\receivebuffer \cdot \gs_0.gssegment)}{\inclient}{\gs_t)}}}\\[25pt]


		\mathax{drop\_connection}{\clientr{P}{\known}{\stateclient} \arro{\dropconnectionclient} \clientr{P}{\updatetwo{E}{\inclient}{\emptyset}{\outclient}{\emptyset}}}\\[15pt]
 \end{array}
 \]

\newpage

\section{Equivalence}

We have introduced an abstract GSP protocol and a robust streaming server-client implementation of GSP. There exists a  representation relation $\triangleleft$ that relates state and delta objects to the update sequences. 
\begin{itemize}
	\item On $Delta \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $emptydelta \triangleleft []$, and
(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates u, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$.
\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $initialstate \triangleleft []$, and
(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
\end{itemize}

Next theorem states one of most important result of the paper, saying that they are weak bisimulation equivalent. 


\begin{theorem}
Let $\mathcal{R}$ be a relation defined as $\{ (\parallel_{i \ \in\ I_{\{0 \ldots n\}}} A_i \parallel \ \queuemessage_A),(\parallel_{i \ \in\ I_{\{0 \ldots n\}}} C_i \parallel \ \queuemessage_C) \ | \ \forall i \ \in\ \mathbb{N}, \forall r: \readtype, A_i = \ \tclient{\tprogram_i}{\tknown_i}{\tpending_i}{\ttransactionbuffer_i}{\tsent_i}{\treceivebuffer_i} \land C_i = \client{P_i}{\stateclient_i} \land \ \rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}} \land \ \queuemessage_C.\state \triangleleft \queuemessage_A \land \ E_{i}.\transactionbuffer = [\ttransactionbuffer_i] \land \ E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i] - 1 \ \land \ E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \ \land \  E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i \ \land \ \forall l, 1 \leq l < |\inclient|, E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l] \ \land \ \tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0 \ \land \ \forall \beta \ \in \ \tsent_i, \beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver
\}$.

\end{theorem}



\begin{proof}
We have to prove that $\mathcal{R}$ satisfies the nine properties of its definition:

\begin{enumerate}
	\item $\rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}}$
	\item $\queuemessage_C.\state \triangleleft \queuemessage_A$
	\item $\ E_{i}.\transactionbuffer \triangleleft [\ttransactionbuffer_i]$
	\item $E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i] - 1$
	\item $E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1]$
	\item $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$
	\item $\forall l, 1 \leq l < |\inclient|, E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l]$
	\item $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$
	\item $\forall \beta \ \in \ \tsent_i, \beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$
	
\end{enumerate}

The proof follows by induction on the length of the derivation $\arro{} ^*$.

\begin{itemize}
   \item{\bf n=0}. 
   \item{\bf n=k+1}. $\forall (A,C) \ \in \ \mathcal{R}$
	
			
			\begin{itemize}
				\item {\bf rule (\textsc{T-READ})}. If $A \arroi{\readtran{r}} A'$, then by rule (\textsc{\footnotesize{T-READ}}), $A$ must be the following term: $ \tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\update{\tprogram}{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. As $(A,C)$ belongs $\mathcal{R}$ then $C$ must be $\clientr{\readins{x}{r}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $C$ could perform.
				Then, looking at the rule, $C' = \clientr{\update{P}{x}{v}}{\stateclient}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if nine properties introduced are keeping.				
					\begin{enumerate}
						\item It is easy to see, since $P$ is the same in both clients and the value got back by each read operations is equals because of $(A,C) \ \in \ \mathcal{R}$ then property 1 is worth. 
						\item to 9. Do not change.
						

					\end{enumerate}
	
			\item {\bf rule (\textsc{T-UPDATE})}. If $A \arroi{\updatetran{u}} A'$, then by rule (\textsc{\footnotesize{T-UPDATE}}), $A$ must be the following term: $ \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer\ \cdot \tupdate}{\tsent}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. We know that $(A,C)$ belongs $\mathcal{R}$, then $C$ must be $\clientr{\updateins{u}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the update transition is the only one that $C$ could perform. Then, $C' = \clientr{P}{\update{E}{\transactionbuffer}{\appendplus{E.\transactionbuffer}{u}}}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if nine properties introduced are keeping.					
						\begin{enumerate}
							\item States $\rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown_i-1] \cdot \tpending_i) \cdot \ttransactionbuffer_i} = \readp{r}{\applyplus{E_{i}.\known}{E_{i}.\pending \cdot E_{i}.\pushbuffer \cdot E_{i}.\transactionbuffer}}$ however after applying rules, the transaction buffers change. Then, performing a read action in abstract GSP, $\rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown_i-1] \cdot \tpending_i) \cdot \ttransactionbuffer_i \cdot \tupdate}$ and the implementation, $\readp{r}{\applyplus{E_{i}.\known}{E_{i}.\pending \cdot E_{i}.\pushbuffer \cdot \appendplus{E.\transactionbuffer}{u}}}$. We rename $\ttransactionbuffer\ \cdot \tupdate$ by $\ttransactionbuffer$' and  $\appendplus{E.\transactionbuffer}{u}$ by $E_{i}.\transactionbuffer$'. If we show that $\forall u: Update$ such that $\appendplus{E.\transactionbuffer}{u} \triangleleft \ttransactionbuffer\ \cdot \tupdate$, we will prove that $(A',C') \ \in \ \mathcal{R}$. By property 3, we know that $\ E_{i}.\transactionbuffer \triangleleft [\ttransactionbuffer_i]$, using the property of relation between Delta and Update, $\appendplus{E.\transactionbuffer}{u} \triangleleft \ttransactionbuffer\ \cdot \tupdate$.
							\item to 9. Do not change.
						
						\end{enumerate}
	
\item {\bf rule (\textsc{T-PUSH})}. If $A \arroi{\pushtran} A'$, then by rule (\textsc{\footnotesize{T-PUSH}}), $A$ must be the following term: $ \tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot [\ttransactionbuffer]}{\ttransactionbuffer\ \cdot \tupdate}{\tsent \cdot [\ttransactionbuffer]}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. We know that $(A,C)$ belongs $\mathcal{R}$, then $C$ must be $\clientr{\pushins}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the push transition is the only one that $C$ could perform. Then, after applying the rule, $C' = \clientr{P}{\updatethree{E}{\pushbuffer}{\reduce{E.\pushbuffer\cdot E.\transactionbuffer}}{\transactionbuffer}{\epsilon}{\nround}{E.\nround+1}}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if nine properties introduced are keeping.					
						\begin{enumerate}
							\item We have to prove that after push transitions, the operations $rvalue$ and $read$ get back the same value. Then $\rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown_i-1] \cdot \tpending_i) \cdot \ttransactionbuffer_i} = \rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown_i-1] \cdot (\tpending_i \cdot [\ttransactionbuffer_i])) \cdot \epsilon}$ by Lemma XX besides $\readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}}$ = $
						\readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{ \reduce{E.\pushbuffer\cdot E.\transactionbuffer}}{\epsilon}}$ by Lemma YY.
							\item It does not change.
							\item $E_{i}.\transactionbuffer = \epsilon$ and $\ttransactionbuffer_i = \epsilon$. Using the property of the relation $\triangleleft$, $\epsilon \triangleleft \epsilon$ 
							\item It does not change.
							\item It does not change.
							\item States $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$ besides by 3. $\ E_{i}.\transactionbuffer \triangleleft [\ttransactionbuffer_i]$. Finally, applying the property of the relation $\triangleleft$, $\reduce{E_i.\pending \cdot E_i.\pushbuffer \cdot E_i.\transactionbuffer} \triangleleft \tpending_i \cdot [\ttransactionbuffer_i]$.
						  \item to 9. do not change.
						\end{enumerate}
						\item {\bf rule (\textsc{T-PULL})}. If $A \arroi{\pulltran} A'$, then by rule (\textsc{\footnotesize{T-PULL}}), $A$ must be the following term: $ \tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]}{\ttransactionbuffer}{\tsent}{0} \bigpar \ \tilde{A} \bigpar\ \queuemessage_A$. Due to $(A,C)$ belongs $\mathcal{R}$, then $C$ must be $\clientr{\pullins}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the pull transition is the only one that $C$ could perform. Then, after applying the rule, $C' = \clientr{P}{\updatethree{E}{\known}{\reducestate{E.\known}{E.\receivebuffer}}{\receivebuffer}{\epsilon}{E.\pending}{\remove{E.\pending}{E.\receivebuffer}}} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if nine properties introduced are keeping.	
						
						\begin{enumerate}
							\item We have to prove that after push transitions, the operations $rvalue$ and $read$ get back the same value. Then $\rvalue{r}{\textit{flatten}(\queuemessage_{A}[0..\tknown_i+\treceivebuffer-1] \cdot (\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer])) \cdot \ttransactionbuffer_i} = \readp{r}{\curstate{\reducestate{E.\known}{E.\receivebuffer}}{\remove{E.\pending}{E.\receivebuffer}}{E.\pushbuffer}{E.\transactionbuffer}}$ = $\readp{r}{\applyplus{\reducestate{E.\known}{E.\receivebuffer}}{\remove{E.\pending}{E.\receivebuffer} \cdot E.\pushbuffer \cdot E.\transactionbuffer}}$. On the one hand, property 5 states that $E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1]$, on the other hand by property 4, $E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i -1]$, after, using the property of the relation $\triangleleft$ between state and updates, we know that $\applyplus{E_{i}.\known}{E_{i}.\receivebuffer[0].delta \cdots \ E_{i}.\receivebuffer[\treceivebuffer_i-1].delta} \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \cdot \ \cdots \ \cdot \ \queuemessage_A[\tknown_i + \treceivebuffer_i -1]$. As you note, the left side is reducestate's definition, then $\reducestate{E.\known}{E.\receivebuffer} u\triangleleft \queuemessage_A[0 \ldots \tknown_i + \treceivebuffer_i -1]$. Next, property by 6., we know that $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$, if we apply the extra axiom of $\triangleleft$, we will get that $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer[0].delta} \triangleleft \tpending \setminus \queuemessage[\tknown]$, so that, $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer} \triangleleft \tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]$. Therefore it worths.
							\item It does not change.
							\item It does not change.
							\item $E_{i}.\receivebuffer$ is $\epsilon$ and $\treceivebuffer$ is 0, therefore it property worths.
							\item It does not change.
							\item We know that $E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i$, if we apply the extra axiom of $\triangleleft$, we will get that $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer[0].delta} \triangleleft \tpending \setminus \queuemessage[\tknown]$, so that, $\remove{E_i.\pending \cdot E_i.\pushbuffer}{E_i.\receivebuffer} \triangleleft \tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer]$.
							\item to 9. do not change.
							
							
							

							
						\end{enumerate}
\end{itemize}

\end{itemize}
\end{proof}


\section{Consistency Guarantees}

We shall introduce a series of store-level consistency guarantees and then we shall show which are captured by application written in GSP. We start identifying three kinds of relations between actions of update and read:

 \paragraph{Session Order} relates whatever pair of actions from the same client, indicating the program order. It is a total order on actions. 

 \paragraph{Visibility} relates Updates with Reads. It is used to indicate is if an action of Update is visible for an action of Read.

 \paragraph{Arbitration} relates Updates with Updates. It is used to resolve update conflicts. It is a total order on actions of update.


We extend the GSP language with a new term which capture the relations amount operation in our system. 
 
\[
    \begin{array}{l@{\quad}r@{\;::=\;}l}
			 (\textsc{environment}) & \environmentterm &  \environment{\systemterm}{\op}{\so}{\vis}{\arb} \\
	    \end{array}
  \]
	
Let $\environmentterm$, a new term, where $\systemterm$ represents our system introduced in Definition 1.1, $\op$ is a mapping of vertices to actions, $\so$ is a session order relation defined from vertices to relations of vertices $\verticesets$ $\times$ ($\verticesets$ $\times$ $\verticesets$) and $\vis$,$\arb$ are visibility and arbitration relation.


 \paragraph{Notation.} Given a session order relation $\so$ from client $i$ and a vertex $v$, we shall write $\soby{\so}{v}$  meaning that $\soby{(\mathcal{V}, \mathcal{R})}{v} = (\mathcal{V} \ \cup \ \{v\}, \mathcal{R}\ \cup \ \{(x,v) / x \in \verticesets\})$. We shall refer to an update action on the queue message as $\updateinqueuemessage{n}{i}$.The arbitration relation $\arb$ is defined as $\{ (v,w) / \{v \mapsto \updateinqueuemessage{m}{h}\} \in \op \land \ \{w \mapsto \updateinqueuemessage{n}{i} \} \in \op \land \ m < n \}$. A transition $\arroi{\alpha}$ denotes the fact that action $\alpha$ is perfomed by client $i$.

 
The following operational semantic allow to understand how working the environment when the actions are executed.

 \[
 \begin{array}{l}
		
\mathrule{e-read}{\systemterm \arroi{\readtran{r}} \systemterm' \qquad v \notin 
dom(\op) \qquad \ \vis' = \vis \ \cup \ \{ (x,v) / \{x \mapsto \updatebyclient{h}\} \in \op \ \land \  u^x \in \ \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer] \}}{\environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\readtran{r}} \environment{\systemterm'}{\op \ \cup \ \{v \mapsto \readtran{r}\} }{\soby{\so}{v}}{\vis'}{\arb}}

 \\[35pt]

		\mathrule{e-update}{\systemterm \arroi{\updatevtran{u}{v}} \systemterm' \qquad v \notin 
dom(\op)}{\environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\updatevtran{u}{v}} \environment{\systemterm'}{\op \ \cup \ \{v \mapsto \updatetran{u} \}}{\soby{\so}{v}}{\vis}{\arb}}
 
 \end{array}
 \]

\subsection{Ordering Guarantees}

We now prove what ordering guarantees are assured by GSP language and what do not. 


First, we prove a useful lemma: 
\begin{lemma}\label{lemma:update-ever-belong} Let u an update action, $\queuemessage$ a message queue, $\tpending_i$ and $\ttransactionbuffer_i$ a pending queue and transaction queue from the client i, if $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $\{x \mapsto \updatebyclient{i} \}\ \in \ \op\ \Rightarrow\ u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$

\end{lemma}

\begin{proof} The proof follows by induction on the length of the derivation $\arro{} ^*$.
\begin{itemize}
   \item{\bf n=0}. Then $\op$ is $\emptyset$, so that antecedent is false, then the preoposition is true.
   \item{\bf n=k+1}. Then $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{} \{x \mapsto \updatebyclient{i} \}\ \in \ \op\ \Rightarrow\ u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. We proceed by 
case analysis on the last transition:
	
	\begin{itemize}
        \item {\bf rule (\textsc{E-READ})}. As $x$ is an update operation then it must not be $v$, so that $\{x \mapsto \updatebyclient{i} \} \in\ \op$, then by inductive hypothesis $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. When $\systemterm \arroi{\readtran{r}} \systemterm'$, $\tknown_i$, $\tpending_i$,$\ttransactionbuffer_i$ do not change.
				\item {\bf rule (\textsc{E-UPDATE})}. There are two possibilities:
				
				
					\begin{itemize}
						\item {\bf $x \neq v$}. Then we can use inductive hypothesis, so that it is easy to see that if $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$ then $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i] \cdot u_{t}^v$ too.
						\item {\bf $x =\ v$}. When $\systemterm \arroi{\updatevtran{u}{v}} \systemterm'$, $u^v \in \ttransactionbuffer'_i$ (with $\ttransactionbuffer'_i$ transaction queue in $\systemterm'$) because $\ttransactionbuffer'_i = \ttransactionbuffer_i \cdot u^v$. It is immediate to note that $u^x \in\  \queuemessage[0..\tknown'_i-1] \cdot \tpending'_i \cdot [\ttransactionbuffer'_i]$.
					\end{itemize}
				\item {\bf rule (\textsc{E-PUSH})}. As $\op$ do not change, then by inductive hypothesis, $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i] \equiv\ u^x \in\  \queuemessage[0..\tknown_i-1] \cdot (\tpending_i \cdot [\ttransactionbuffer_i]) \cdot \epsilon$. When $\systemterm \arroi{\pushtran} \systemterm'$, $\tknown_i$' = $\tknown_i$, $\tpending_i$' = $\tpending_i \cdot [\ttransactionbuffer_i]$ and $\ttransactionbuffer_i$' = $\epsilon$.
\item {\bf rule (\textsc{E-PULL})}. As $\op$ do not change, then by inductive hypothesis, $u^x \in\  \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. We should prove that it is equivalent to $u^x \in\  \queuemessage[0..\tknown_i - 1 + \treceivebuffer_i] \cdot \tpending_i \setminus \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i] \cdot [\ttransactionbuffer_i]$. There are two interesting cases to consider:
		\begin{itemize}
			\item If $u^x \in\ \tpending_i\  \land\ u^x \notin\ \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i]$, then $u^x \in \ \tpending_i$'.
			\item If $u^x \in\ \tpending_i\  \land\ u^x \in\ \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i]$, then $u^x \notin \ \tpending_i$' but $u^x \in\ \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i]$. 
		\end{itemize}
\end{itemize}
\end{itemize}

The proof for the remaining cases is by inductive hypothesis because $\op$, $\tknown_i$, $\tpending_i$ and $\ttransactionbuffer_i$ do not change.

\end{proof}

\begin{theorem}[\textsc{Read My Writes}]\label{theorem:read-my-writes}

Let $\textsc{\small{SO}}_R$ the second component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $\textsc{\small{SO}}_R \cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS}}$

\end{theorem}


\begin{proof} The proof follows by induction on the length of the derivation $\arro{} ^*$.
\begin{itemize}
   \item{\bf n=0}. In particular $\op$ and $\vis$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Then $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\alpha} \environment{\systemterm'}{\op'}{\so'}{\vis'}{\arb}$. We proceed by 
definition:
	
	\begin{itemize}
        \item $\textsc{\small{SO}}_R$' = $\textsc{\small{SO}}_R \cup\ \{(w,v) / \{w \mapsto \readtran{r}\} \lor\ \{w \mapsto \ \updatebyclient{j}\} \}$. Applying the intersection $(\mathbb{U}\ \times \ \mathbb{R})$, we shall obtain $\textsc{\small{SO}}_R \ \cup\ \{(w,v) / \{w \mapsto \updatebyclient{j}\} \}$.				
				\item $\vis' = \vis \ \cup \ \{ (x,v) / \{x \mapsto \updatebyclient{h}\} \in \op \ \land \  u^x \in \ \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer] \}$.
\end{itemize}
By inductive hypothesis, $\textsc{\small{SO}}_R \ \cup\ (\mathbb{U}\ \times \ \mathbb{R}) \subseteq \vis$. We only have to prove that $\{(w,v) / \{w \mapsto \updatebyclient{j}\} \in \op  \ \} \subseteq \{ (x,v) / \{x \mapsto \updatebyclient{h}\} \in \op \ \land \  u^x \in \ \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer] \}$. When $j = h$ and $w = x$, we can use Lemma~\ref{lemma:update-ever-belong}. So that, we have proved that $\textsc{\small{SO}}_R$' $\cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS'}}$.
\end{itemize}
\end{proof}



\begin{theorem}[\textsc{Monotonic Read}]
\label{theorem:monotonic-read}
Let $\textsc{\small{SO}}_R$ the second component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $(\textsc{\small{VIS}};\textsc{\small{SO}}_R) \cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS}}$

\end{theorem}


\begin{proof} The proof follows by induction on the length of the derivation $\arro{} ^*$.
\begin{itemize}
   \item{\bf n=0}. In particular $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Then $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb} \arroi{\alpha} \environment{\systemterm'}{\op'}{\so'}{\vis'}{\arb}$. Let $R$ be a composition of relations. We shall say that if $(x,y) \in \ R $ iff $\ \exists y \in\ \verticesets\ $ such that $(x,y) \in\ \textsc{\small{VIS}}' \land \ (y,z) \in\  \textsc{\small{SO}}_R$'. We have to prove that $(x,z) \in \ \textsc{\small{VIS}}$'. We proceed by 
case analysis on the last transition:
	
	\begin{itemize}
        \item {\bf rule (\textsc{E-READ})}. We know that $v$ is fresh, therefore, $v$ have not be neither $x$ nor $y$ because there exists $z$ such that, $z$ happens after from $x$ and $y$. There are only two possibilities:
					
					\begin{itemize}
						\item $z = v$. As $(y,z) \in \ \textsc{\small{SO}}_R$, then $y$ and $z$ are from the same client, called $i$. We are only interested in relations of $update \times\ read$. We know that $v$ is associated to an read action besides $x$ have to be an update action. As $(x,y) \in \ \textsc{\small{VIS}}$' then $y$ is an read action,i.e., $\{y \mapsto \readbyclient{i} \}\ \in \ \op$.By Lemma xx, there exists an update $u$ such that $u^x \in\ \ \queuemessage[0..\tknown_i-1] \cdot \tpending_i \cdot [\ttransactionbuffer_i]$. Substituting $w$ by $v$ in $\textsc{\small{VIS}}$', we prove that $(x,z) \in \textsc{\small{VIS}}$'.
						item $z \neq v$. This case follows immediately by inductive hypothesis.
					\end{itemize}
					
			  \item{\bf rule (\textsc{E-UPDATE})}. Visibility relation does not change,i.e.,$\textsc{\small{VIS}}$ = $\textsc{\small{VIS}}$'. Let $v$ be a vertex associated an update action, then $\textsc{\small{SO}}_R$' = $\textsc{\small{SO}}_R \cup\ \{(w,v) / \{w \mapsto \readtran{r}\} \lor\ \{w \mapsto \ \updatebyclient{j}\} \}$. As we are only interested in relations of $update \times\ read$, then $(\textsc{\small{VIS}}';\textsc{\small{SO}'}_R) \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \equiv \ (\textsc{\small{VIS}};\textsc{\small{SO}}_R) \cap \ (\mathbb{U}\ \times \ \mathbb{R})$. By inductive hypothesis we can prove that $(\textsc{\small{VIS}}';\textsc{\small{SO}}_R)' \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \ \subseteq \ \textsc{\small{VIS}} \subseteq \ \textsc{\small{VIS}}$'.				
				The proof for the remaining cases follow are not interesting because the relations does not change.
\end{itemize}
\end{itemize}
\end{proof}



\begin{theorem}[\textsc{No Circular Causality}]

Let $\textsc{\small{SO}}_R$ the second component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then $\textbf{acyclic}(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^+$.

\end{theorem}

\begin{proof}

Since $\textsc{\small{VIS}}$ is acyclic and $\textsc{\small{SO}}_R \cap \ (\mathbb{U}\ \times \ \mathbb{R})  \subseteq \ \textsc{\small{VIS}}$ by Theorem~\ref{lemma:update-ever-belong}, we have to prove that $\textsc{\small{VIS}} ^+$ is acyclic. In particular, the transitive closure of an acyclic graph is the reachability relation of the directed acyclic graph and a strict partial order.

\end{proof}





\begin{theorem}[\textsc{Causal Visibility}]

Let $\textsc{\small{SO}}_R$ the second component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{+} \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \subseteq \textsc{\small{VIS}}.$ 

\end{theorem}
 

\begin{proof} The proof follows by induction on the number of union sets between $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$. Then, $\bigcup_{n=1}^{\infty} (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{n} \cap \ (\mathbb{U}\ \times \ \mathbb{R}) \subseteq \textsc{\small{VIS}}.$
\begin{itemize}
   \item{\bf n=0}. This means that $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Suppose that we have proved that the number of union sets $< k+1$. Now, we have to prove that: $\forall (a,b) \mid (a,b \in \verticesets \Rightarrow\ (a,b)\ \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1} \cap \ (\mathbb{U}\ \times \ \mathbb{R})) \Rightarrow\ (a,b) \in \textsc{\small{VIS}}$.
	
Assume $(a, x_1),(x_1, x_2),\ldots(x_{k{-}1}, x_k),(x_{k}, b)$ are relations from $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$. Then $(a, x_1),(x_1, x_2),\ldots(x_{k{-}1}, x_k)$ are relations from $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$. By the induction hypothesis, $(a, x_k) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$, and we also have $(x_k, b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} )$. Thus by the definition of $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$, $(a, b) \in
(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$.
Conversely, assume $(a,b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1}$ = $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k} \circ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}})$. Then there is a vertex $c \in \verticesets$ such
that $(a,c) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$ and $(c, b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} )$.

We are only interested when $a$ is an update action and $b$ a read action. It is because of the intersection with $(Update \times Read)$. We have two possible cases:

\begin{itemize}
	\item c is a read action. It means that $(c, b)$ only can be in $\textsc{\small{SO}}_R$ because $\textsc{\small{VIS}}$ requires that $c$ will be an update action. In particular, if  $(c, b) \in\ \textsc{\small{SO}}_R$, they belong to the same client. 
	
	\begin{itemize}
		\item if $(a,c) \in\ \textsc{\small{VIS}}$ and $(c,b) \in\ \textsc{\small{SO}}_R$, by Theorem~\ref{theorem:monotonic-read}, $(a,b) \in\ \textsc{\small{VIS}}$.
		
		\item if $(a,c) \in\ \textsc{\small{SO}}_R$ then by Theorem~\ref{theorem:read-my-writes}, $(a,c) \in\ \textsc{\small{VIS}}$- Then, it is analogous to the previous case.
		
	\end{itemize}
	\item c is an update action. It means that $(a, c)$ only can be in $\textsc{\small{SO}}_R$ because $\textsc{\small{VIS}}$ requires that $c$ will be an read action. In particular, if  $(a,c) \in\ \textsc{\small{SO}}_R$, they belong to the same client.
	
	\begin{itemize}
		\item if $(a,c) \in\ \textsc{\small{SO}}_R$ and $(c,b) \in \textsc{\small{VIS}}$, by Theorem Monotonic Writes (Falta probar!), $(a,b) \in\ \textsc{\small{VIS}}$.
		\item if $(a,c) \in\ \textsc{\small{VIS}}$ ... VER.
	\end{itemize}
\end{itemize}


	
	
\end{itemize}
\end{proof}


\begin{theorem}[\textsc{Causal Arbitration}]

Let $\textsc{\small{SO}}_R$ the second component of the relation $\textsc{\small{SO}}$, $\textsc{\small{VIS}}$ a visibility relation and $\textsc{\small{AR}}$ an arbitration relation then $(\mathbb{U}\ \times \ \mathbb{U}) \cap \ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{+} - \textsc{\small{SO}}_R \subseteq \textsc{\small{AR}}.$ 

\end{theorem}
 

\begin{proof} 
The proof follows by induction on the number of union sets between $\textsc{\small{SO}}_R$ and $\textsc{\small{VIS}}$. Then, $(\mathbb{U}\ \times \ \mathbb{U}) \cap \ \bigcup_{n=1}^{\infty} (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{n} - \textsc{\small{SO}}_R \subseteq \textsc{\small{AR}}.$


\begin{itemize}
   \item{\bf n=0}. This means that $\textsc{\small{SO}}_R$, $\textsc{\small{VIS}}$ and  $\textsc{\small{AR}}$ are $\emptyset$, so that $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Suppose that we have proved that the number of union sets $< k+1$. Now, we have to prove that: $\forall (a,b) \mid (a,b \in \verticesets \Rightarrow\ (a,b)\ \in\ (\mathbb{U}\ \times \ \mathbb{U}) \cap \ \bigcup_{n=1}^{\infty} (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1} - \textsc{\small{SO}}_R \Rightarrow\ (a,b) \in \textsc{\small{AR}}$. 

Assume $(a,b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k+1} $ = $(\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k} \circ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}})$. Then there is a vertex $c \in \verticesets$ such
that $(a,c) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} ) ^{k}$ and $(c, b) \in\ (\textsc{\small{SO}}_R \ \cup \ \textsc{\small{VIS}} )$.

We are only interested when $a$ and $b$ are an update actions. It is because of the intersection with $(Update \times Update)$. We have two possible cases:
\begin{itemize}
	\item c is a read action. It means that $(c,b)$ only can be in $\textsc{\small{SO}}_R$ because $\textsc{\small{VIS}}$ requires that $c$ will be an update action. In particular, if  $(c,b) \in\ \textsc{\small{SO}}_R$, they belong to the same client. COMPLETAR
	
	\item c is an update action. COMPLETAR
\end{itemize}
\end{itemize}

\end{proof}


\begin{example}[Consistent Prefix] 
\label{consistent-prefix}Consider the following system built-up from two 
different client:

\[
\begin{array}{l}
E = \environment{\tclient{\textit{update(aList.add('a'));push();}}{0}{\epsilon}{\epsilon}{\epsilon}{0}_1\ \bigpar\
\\
\tclient{\textit{update(aList.add('b'));push();let v = read(x);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}_2  \bigpar\ \epsilon}{\emptyset}{\emptyset}{\emptyset}{\emptyset}
\end{array}
\]
\end{example}
		
Environment has a system $\systemterm$ with two clients and a message queue $S$ without updates. Relation sets $\op$,$\so$,$\vis$,$\arb$ are empty, i.e.,there were not an execution in $\systemterm$ captured by the relation sets. The update action add a string to an object called $aList$ which has not elements. 
In this state, $C_1$ and $C_2$ can perform their update actions. E may non-deterministically choose to do $update(aList.add('a')$ or $update(aList.add('b')$. If the first communication takes place over $update(aList.add('a')$, then the system evolves as follows:

\[
\begin{array}{l}
E \arrobyclient{\updatevtran{aList.add('a')}{{v_0}}}{1} \environment{\tclient{push();}{0}{\epsilon}{[aList.add('a')]}{\epsilon}{0}_1\ \bigpar\
\\
\tclient{\textit{update(aList.add('b'));push();let x = read(aList);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}_2  \bigpar\ \epsilon} 
{\\ \emptyset}{\{( \{ v_0 \} , \emptyset ) \}}{\emptyset}{\emptyset} 
\end{array}
\]

The action $\updatetran{aList.add('a')}$ of the client $1$ will be identified by vertex $v_0$ by rule $\textsc{\small{E-UPDATE}}$. In particular, the update action will be left into the transactional queue of Client $1$ besides the new vertex will be added to vertices in $\so$. Now, Client 1 performs $\pushtran$: 

\[
\begin{array}{l}
E \arrobyclient{\pushtran}{1} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{[aList.add('a')]}{0}_1\ \bigpar\
\\
\tclient{\textit{update(aList.add('b'));push();let x = read(aList);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}_2  \bigpar\ \epsilon} 
{\\ \emptyset}{\{( \{ v_0 \} , \emptyset ) \}}{\emptyset}{\emptyset} 
\end{array}
\]
		
When it happens, $aList.add('a')$ is moved to the sent queue and pending queue. At this moment, Client 2 can perform an update action however Client 1 will realize an internal action which is given by $\textsc{\small{E-PROCESS}}$.  			

\[
\begin{array}{l}
E \arrobyclient{\tau}{1} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}_1\ \bigpar\ \\
\tclient{\textit{update(aList.add('b'));push();let x = read(aList);}}{0}{\epsilon}{\epsilon}{\epsilon}{0}_2  \bigpar\ \\ 
aList.add('a')} 
{\emptyset}{\{( \{ v_0 \} , \emptyset ) \}}{\emptyset}{\emptyset} 
\end{array}
\]

Analogously, Client 2 realize its actions leaving to environment evolves as below:

\[
\begin{array}{l}
E \arrobyclient{\updatetran{aList.add('b')}}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}_1\ \bigpar\
\\
\tclient{\textit{push();let x = read(aList);}}{0}{\epsilon}{[aList.add('b')]}{\epsilon}{0}_2  \bigpar\ 
\\ aList.add('a')} {\emptyset}{\{( \{ v_0,v_1 \} , \{\ (v_0,v_1) \} ) \}}{\emptyset}{\emptyset} 
\\
\\
\arrobyclient{\pushtran}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}_1\ \bigpar\
\\
\tclient{\textit{let x = read(aList);}}{0}{[aList.add('b')]}{\epsilon}{[aList.add('b')]}{0}_2  \bigpar\ 
\\ aList.add('a')}{\emptyset}{\{( \{ v_0,v_1 \} , \{\ (v_0,v_1) \} ) \}}{\emptyset}{\emptyset} 
\\
\\
\arrobyclient{\tau}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}_1\ \bigpar\
\\
\tclient{\textit{let x = read(aList);}}{0}{[aList.add('b')]}{\epsilon}{\epsilon}{0}_2  \bigpar\ 
\\aList.add('a') \cdot [aList.add('b')]} {\emptyset}{\{( \{ v_0,v_1 \} , \{\ (v_0,v_1) \} ) \}}{\emptyset}{\{ (v_0,v_1) \}} 
\\
\\
\arrobyclient{\readtran{aList}}{2} \environment{\tclient{0}{0}{[aList.add('a')]}{\epsilon}{\epsilon}{0}_1\ \bigpar\
\\
\tclient{\update{0}{x}{['b']}}{0}{[aList.add('b')]}{\epsilon}{\epsilon}{0}_2  \bigpar\ aList.add('a') \cdot [aList.add('b')]} 
\\
{\emptyset}{\emptyset}{\emptyset}{\emptyset} 
\end{array}
\]
		
Note that $\arb$ is modified because the message queue has two elements. The value returned will be the list with a only element, ['b'], because of the internal action associated to the rule $\textsc{\small{E-RECEIVE}}$ did not perform it. Then, if the rule $\textsc{\small{E-RECEIVE}}$ were performed, the value of the list would be ['a','b']. It is because the content of the pending queue is removed when the server left their message. 

The guarantee Consistent Prefix, which rules is $(\textsc{\small{AR}};\textsc{\small{VIS}}) \subseteq \ \textsc{\small{AR}};\textsc{\small{VIS}}$, states that if we see an result from a client in a particular order, we will never see this result in a different order.

\section{Extending GSP}

As illustrated in above examples, there are situations in which a environment does not ensures consistency guarantees as Consistent Prefix or Single Order. The nature of such cases is caused by having no transactions as the usual databases.

The remaining of this section is proposing a environment that ensures these consistency guarantees. We start by refining the environment in GSP. We will distinguish a new relation:

\paragraph{Return Before} relates updates actions. It indicates the ordering of non-overlapping operations.

\[
    \begin{array}{l@{\quad}r@{\;::=\;}l}
			 (\textsc{environment}) & \environmentterm &  \environmenttran{\systemterm}{\op}{\so}{\vis}{\arb}{\rb}{\tx}{\tc} \\
			 (\textsc{transactions with overlapping}) & \tx &  \emptyset  \ | \ w^j \mapsto \mathcal{N},\tx  \  with \ w \ \in\ \verticesets\, j \in\ \mathbb{N} \\
			 (\textsc{transactions closed}) & \tc &  \epsilon  \ | \ w^j \cdot \tc \ with \ w \ \in\ \verticesets\, j \in\ \mathbb{N} 

	    \end{array}
\]


The term $\tx$ relates vertex from a client to set of vertex which have just not finished; $\tc$ denotes transaction closed.


\subsection{Operational Semantic}

%\subsubsection{Notation}

%\begin{flushleft}
%\specfunction{$\downharpoonright$}{$\verticesets$}{$2^\verticesets$}{$2^\verticesets$} \\
%$\downharpoonright v^i \emptyset$ =  $\emptyset$ \\
%$\downharpoonright v^i (x^h \mapsto V)$ = x^h \mapsto V \cup \ v^i;  $\downharpoonright v^i V$ \\
%\end{flushleft}


We assume the following countable sets of transactional vertices names $[\verticesets]$ ranged over by $[v];[v_0];[v_1],\ldots$;

The labeled transition system for the extension of GSP considers the following actions $\beta$:	

\[ 
\begin{array}{r@{\ ::= \ }l}
  \beta & \alpha \ | \ \startsynctran \ | \ \finishsynctran  \ | \  [\alpha] \\
\end{array}
\]

These labels allow system to perform an update synchronous. Label $\startsynctran$ stands for the begining of a transaction, and $\finishsynctran$ the end of it.



 \[
 \begin{array}{l}    \hspace{-.3cm} \textsc{ENVIRONMENT}\\

		
\mathrule{e-start-sync}{\systemterm \arroi{\syncupdtran{u}{v}} \systemterm' \qquad [v^i] \notin 
dom(\tx)}{\environmenttran{\systemterm}{\op}{\so}{\vis}{\arb}{\rb}{\tx}{\tc} \arroi{\startsynctran} \environmenttran{\systemterm'}{\op}{\so}{\vis}{\arb}{\rb}{\tx;v^i \mapsto dom(\tc)}{\tc}}

 \\[35pt]

\mathrule{e-end-sync}{\systemterm \arroi{\finishsynctran(u^{[v]})} \systemterm' \qquad [v^i] \in 
dom(\tx)}{\environmenttran{\systemterm}{\op}{\so}{\vis}{\arb}{\rb}{v^i \mapsto \mathcal{N},\tx}{\tc} \arroi{\finishsynctran([v^i])} \environmenttran{\systemterm'}{\op}{\so}{\vis}{\arb}{\rb'}{\tx}{\tc \cdot\ v^i}}
\\
 \\[10pt]where \ 
\rb' = \rb \cup\ \{ (x,v) \ | \ \forall 0 \leq m,n < |\queuemessage|, x \mapsto \queuemessage[m] \ \land \ v \mapsto \queuemessage[n] \ \land \ m \leq\ n \ \land \ x\notin\tc(v) \}
 \end{array}
 \]


\[
 \begin{array}{l} \hspace{-.3cm} \textsc{PROGRAM}\\


\mathax{t-sync-update}{\tsystem{\tclienti{\tsyncupd{u};\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arroi{\syncupdtran{u}{v}} \tsystem{\tclienti{[\tupdins;\tflush];\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage}}
 
 \\[15pt]

\mathrule{t-tran}{\tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arroi{\alpha} \tsystem{\tclienti{\tprogram'}{\tknown'}{\tpending'}{\ttransactionbuffer'}{\tsent'}{\treceivebuffer'}\ \bigpar\ C}{\queuemessage}}{\tsystem{\tclienti{[\tprogram];Q}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arroi{[\alpha]} \tsystem{\tclienti{[\tprogram'];Q}{\tknown'}{\tpending'}{\ttransactionbuffer'}{\tsent'}{\treceivebuffer'}\ \bigpar\ C}{\queuemessage}}

 \\[25pt]

 
\mathax{t-flush}{\tsystem{\tclienti{[\tflush];\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arroi{\tau} \tsystem{\tclienti{[\twhile{cond}{Q}];\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage}}
 
 \\[15pt]

\mathax{t-end-sync}{\tsystem{\tclienti{[0];\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage} \arroi{\finishsynctran(u^{[v]})} \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ C}{\queuemessage}}
 

 \end{array}
 \]
 

\end{document}
