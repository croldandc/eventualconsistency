% !TEX root = main.tex

\section{Proof of results in \secref{sec:transactions}}


First, we prove a useful lemma: 

\begin{lemma}\label{lemma:empty_queue} 

$\forall C$ such that 

\[
\begin{array}{l}
   \tclienti{Q}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} \ 
   \\ \Arro^* \ \tclienti{\tsyncupd{u};\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer} 
   \\
	  \Arro^* \ \tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}
\end{array}
\] then  
rvalue operation always reads above the store.

\end{lemma}

\begin{proof} Confirmed is evaluated to true when $\tpending$ and $\ttransactionbuffer$ are empty so that, after the loop, the read operation only return values which belong to the Store.
\end{proof}	

\begin{lemma} $\ovis = \roarb$ iff 

\begin{enumerate}
   \item $\roarb;\ovis \subseteq \ovis$; and
   \item $\neg\ovis;\neg\roarb \subseteq \neg\ovis$.
\end{enumerate}
\end{lemma}

\begin{proof} $\Rightarrow$) 
\begin{enumerate}
\item
	\[ \begin{array}{l@{\ =\ }l@{\qquad}l}
		\roarb;\ovis &  \roarb;\roarb & \roarb =\ovis\\
		& \roarb & \roarb \mbox{is a partial order (i.e., transitive)}\\
		&  \ovis & \roarb =\ovis
   	\end{array}
	\]
\item Note that  $\roarb;\ovis =\ovis$ implies $\neg(\roarb;\ovis) =\neg\ovis$. By property of complement and composition, $\neg(\roarb;\ovis) =\neg\ovis;\neg\roarb =\neg\ovis$. 
\end{enumerate}

$\Leftarrow)$ We divided the proof in two implications
 \begin{enumerate}
    \item  $\roarb;\ovis \subseteq \ovis$ implies $\ovis\subseteq \roarb$. We proceed by contradiction. Assume $(a,b)\in\ovis$ but $(a,b)\not\in\roarb$.
    Since $\roarb$ is a total order, $(b,a)\in\roarb$. By assumption, $(b,a)\in\roarb$ and $(a,b)\in\ovis$ implies $(b,b)\in\ovis$, but this is in contradiction 
    with the fact that $\ovis$ is acyclic. 
        
    \item $\neg\ovis;\neg\roarb \subseteq \neg\ovis$ implies $\roarb\subseteq\ovis$. We proceed by contradiction. 
    Assume $(a,b)\in\roarb$ and $(a,b)\not\in\ovis$, and hence,  $(a,b)\in\neg\ovis$. Since,
    $\roarb$ is a strict total order $(b,a)\not\in\roarb$. Hence, $(b,a)\in\neg\roarb$. By assumption, $(a,b)\in\neg\ovis$ and $(b,a)\in\neg\roarb$ implies $(a,a)\in\neg\ovis$.
    Again, by assumption, 
 \end{enumerate}

\end{proof}

\begin{proof}[\lemref{thm:single-order}]
Firstly, we will prove by induction on on the length of the derivation that $\textsc{\small{AR}};\textsc{\small{VIS}} \subseteq \textsc{\small{VIS}}$, i.e., for all $\vertice_a$,$\vertice_b$,$\vertice_c$ such that ($\vertice_a$,$\vertice_b$) $\in$ $\textsc{\small{AR}}$ and ($\vertice_b$,$\vertice_c$) $\in$ $\textsc{\small{VIS}}$ then ($\vertice_a$,$\vertice_c$) $\in$ $\textsc{\small{VIS}}$.

\begin{itemize}
   \item{\bf n=0}. It is easy to see because of both relations are empty, hence is trivial $\emptyset \subseteq \emptyset$.
   \item{\bf n=k+1}. Then $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \arro{} ^n\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}\arroi{\alpha} \environment{\systemterm'}{\op'}{\so'}{\vis'}{\arb'}[\sse']$. We proceed by case analysis on the last transition:
	
	\begin{itemize}
        \item {\bf rule (\ruleName{a-read})}. $\arb'$ = $\arb$.  Then, there exists two cases: 				
				\begin{itemize}
					\item $\vertice_c \neq \vertice$, as $\vertice$ is an vertex associated to the last computation, then ($\vertice_b$,$\vertice_c$) $\in$ $\vis$, therefore, ($\vertice_b$,$\vertice_c$) $\in$ $\vis'$. By inductive hypothesis, ($\vertice_a$,$\vertice_c$) $\in$ $\vis$. Hence, $\vertice_c \neq \vertice$ then ($\vertice_a$,$\vertice_c$) $\in$  $\vis'$.
					\item $\vertice_c$ = $\vertice$. Since $\vertice_a$, $\vertice_b \in \arb$ then there exist two updates into the Store associated to them. Let $\udec[u][\vertice_a]$, $\udec[u][\vertice_b]$ be these updates, then we know that $\udec[u][\vertice_a]$ = $\queuemessage$[m] and $\udec[u][\vertice_b]$ = $\queuemessage$[n] such that $m < n$. If ($\vertice_b$,$\vertice_c$) $\in$ $\vis$ then $\udec[u][\vertice_b]$ $\in \queuemessage[0..\tknown-1] \cdot \tpending \cdot [\ttransactionbuffer]$ by definition. Then, analyzing cases:
					\begin{itemize}
						\item $\udec[u][\vertice_b]$ $\in \queuemessage[0..\tknown-1]$. Then $\udec[u][\vertice_a]$ also is in $\queuemessage[0..\tknown-1]$ because of $\udec[u][\vertice_a]$ = $\queuemessage$[m] and $\udec[u][\vertice_b]$ = $\queuemessage$[n] and $m < n$.
						\item $\udec[u][\vertice_b]$ $\notin \tpending$ and $\udec[u][\vertice_b]$ $\notin [\ttransactionbuffer]$ by $\lemref{lemma:empty_queue}$.
					\end{itemize}
					
				\end{itemize}
				
			\item The rest of the rules do not change $\textsc{\small{VIS}}$.

\end{itemize}

\end{itemize}

Now, we will prove by induction on on the length of the derivation that $\textsc{\small{AR}}^{-1};\neg\textsc{\small{VIS}} \subseteq \neg\textsc{\small{VIS}}$, i.e., for all $\vertice_a$,$\vertice_b$,$\vertice_c$ such that ($\vertice_b$,$\vertice_a$) $\in$ $\textsc{\small{AR}}$ and ($\vertice_a$,$\vertice_c$) $\notin$ $\textsc{\small{VIS}}$ then ($\vertice_b$,$\vertice_c$) $\notin$ $\textsc{\small{VIS}}$. This prove is analogue when $\vertice_c \neq \vertice$. Furthermore, if $\udec[u][\vertice_a]$ $\notin \queuemessage[0..\tknown-1]$ then $\udec[u][\vertice_b]$ $\notin \queuemessage[0..\tknown-1]$ because of $\udec[u][\vertice_b]$ is before to $\udec[u][\vertice_a]$ at Store, then 
\end{proof}
	




