% !TEX root = main.tex

\section{Equivalence}

We have introduced an abstract GSP protocol and a robust streaming server-client implementation of GSP. There exists a relation represented by $\triangleleft$ [~ref:] which relates state and delta objects to the update sequences. 

\[
\begin{array}{l@{\quad\qquad}l@{\quad\qquad}l}
  \mathax{\triangemptydelta\medskip\medskip}{\medskip\medskip\emptydelta \triangleleft \epsilon}{} 
  &
  \mathrule{\triangappend}
  		{\adelta \triangleleft \anupdseq}
		{\iappend \adelta \anupd  \triangleleft \anupdseq \cdot \anupd}
  &
   \mathrule{\triangreduce}
   		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
\\
  \mathax{\trianginitialstate\medskip\medskip}{\medskip\medskip\initialstate \triangleleft \epsilon}{} 
  &
  \mathrule{\triangapply}
  		{\astate \triangleleft \anupdseq \quad \adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\iapply \astate {\adelta[_1]\cdots\adelta[_n]}  \triangleleft \anupdseq \cdot\anupdseq[_1] \cdots \anupdseq[_n]}
  & 
  \mathrule{\triangread}
  		{\astate \triangleleft \anupdseq}
		{\iread r \astate  = \rvalue r  \anupdseq}  
\\
  \multicolumn{3}{c}{\mathrule{\triangremove}
  		{\adelta[_1] \triangleleft \anupdseq[_1]\ \ldots\ \adelta[_n] \triangleleft \anupdseq[_n]}
		{\iremove{\adelta[_1] \cdots \adelta[_n]}{\adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_{n-1}]}  }
\end{array}
\]


\begin{lemma}\label{lemma:apply} $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ iff $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.
\end{lemma}

\begin{proof} $\Rightarrow)$ The only possible derivation for $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ is

\[
   \mathrulean{\triangapply}
  		{ \astate \triangleleft \anupdseq['] \qquad\qquad
	   		\mathrulean{\triangreduce}
   				{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
				{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}	  
		}
		{\iapply \astate {\ireduce{\adelta[_0]\cdots\adelta[_n]}}  \triangleleft  \anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]}
\]
and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.

$\Leftarrow)$ Follows analogously. 
\end{proof}


\begin{lemma}\label{lemma:reduce} if $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]\cdot \adelta[_n]}\triangleleft \anupdseq \cdot \anupdseq[_n]$ and $\adelta[_n] \triangleleft \anupdseq[_n]$ then $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$.
\end{lemma}

\begin{proof} $\Rightarrow)$ The only possible derivation for $\ireduce {\adelta[_1] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq \cdot \anupdseq[_n]$ is

\[
   \mathrulean{\triangreduce}
  		{\mathrulean{}
   			{}
				{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]}	\qquad\qquad
	   		\adelta[_n] \triangleleft \anupdseq[_n]  
		}
		{\ireduce {\adelta[_1] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq \cdot \anupdseq[_n]}	
\]
%and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
%above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.

$\Leftarrow)$ Follows analogously. 
\end{proof}
%\begin{itemize}
%	\item On $\mathit{Delta} \times \mathit{Update}^*$, let $\triangleleft$ be the smallest relation such that (1) $\emptydelta \triangleleft []$, and
%(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates $u$, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$ and (4) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $\remove{d_1 \ldots d_{n}}{d_n} \triangleleft a_1 \cdots a_{n-1}$. \marginpar{El (4) lo agregamos nosotros. ¿Se aclara? ¿C\'omo?}
%  
%\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $\initialstate \triangleleft []$, and
%(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
%\end{itemize}
%
% 

\begin{definition} \label{def:implementation}
Let  $\systemterm = \abstsyst[@][@][\Absclient_j]$ with $\Absclient_l={\abstcliJ}$be a \tgspcalculus\ system and 
$\isystemterm = \concsyst $  with $\iserver = \iserverins$ and $\iclient_l = \addid{\iclientinstJ}[{\cid{_l}}]$ 
an streaming implementation
system. We say $\isystemterm$ implements $\systemterm$ if the following conditions hold for all $l \in L$,

\begin{enumerate}
	\item \henote{eliminada}
	% $\rvalue{r}{\flatten{\queuemessage_{A}[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}}$
	\item $\astate \triangleleft \queuemessage$
	\item \label{prop_transactions} ${\transactionbuffer}_j\triangleleft{\ttransactionbuffer}_j$ 
	\item \chnote{revivi}	
	%$E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i - 1]$
		\label {prop_inclient} if $\inclient_l = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]$ then 
		$\adelta[_1] \triangleleft \queuemessage_A[\tknown_i] \ldots \adelta[_k] \triangleleft \queuemessage_A[\tknown_l + \treceivebuffer_l - 1]$
	\item \label{prop_state_known} $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]}$
	\item \label{prop_pending} $\pending_l = \aroundtuplei[0]\ldots\aroundtuplei[h]$ and $\ireduce{\adelta_0\cdots\adelta_h\cdot {\pushbuffer}_l} \triangleleft \flatten{\tpending_l}$
	\item \label{prop_size_buffersent} $|\tsent_l| = n$ \chnote{esto no lo tenia en el modelo original. Chequear que n ni send en abstracto no se modifiquen}
	%\item \label{prop_size_inclient} $|\inclient_l| = \treceivebuffer_l$ \chnote{esto es nuevo.}
	
	\item ${\inclient}_l = \agssegpairi \cdots \agssegpairi[h]$ and $\ireduce{\adelta_0\cdots\adelta_h}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l-1]$
	% $\length{\inclient}_l = \treceivebuffer_l$ and for all $0 \leq h < \treceivebuffer_l$,  $\inclient[h] = \agssegpair$ and $\adelta\triangleleft{\queuemessage[\tknown + l]}$
	\item $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$
	\henote{no muy seguro}
	\item For all update sequence $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$
		\item For all natural $m$, such that $0 \leq m < |\outserver(i)| - 1$ then $\outserver(i)[m] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient| + m]$
\end{enumerate}
 
\end{definition}

Next theorem states one of most important result of the paper, saying that abstract GSP protocol and the implementation of GSP are weak bisimulation equivalent (or weakly bisimilar).

We use $\approx$ for standard weak bisimulation.

\begin{theorem} If  $\isystemterm$ implements $\systemterm$, then $\isystemterm\approx\systemterm$. 
\end{theorem}



\begin{proof} We show that the following relation is a weak bisimulation.
\[
\mathcal{R} = \{ (\isystemterm, \systemterm) \ |\ \implements{\isystemterm{}}{\systemterm} \}
\]


%Let $A$ be a system from abstract GSP Protocol, defined as  then both system are weakly bisimilar, written $A \approx C$, if $(A,C)  \in \ \mathcal{R}$, where $\mathcal{R}$ be a binary relation defined as $\{ (\parallel_{i \ \in\ I_{\{0 \ldots n\}}} A_i \parallel \ \queuemessage_A),(\parallel_{i \ \in\ I_{\{0 \ldots n\}}} C_i \parallel \ \queuemessage_C) \ | \ \forall i \ \in\ \mathbb{N}, \forall r: \readtype, A_i = \ \tclient{\tprogram_i}{\tknown_i}{\tpending_i}{\ttransactionbuffer_i}{\tsent_i}{\treceivebuffer_i} \land C_i = \client{P_i}{\stateclient_i}$ and the conjunction of the following properties: %\land \ \rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}} \land \ \queuemessage_C.\state \triangleleft \queuemessage_A \land \ E_{i}.\transactionbuffer = [\ttransactionbuffer_i] \land \ E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i] - 1 \ \land \ E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \ \land \  E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i \ \land \ \forall l, 1 \leq l < |\inclient|, E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l] \ \land \ \tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0 \ \land \ \forall \beta \ \in \ \tsent_i, \beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver
%\marginpar{Ac\'á deber\'ia decir que R cumple las propiedades de weak bisimulation. C\'omo lo escribo mejor?}


%The proof follows by induction on the length of the derivation $\arro{} ^*$.
 We use $\tilde{A}$ and $\tilde{C}$ to denote clients, except client $i^{th}$, interacting concurrently, i.e., $\parallel_{j \ \in\ I_{\{0 \ldots n\} - i}}$ $A_j$ or $C_j$ respectively.

\begin{itemize}
   
	
   \item{\bf n=k+1}. $\forall (\systemterm ,\isystemterm ) \ \in \ \mathcal{R}$
   
  % \henote{Para no escribir $\mathcal{R}^{-1}$ podemos cambiar la definici\'on $\mathcal{R}$}
		
			
			\begin{itemize}
%				\item {\bf rule (\textsc{t-read})}. If $\systemterm  \arroi{\readtran{r}} \systemterm '$, then by rule (\textsc{\footnotesize{t-read}}), $\systemterm $ must be the following term: 
%				$\tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				, therefore, the client $i^{th}$ is the only one who have changed. So that, $\systemterm'$ is 
%				$\tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				. As $(\systemterm,\isystemterm)$ belongs $\mathcal{R}^{-1}$ then $\isystemterm$ must be $\clientr{\readins{x}{r}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $\isystemterm$ can perform.
%				Then by rule (\textsc{read}), $\isystemterm' = \clientr{\update{P}{x}{v}}{\stateclient}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We will prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}^{-1}$ if the ten properties introduced are keeping.				
				\item {\bf rule \ruleName{t-read}}. Then, $\systemterm  \arroi{\readtran{r}} \systemterm '$ with 
				\[\begin{array}{r@{=}l}
					\systemterm & \tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					\\
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					\\
					v &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  \end{array}
				\]
		
				\henote{Ac\'a es $\systemterm['']$ porque $N$ es el que estas usando}.
				
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\isystemterm \arroi{\readtran{r}} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					v' & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
				  \end{array}		
				\]
				
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by property \ref{prop_state_known};
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						\end{itemize}
						
						Then, we can build the following proof for 
						$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						= 
						\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						\[
						  \mathrulean{\triangread}
						    {
								  \mathrulean{\lemref{lemma:apply}}
									{
										\mathrulean{\triangapply}
										{
										\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										\quad 
										\mathrulean{\lemref{lemma:reduce}}
											{
												\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												\quad
												\transactionbuffer \triangleleft \ttransactionbuffer
											}
											{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										}
										{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									}
									{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
								}
  						  {v'  = v}  
					\]
											
						\item to 9 straightforwardly hold.
						

					\end{enumerate}
					
					
			\item {\bf rule \ruleName{t-update}}. Then, $\systemterm  \arroi{\updatetran{u}} \systemterm '$ with 
				\[\begin{array}{r@{=}l}
					\systemterm & \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					\\
					\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  \end{array}
				\]
				\chnote{Deberi\'amos cambiar la regla del update en la imple para que guarde updates con vertices como hacemos en abs}.
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,

				\[\addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\isystemterm \arroi{\updatetran{u}} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	\\
				  \end{array}		
				\]
				
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item The only terms that have changed are the transaction buffers in client $\cid$. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						\end{itemize}
						
						Then, we can build the following proof for 
						$\iappend{\transactionbuffer}{u}
						\triangleleft 
						\ttransactionbuffer \cdot \tupdate$
						\[
						  \mathrulean{\triangappend}
						      {
						      \transactionbuffer \triangleleft{\ttransactionbuffer}
						      }
  						{\iappend{\transactionbuffer}{u}]
						\triangleleft 
						\ttransactionbuffer \cdot \tupdate}  
					\]

						 \chnote{Esta prueba es m\'as inmediata, creo que aca no haria falta mostrar el detalle ya que es solo un paso. Con mencionar la regla del append tiene que alcanzar, lo dejo por si preferis que quede asi.}.

						\item to 9 straightforwardly hold.
						

					\end{enumerate}
	
	
			\item {\bf rule \ruleName{t-push}}. Then, $\systemterm  \arroi{\pushtran} \systemterm '$ with 
				\[\begin{array}{r@{=}l}
					\systemterm & \tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}['']}
					\\
					\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot [\ttransactionbuffer]}{\epsilon}{\tsent \cdot [\ttransactionbuffer]}{\treceivebuffer}}[{\systemterm['']}]
				  \end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \addid{\iclientinst[\tpushins]} \ \bigpar \ \isystemterm['']\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\isystemterm \arroi{\pushtran} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\isystemterm['] & {\addid{\iclientinst[P][@][@][\ireduce{\pushbuffer\cdot \transactionbuffer}][\epsilon][@][n+1]}\ \bigpar \ \isystemterm['']}	\\
				  \end{array}		
				\]
				
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item We will inspect the terms that have changed in client $\cid$ knowing as hypothesis that $\implements{\isystemterm}{\systemterm}$.
						\begin{itemize}
							
							\item By \propref{prop_transactions}, $\transactionbuffer \triangleleft{\ttransactionbuffer}$. Now, the term in our abstract model is $\epsilon$ and in the implementation is $\emptydelta$, then, by \triangemptydelta this property holds.
							\chnote{en las reglas de la implementacion donde ponemos epsilon, revisar que deberia ser emptydelta o emptystate}
							
						\item By \propref{prop_pending}, $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ however, after $\pushtran$ transition, we should build the following proof for 
						$\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}\cdot \transactionbuffer}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]} \ $
						
					\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
								\quad
								\transactionbuffer \triangleleft \ttransactionbuffer}
  						{\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}\cdot \transactionbuffer}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
					\]
					  \item By \propref{prop_size_buffersent}, $|\tsent_l| = n$, but $\tsent_l$ has incremented by one his size as $n$, so that this property is hold.
						\end{itemize}
						
						

					\end{enumerate}
					
	
	\item {\bf rule \ruleName{t-pull}}. Then, $\systemterm  \arroi{\pulltran} \systemterm '$ with 
				\[\begin{array}{r@{=}l}
					\systemterm & \tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					\\
					\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm['']}]	
				  \end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \addid{\iclientinst[\tpullins][@]
						[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						[@][@][@][n][{\agssegpair[{\adelta[']}]}\cdot\inclient]}
								\ \bigpar \ \isystemterm['']\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\isystemterm \arroi{\pulltran} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\isystemterm['] & \addid{\iclientinst[P]
						 [\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}][n][\epsilon]}\ \bigpar \ \isystemterm['']	\\
					   \aseqround['] & filter\ (\geq \amxrf[_k](\cid)) \ \aseqround \\
						\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]
				  \end{array}		
				\]
				
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
						\chnote{esta oka la regla pull1? el in del cliente no entiendo porque tiene el delta y la f, para que la usas?}
					\begin{enumerate}
						\item We will inspect the terms that have changed in client $\cid$ knowing as hypothesis that $\implements{\isystemterm}{\systemterm}$.
						\begin{itemize}
							\item By \propref{prop_state_known}, $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]} \ $, however, after $\pulltran$ transition, we should build the following proof for 
						$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]} \ $
					\[
						  \mathrulean{\lemref{lemma:apply}}
						  {
							\mathrulean{\triangapply}
								{
								\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
								\quad 
								\adelta[_1] \triangleleft \queuemessage_A[\tknown_l] \ldots \adelta[_k] \triangleleft \queuemessage_A[\tknown_l + \treceivebuffer_l - 1]
								}
								{\iapply{\known}{\adelta[_1]\cdots\adelta[_k]}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}
								}
							}
  						{\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}}  
					\]
					  The last step is worth by \propref{prop_inclient}.
						\item By \propref{prop_inclient}, if $\inclient_l = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]$ then 
		$\adelta[_1] \triangleleft \queuemessage_A[\tknown_i] \ldots \adelta[_k] \triangleleft \queuemessage_A[\tknown_l + \treceivebuffer_l - 1]$. After $\pulltran$ transition, $\inclient_l$['] = $\epsilon$ and $\treceivebuffer_l$ = 0, then by 
		\triangemptydelta, this property is hold.
						\item We have to prove that $\ireduce{\adelta[_m]\cdots\adelta[_h]} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$ (PENDIENTE)
						\end{itemize}
		
				

					\end{enumerate}
	
						
					\item {\bf rule (\textsc{t-confirmed})} If $A \arroi{\confirmedtran} A'$, then by rule (\textsc{\footnotesize{t-confirmed}}), $A$ must be the following term: $ \tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclienti{\update{\tprogram}{x}{\tpending \neq \emptysequence \vee\ \ttransactionbuffer \neq \epsilon}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ \tilde{A}}{\queuemessage_A}$. As $(A,C)$ belongs $\mathcal{R}$ then $C$ must be $\clientr{\confirmedins{x}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $C$ could perform.
				Then, looking at the rule, $C' = \clientr{\update{P}{x \mapsto E.\pending = \epsilon \lor E.\pushbuffer = \epsilon \lor E.\transactionbuffer = \epsilon}{\textbf{true}}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We prove that $(A',C') \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					\begin{enumerate}
						\item Both clients has the same program $P$. By 6. we know that the value of $E.\pending \cdot E.\pushbuffer$ is related to $\tpending$, thereby, when E.$\pending$ or E.$\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\ E_{i}.\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has by property 3.
						\item to 9. Do not change.
					\end{enumerate}
					\item {\bf rule (\textsc{t-receive})} If $A \arroi{\tau} A'$, then by internal rule (\textsc{\footnotesize{t-receive}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + 1}\bigpar\ C}{\queuemessage}$. As	$(A,C)$ belongs $\mathcal{R}$ then $C$ must be $\clientr{\tprogram}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, such that after internal transitions $\tau$, it will become $C'$. By Hypothesis of (\textsc{\footnotesize{t-receive}}, we know that $\tknown + \treceivebuffer + 1 \leq \text{\textbar} S_A \text{\textbar}$, then, by Property 8., $|E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$. We will consider two cases:
						
						\begin{itemize}
							\item $|E_{i}.\inclient| > 0$, then $|E_{i}.\inclient|$ has a $GsSegment$ at least, i.e., $E.\inclient = \gs_0 \cdot \gs_t$. If $C$ took the internal rule (\textsc{\footnotesize{RECEIVE}}), we will get the following $C'$ termn, $\clientr{P}{\updatetwo{E}{\receivebuffer}{E.\receivebuffer \cdot \gs_0.gssegment)}{\inclient}{\gs_t)}}$. Now, we will check if $(A',C')$ belongs to $\mathcal{R}$.
							
							\begin{enumerate}
								\item The inputs term in read operation have not changed.
								\item It does not change.
								\item It does not change.
								\item Term $\treceivebuffer$ was incremented by 1. Then, we should prove that $E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[(j+1) - 1].delta \triangleleft \queuemessage_A[\tknown_i + (\treceivebuffer_i+1) - 1]$ is guaranteed. By Property 4., we only should prove $E_{i}.\receivebuffer[j].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i]$ allow $(A',C')$ to belong to $\mathcal{R}$. It worths by Property 7., in particular with $l$ = 1.  
								\item It does not change.
								\item It does not change.
							  \item It is easy to see such that $|\inclient'| < |\inclient|$, then we use Property 7.
								\item to 9. They do not change.
							\end{enumerate}
						\end{itemize}
					\item $|\queuemessage_C.\outserver| > 0$, then $|\queuemessage_C.\outserver|$ has a $GsSegment$ at least, i.e., $\queuemessage_C.\outserver(i)$ = $\gs \cdot \gss$. Then, by internal rule (\textsc{\footnotesize{comm-server-client}} we get $\update{\outserver}{i}{\gss}$ and $\update{E}{\inclient}{E.\inclient \cup \{\gs\}}$. Then, by internal rule (\textsc{\footnotesize{recieve}}), we get a term who has $|E_{i}.\inclient| > 0$. The rest of the prove is equivalent to above case.
						
\item {\bf rule (\textsc{t-process})} If $A \arroi{\tau} A'$, then by rule (\textsc{\footnotesize{t-process}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\tsenthead] \cdot \tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage \cdot \tsenthead}$. Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. Analyzing cases:
					
					
					
					\begin{itemize}
						\item If $\beta \ \in\ E_{i}.\outclient$ then, by rule (\textsc{\footnotesize{comm-client-server}}), $C \arroi{\tau} C'$, so that, $C'$ = $\clientr{P}{\update{E}{\outclient}{\tailround}} \bigpar\ \tilde{C} \ \bigpar\ \ \server{\state}{\update{\inserver}{i}{\headerround}}{\outserver}_C$ and $\delta_0 \triangleleft \beta$. Performing a new internal action by rule (\textsc{\footnotesize{batch}}),i.e., $C' \arroi{\tau} C''$, then $C''$ = $\server{\apply{\persistedstate}{d}}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}  \bigpar\ \tilde{C} \bigpar \clientr{P}{\stateclient}$. We have to prove that $(A',C'')$ belongs $\mathcal{R}$.
						
						\begin{enumerate}
							\item Theirs terms do not change.
							\item Our hypothesis is $\queuemessage_C.\state \triangleleft \queuemessage_A$ besides $\delta_0 \triangleleft \beta$, then using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item $\queuemessage_A$  has incremented by one, so that, by Hypothesis, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$, besides, $\Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$ because of neither $E_{i}.\inclient$ nor $\queuemessage_C.\outserver$ have changed.
\item By Hypothesis, for all element in $\tsent$, those belongs to $E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$, in particular, $\tsent$ without a element keeps these guarantee.
						\end{enumerate}
\item If $\beta \ \in\ E_{i}.\inserver$ then, applying rule (\textsc{\footnotesize{batch}}), we can see that we are at above case.
					\end{itemize}
					
\end{itemize}

\end{itemize}

We have prove that if $A$ perform an action, $C$ also can perform an action, the terms after both transitions are in $\mathcal{R}$. Now, we will prove the opposite side. When $C$ perform an action, then A can perform an action and the news terms are in $\mathcal{R}$.


\begin{itemize}
   \item{\bf n=0}. Then $C$ = $\clientr{E}{\initialstate}$ and $A$ = $\tsystem{\tclienti{0}{\emptyset}{\emptyset}{\emptyset}{\emptyset}{0}\ \bigpar\ \tilde{A}}{\queuemessage_A}$. It is analogous to the base case previously proved.
			
   \item{\bf n=k+1}. $\forall (C,A) \ \in \ \mathcal{R}$
	
			
			\begin{itemize}
				\item {\bf rule (\textsc{comm-server-client})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-server-client}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					\begin{enumerate}
						\item to 6. Their terms do not changed.
						\setcounter{enumi}{6}	
							\item $l'$ = $(|E_{i}.\inclient| + 1)$, so that, we have to prove that $E_{i}.\inclient[l'] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 + l']$, however, it easy to see because by property 10. when $m$ = 0 then $\outserver(i)[0] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient|]$.
						\item It is easy to see that $(|E_{i}.\inclient| + 1) + (|\queuemessage_C.\outserver|-1) > 0$.
						\item It does not change.
						\item It is easy to see, because, Property 10 is guaranteed with $0 \leq l$ therefore $1 \leq l$. 
					\end{enumerate}
					
					
				\item {\bf rule (\textsc{comm-client-server})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-client-server}}), $C'$ must be the following term: $\server{ps'}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}$, therefore, the client $i^{th}$ is the only one who has changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.				
					\begin{enumerate}
						\item to 8. Their terms do not changed.
						\setcounter{enumi}{8}	
						\item It is easy to see, because, we have exchanged a sequence from $\outclient$ to $\inserver$. 
						\item It does not change.
						\end{enumerate}
				


				
						\item {\bf rule (\textsc{batch})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{batch}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. Hence	$(C,A)$ belongs to $\mathcal{R}$ then $A$ after of internal transition $\tau$ is $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ S_C}{\queuemessage \cdot \tsenthead}$. We will prove that $(C',A') \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.	
				\begin{enumerate}
						\item Their terms do not change.
						\item Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. In particular, we consider $\beta \ \in \ \queuemessage_C.\inserver$, then there exists $\delta_o$ such that $\delta_0 \triangleleft \beta$, besides by Property 2., $\queuemessage_C.\state \triangleleft \queuemessage_A$, so that using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item It does not change.
							\item $\queuemessage_C.\outserver$ is updated with the new persisted state however its size does not change. By Hypothesis 9, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$.
							\item It does not change.
							\item It does not change.

						\end{enumerate}
		

				
			\end{itemize}
		\end{itemize}
		
\end{proof}
