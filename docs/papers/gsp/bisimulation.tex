% !TEX root = main.tex

\section{Equivalence}

We have introduced an abstract GSP protocol and a robust streaming server-client implementation of GSP. There exists a relation represented by $\triangleleft$ [~ref:] which relates state and delta objects to the update sequences. 

\[
\begin{array}{l@{\quad\qquad}l@{\quad\qquad}l}
  \mathax{\triangemptydelta\medskip\medskip}{\medskip\medskip\emptydelta \triangleleft \epsilon}{} 
  &
  \mathrule{\triangappend}
  		{\adelta \triangleleft \anupdseq}
		{\iappend \adelta \anupd  \triangleleft \anupdseq \cdot \tupdate}
  &
 %  \mathrule{\triangreduce}
 % 		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
 %		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
  \mathrule{\triangread}
  		{\astate \triangleleft \anupdseq}
		{\iread r \astate  = \rvalue r  \anupdseq}  
\\  
\\
  \mathax{\trianginitialstate\medskip\medskip}{\medskip\medskip\initialstate \triangleleft \epsilon}{} 
  &
  \mathrule{\triangapply}
  		{\astate \triangleleft \anupdseq \quad \adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\iapply \astate {\adelta[_1]\cdots\adelta[_n]}  \triangleleft \anupdseq \cdot\anupdseq[_1] \cdots \anupdseq[_n]}
  & 

   \mathrule{\triangreduce}
   		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
\\
%\\
%&
%\mathax{\triangapplyemp\medskip\medskip}{\medskip\medskip\iapply \astate {\emptydelta}  \triangleleft \astate}{} 
  
%&
%\mathax{\triangreduceemp\medskip\medskip}{\medskip\medskip \ireduce{\epsilon} \triangleleft \emptydelta}{} 
  
%  \mathrule{\triangread}
 % 		{\astate \triangleleft \anupdseq}
%		{\iread r \astate  = \rvalue r  \anupdseq}  

%\\
%  \multicolumn{3}{c}{\mathrule{\triangremove}
%  		{\adelta[_1] \triangleleft \anupdseq[_1]\ \ldots\ \adelta[_n] \triangleleft \anupdseq[_n]}
%		{\iremove{\adelta[_1] \cdots \adelta[_n]}{\adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_{n-1}]}  }
\end{array}
\]


\begin{lemma}\label{lemma:apply} $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ iff $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.
\end{lemma}

\begin{proof} $\Rightarrow)$ The only possible derivation for $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ is

\[
   \mathrulean{\triangapply}
  		{ \astate \triangleleft \anupdseq['] \qquad\qquad
	   		\mathrulean{\triangreduce}
   				{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
				{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}	  
		}
		{\iapply \astate {\ireduce{\adelta[_0]\cdots\adelta[_n]}}  \triangleleft  \anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]}
\]
and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.



$\Leftarrow)$ Follows analogously. 
\end{proof}


\begin{lemma}\label{lemma:reduce} $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]\cdot \adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq[']$ $\adelta[_n] \triangleleft \anupdseq['']$.
\end{lemma}

\begin{proof} $\Rightarrow)$ The only possible derivation for $\ireduce {\adelta[_1] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq$ is

\[
   \mathrulean{\triangreduce}
  					{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]\qquad\qquad
	   		\adelta[_n] \triangleleft \anupdseq[_n]  
		}
		{\ireduce {\adelta[_0] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq[_0]\cdots\anupdseq[_{n-1}] \cdot \anupdseq[_n]}	
\]
Hence, $\anupdseq['] = \anupdseq[_0]\cdots\anupdseq[_{n-1}]$ and $\anupdseq[''] = \anupdseq[_n]$. The proof is completed by using rule \ruleName{\triangreduce} on
$\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]$.

 \[  \mathrule{\triangreduce}
   		{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]}
		{\ireduce {\adelta[_0] \cdots \adelta[_{n-1}]} \triangleleft \anupdseq[_0] \cdots \anupdseq[_{n-1}]}
\]
 
%and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
%above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.

$\Leftarrow)$ Follows analogously. 
\end{proof}

\begin{lemma}\label{lemma:reducefirst} $\ireduce{\adelta[_0]\cdot\adelta[_1]\cdots\adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\adelta[_0] \triangleleft \anupdseq['], \ireduce{\adelta[_1]\cdots\adelta[_{n}]}\triangleleft \anupdseq['']$.
\end{lemma}


\begin{lemma}\label{lemma:reduceinreduce} $\ireduce{\adelta[_0]\cdots\ireduce{\adelta['_{0}]\cdots\adelta['_{m-1}]}\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$ iff $\ireduce{\adelta[_0]\cdots\adelta['_0]\cdots\adelta['_{m-1}]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$

\end{lemma}

%\begin{itemize}
%	\item On $\mathit{Delta} \times \mathit{Update}^*$, let $\triangleleft$ be the smallest relation such that (1) $\emptydelta \triangleleft []$, and
%(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates $u$, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$ and (4) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $\remove{d_1 \ldots d_{n}}{d_n} \triangleleft a_1 \cdots a_{n-1}$. \marginpar{El (4) lo agregamos nosotros. Â¿Se aclara? Â¿C\'omo?}
%  
%\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $\initialstate \triangleleft []$, and
%(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
%\end{itemize}
%
% 


\begin{lemma}\label{lemma:storechanged} Let $\adelta[_0]\cdots\adelta[_{n-1}]$ a delta sequence, such that, $\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_0] \triangleleft \anupdseq[_n]$ and the following relation $\astate \triangleleft \anupdseq$ then $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_n]$
\end{lemma}

\begin{proof} The proof follows by induction on the length of the sequence.

\begin{itemize}
   \item{\bf n=0}. It is easy to see that $\iapply{\astate}{\ireduce{\emptydelta}}\triangleleft \anupdseq$ is $\astate \triangleleft \anupdseq$.
   \item{\bf n=k+1}. Then, our inductive hypothesis is $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_k]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_k]$, we should build the following proof for 
							
						$\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_{k+1}]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_{k+1}] \ $
					\[
						  \mathrulean{\lemref{lemma:apply}}
						  {
								\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_k]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_k]
								\quad \quad 
								\anupdseq[_{k+1}]\triangleleft\anupdseq[_{k+1}] 							
							}
  						{\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_{k+1}]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_{k+1}]}  
					\]
	

\end{itemize}


\end{proof}


\begin{definition} \label{def:implementation}
Let  $\systemterm = \abstsyst[@][@][\Absclient_j]$ with $\Absclient_l={\abstcliJ[@][m]}$be a \tgspcalculus\ system and 
$\isystemterm = \concsyst $  with $\iserver = \iserverins$ and $\iclient_l = \addid{\iclientinstJ}[{\cid{_l}}]$ 
an streaming implementation
system. We say $\isystemterm$ implements $\systemterm$ if the following conditions hold for all $l \in L$,

\begin{enumerate}
	\item \label{prop_transactions} ${\transactionbuffer}_l\triangleleft{\ttransactionbuffer}_l$;
%	\item \label{prop_sent} If $\cid_l \in \dom\inserver$ and $\cid_l \in \dom\outserver$ then ${\pushbuffer}_l \ \triangleleft \ {\tsent}_t$  $\tsent_l$ = ${\tsent}_h \cdot {\tsent}_t$ and and $ \ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h$
	\item \label{prop_sent}  
	\begin{itemize}
	   \item   $\cid_l \in \dom\inserver$, $\cid_l \in \dom\outserver$ and
	 $ \ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer}_l} \triangleleft \ \flatten{{\tsent}_l}$; or
	   \item  $\cid_l \not\in\dom\inserver,  {\pushbuffer}_l \triangleleft \ \flatten{{\tsent}_l}$
	\end{itemize}

	\item \label{prop_pending} $\pending_l = \aroundtuplei[1]\ldots\aroundtuplei[h]$ and 
		$\ireduce{\adelta_1\cdots\adelta_h\cdot {\pushbuffer}_l} \triangleleft \flatten{\tpending_l}$;
	\item  \label{prop_size_buffersent} $m_l = n_l$ 
	
\item \label{prop_inclient} if $\cid_l \in \dom{\outserver}$ then:
    \begin{itemize}
   % \item  ${\inclient}_l \cdot \outserver(\cid_l)  = \agssegpair[{\astate[']}]\cdot\agssegpairi[1] \cdots \agssegpairi[h]$
    % and  
    % $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{h}]}}\triangleleft \flatten{\queuemessage} )$; or 
      \item ${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$; 
     \linebreak
      $\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$; and $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft 
       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$; or
     
     \item ${\inclient}_l = \agssegpair[{\astate[']}]\cdot\agssegpairi[{z+1}] \cdots \agssegpairi[h']$, 
              $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$,
     		$\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$,
               $\astate['] \triangleleft \ \queuemessage[0 .. t - 1]$ and $t \leq \tknown_l+\treceivebuffer_l$; 

     
     $\ireduce{\adelta_{z+1}\cdots\adelta_{h'}}\triangleleft \ \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ and 
     $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \
       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$; or
     
       
     \item ${\inclient}_l = \epsilon$, 
     $\outserver(\cid_l) = \agssegpair[{\astate[']}]\cdot\agssegpairi[z+1] \cdots \agssegpairi[h]$, 
     $\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$
      $\astate['] \triangleleft \ \queuemessage[0 .. t - 1]$ and $\tknown_l+\treceivebuffer_l \leq t$; 
     
     $\ireduce{\adelta_{z+1}\cdots\adelta_{h}}\triangleleft \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ 
     
     
    \end{itemize}



	\item \label{prop_state_known} $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]}$;
	
	\item \label{prop_stateserver} $\astate \triangleleft \flatten{\queuemessage}$.
	
	                                    
%	\item \label{prop_outserver2} $(\outserver(l) = \agssegpair[{\astate[']}]\cdot\agssegpairi \cdots \agssegpairi[h] \land \ireduce{\adelta_0\cdots\adelta_h}\triangleleft  \queuemessage[t..|\queuemessage| - 1])\ \land \ \iapply{\astate[']}{\ireduce{\adelta[_0]\cdots\adelta[_{h}]}}\triangleleft \queuemessage ) \ \lor \ $
%							    $(\outserver(l)$ = $\agssegpair[\adelta_0][{\amxrf[^{0}]}]\cdots\agssegpair[\adelta_h][{\amxrf[^{h}]}] \land \ireduce{\adelta_0\cdots\adelta_h}%\triangleleft \ \queuemessage[\tknown_l + \treceivebuffer_l \ldots  |\queuemessage| - 1]$)


	%\item \henote{eliminada}
	% $\rvalue{r}{\flatten{\queuemessage_{A}[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}}$
	%$E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i - 1]$
	%	\label {prop_inclient} if $\inclient_l = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]$ then 
	%	$\adelta[_1] \triangleleft \queuemessage_A[\tknown_i] \ldots \adelta[_k] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l - 1]$
	%\item ${\inclient}_l = \agssegpairi \cdots \agssegpairi[h]$ and $\ireduce{\adelta_0\cdots\adelta_h}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l-1]$
	% $\length{\inclient}_l = \treceivebuffer_l$ and for all $0 \leq h < \treceivebuffer_l$,  $\inclient[h] = \agssegpair$ and $\adelta\triangleleft{\queuemessage[\tknown + l]}$
	%\item $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$
%	\henote{no muy seguro}
	%\item \label{prop_outserver} For all natural $m$, such that $1 \leq m \leq |\outserver(i)|$ then $\outserver(l)[m] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l - 1 + m]$
	

\end{enumerate}
 
	
	
\end{definition}

Next theorem states one of most important result of the paper, saying that abstract GSP protocol and the implementation of GSP are weak bisimulation equivalent (or weakly bisimilar).

We use $\approx$ for standard weak bisimulation.

\begin{theorem} If  $\isystemterm$ implements $\systemterm$, then $\isystemterm\approx\systemterm$. 
\end{theorem}



\begin{proof} We show that the following relation is a weak simulation.
\[
\mathcal{R} = \{ (\isystemterm, \systemterm) \ |\ \implements{\isystemterm{}}{\systemterm} \}
\]


%Let $A$ be a system from abstract GSP Protocol, defined as  then both system are weakly bisimilar, written $A \approx C$, if $(A,C)  \in \ \mathcal{R}$, where $\mathcal{R}$ be a binary relation defined as $\{ (\parallel_{i \ \in\ I_{\{0 \ldots n\}}} A_i \parallel \ \queuemessage_A),(\parallel_{i \ \in\ I_{\{0 \ldots n\}}} C_i \parallel \ \queuemessage_C) \ | \ \forall i \ \in\ \nat, \forall r: \readtype, A_i = \ \tclient{\tprogram_i}{\tknown_i}{\tpending_i}{\ttransactionbuffer_i}{\tsent_i}{\treceivebuffer_i} \land C_i = \client{P_i}{\stateclient_i}$ and the conjunction of the following properties: %\land \ \rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}} \land \ \queuemessage_C.\state \triangleleft \queuemessage_A \land \ E_{i}.\transactionbuffer = [\ttransactionbuffer_i] \land \ E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i] - 1 \ \land \ E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \ \land \  E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i \ \land \ \forall l, 1 \leq l < |\inclient|, E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l] \ \land \ \tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0 \ \land \ \forall \beta \ \in \ \tsent_i, \beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver
%\marginpar{Ac\'Ã¡ deber\'ia decir que R cumple las propiedades de weak bisimulation. C\'omo lo escribo mejor?}


%The proof follows by induction on the length of the derivation $\arro{} ^*$.
 %We use $\tilde{A}$ and $\tilde{C}$ to denote clients, except client $i^{th}$, interacting concurrently, i.e., $\parallel_{j \ \in\ I_{\{0 \ldots n\} - i}}$ $A_j$ or $C_j$ respectively.

\begin{itemize}
   
	
   \item%{\bf n=k+1}. $\forall (\isystemterm ,\systemterm ) \ \in \ \mathcal{R}$
   
  % \henote{Para no escribir $\mathcal{R}^{-1}$ podemos cambiar la definici\'on $\mathcal{R}$}
		
			
			\begin{itemize}
%				\item {\bf rule (\textsc{t-read})}. If $\systemterm  \arroi{\readtran{r}} \systemterm '$, then by rule (\textsc{\footnotesize{t-read}}), $\systemterm $ must be the following term: 
%				$\tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				, therefore, the client $i^{th}$ is the only one who have changed. So that, $\systemterm'$ is 
%				$\tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				. As $(\systemterm,\isystemterm)$ belongs $\mathcal{R}^{-1}$ then $\isystemterm$ must be $\clientr{\readins{x}{r}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $\isystemterm$ can perform.
%				Then by rule (\textsc{read}), $\isystemterm' = \clientr{\update{P}{x}{v}}{\stateclient}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We will prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}^{-1}$ if the ten properties introduced are keeping.
\item {\bf rule \ruleName{update}}. Then, $\isystemterm  \arroi{\updatetran{u}} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	
				  \end{array}
				\]
				
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\systemterm = \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \henote{\figref{}}, 
				$\systemterm \arroi{\updatetran{u}} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
						\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  \end{array}		
				\]
				
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item[\ref{prop_transactions}.] The only terms that have changed are the transaction buffers in client $\cid$. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by \refprop{prop_transactions}. 						
						Then, $\iappend{\transactionbuffer}{u} \triangleleft \ttransactionbuffer \cdot \tupdate$ holds by
						rule \ruleName{\triangappend}.

						\end{itemize}
%						We can build the following proof for 
%						$\iappend{\transactionbuffer}{u}
%						\triangleleft 
%						\ttransactionbuffer \cdot \tupdate$
%						\[
%						  \mathrulean{\triangappend}
%						      {
%						      \transactionbuffer \triangleleft{\ttransactionbuffer}
%						      }
%  						{\iappend{\transactionbuffer}{u}]
%						\triangleleft 
%						\ttransactionbuffer \cdot \tupdate}  
%					\]

%						 \chnote{Esta prueba es m\'as inmediata, creo que aca no haria falta mostrar el detalle ya que es solo un paso. Con mencionar la regla del append tiene que alcanzar, lo dejo por si preferis que quede asi.}.

						\item[{--}] The remaining properties straightforwardly hold.
						

					\end{enumerate}


\item {\bf rule \ruleName{push}}. Then, $\isystemterm  \arroi{\pushtran} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpushins]} \ \bigpar \ \isystemterm[''] 
					\\
					\isystemterm['] & {\addid{\iclientinst[P][@][@][\ireduce{\pushbuffer\cdot \transactionbuffer}][\epsilon][@][n+1]}\ \bigpar \ \isystemterm['']}
				  \end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, \henote{completar referencia a la figura}
				
				$\systemterm \arroi{\pushtran} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot [\ttransactionbuffer]}{\emptydelta}{\tsent \cdot [\ttransactionbuffer]}{\treceivebuffer}[@][n+1]}[{\systemterm['']}]\\
				  \end{array}		
				\]
								
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item[\ref{prop_transactions}.] It  holds since $\medskip\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}.
						 
						\item[\ref{prop_sent}.] There are two cases:
						\begin{itemize}
						
						\item $\cid\in\dom\inserver$:  We need to prove that 
						\[\ireduce{\igetdeltas{\inserver(\cid)}\cdot\ireduce{\pushbuffer\cdot \transactionbuffer}} \triangleleft \ \flatten{{\tsent}\cdot[\ttransactionbuffer]}\]
						 Since $\implements{\isystemterm}{\systemterm}$, 
						 $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
						 and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
						 By $\lemref{lemma:reduce}$, $\flatten{\tsent} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
						 $\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$. 
						 Then, we can build the following proof 
						 
						 {\scriptsize
						\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {
						  \ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1] 
						  \quad
						  \mathrulean{\triangreduce}
						    	{\pushbuffer \triangleleft {\anupdseq[_2]}
								\quad
								\transactionbuffer \triangleleft \ttransactionbuffer}
  							{\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft \anupdseq[_2]\cdot\ttransactionbuffer}  
							}
							{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\ireduce{\pushbuffer\cdot \transactionbuffer}} \triangleleft \ \anupdseq[_1]\cdot(\anupdseq[_2]\cdot \ttransactionbuffer)}
						\]}

						 The proof is completed by noting that $\anupdseq[_1]\cdot(\anupdseq[_2]\cdot \ttransactionbuffer) = \flatten{{\tsent}\cdot[\ttransactionbuffer]}$.
						 \medskip
						 
%						  Then $\implements{\isystemterm}{\systemterm}$ by hypothesis. is that $\tsent$ = ${\tsent}_h \cdot {\tsent}_t $ and $ {\pushbuffer}_l\ \triangleleft \ {\tsent}_t$ 
%						 and $\ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h$. Now, $\tsent$ and $\pushbuffer$ 
%						 have changed, in particular ${\tsent}_t $ has a new block. $\inserver$ has not changed. 
%						 We should build the following proof for $\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft {\tsent}_t\cdot\ttransactionbuffer \ $.
%						\[
%						  \mathrulean{\lemref{lemma:reduce}}
%						  {\pushbuffer \triangleleft {\tsent}_t
%								\quad
%								\transactionbuffer \triangleleft \ttransactionbuffer}
%  						{\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft {\tsent}_t\cdot\ttransactionbuffer}  
%					\]
%						Then, this property holds.

						\item $\cid\notin\dom\inserver$: We need to prove that 
						\[\ireduce{\pushbuffer\cdot \transactionbuffer} \triangleleft \ \flatten{{\tsent}\cdot[\ttransactionbuffer]}\]
						 Since $\implements{\isystemterm}{\systemterm}$, 
						 $\pushbuffer \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
						 and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
						 Then, we can build the following proof 

						\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {
						  \igetdeltas{\inserver(\cid)} \triangleleft \ \anupdseq[_1] 
						  \quad
						 \transactionbuffer \triangleleft \ttransactionbuffer}
  						 {\ireduce{\pushbuffer\cdot \transactionbuffer} \triangleleft \ \anupdseq[_1]\cdot\ttransactionbuffer}
						\]
						
						The proof is completed by noting that $\anupdseq[_1] = \flatten{{\tsent}}$.

						\end{itemize}
						
						
						
						
						\item[\ref{prop_pending}.] We need to prove 
						$\ireduce{\igetdeltas{\pending}\cdot\ireduce{{\pushbuffer}\cdot \transactionbuffer}}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}$
						
						\henote{Conviene anticipar las hipothesis}
						 Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \refprop{prop_transactions};  
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \refprop{prop_pending};
						\end{itemize}
						We know that $\flatten{\tpending\cdot [\ttransactionbuffer]}$ = $\flatten{\tpending} \cdot \ttransactionbuffer$.
						 Then, we can build the following proof 
						 

					\[
					   \mathrulean{\lemref{lemma:reduceinreduce}}
					   {
						  \mathrulean{\lemref{lemma:reduce}}
						  {\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
						    \quad
						    \transactionbuffer \triangleleft \ttransactionbuffer}
  						{\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}\cdot \transactionbuffer}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
					   }
					   {\ireduce{\igetdeltas{\pending}\cdot\ireduce{{\pushbuffer}\cdot \transactionbuffer}}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
					\]
					
						
						\item[\ref{prop_size_buffersent}.] It trivially holds since in both cases the counters are incremented by one. \chnote{Esta hipotesis sospechamos que sobra.}
						\item[{--}] The remaining properties straightforwardly hold.
								
					\end{enumerate}


\item {\bf rule \ruleName{send}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient['']\ \\
					\isystemterm['] & \addid{\iclientinst[@][@][\pending \cdot \around][\emptydelta]}
		\ \bigpar \ \iserverins[{\astate[']}][@][\inserver\upd{\cid}{\inserver(\cid)\cdot\around}]
		\ \bigpar\ \iclient[''] \\
					\around & \aroundtuple[\cid][\nround][\pushbuffer]
					\end{array}
				\]
				
											
				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.			

						\begin{itemize}
						
							\item[\ref{prop_sent}.] $\around = \aroundtuple[\cid][\nround][\pushbuffer]$ and $\igetdeltas{\inserver(\cid)} = \adelta[_0] \cdots \adelta[_{n-1}]\cdot\pushbuffer$ where the $n$ first deltas belonged to $\inserver(\cid)$ before the send transition.  Furthermore, as $\implements{\isystemterm}{\systemterm}$, the following property holds $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{{\tsent}}$.
							
							Since the hypothesis of the rule states that $\cid\in\dom\inserver$, we have to prove that
							\[\ireduce{\igetdeltas{\inserver(\cid)}\cdot \emptydelta} \triangleleft \ \flatten{\tsent} \]
				
							\[
						  	\mathrulean{\lemref{lemma:reduce}}
						  	{\ireduce{\adelta[_0] \cdots \adelta[_{n-1}]\cdot\pushbuffer} \triangleleft \ {\tsent}
								\quad
								\emptydelta \triangleleft \epsilon}
  							{\ireduce{\adelta[_0] \cdots \adelta[_{n-1}]\cdot\pushbuffer\cdot\emptydelta} \triangleleft \ {\tsent}}  
							\]
							
							
							%We have moved the ${\pushbuffer}$ to $\inserver(\cid)$, leaving in the push buffer, $\emptydelta$. Furthermore, ${\tsent}_t$ is $\epsilon$. By \triangemptydelta this part of the property holds. 	
						%	We build the following proof for 
						%$\ireduce{\igetdeltas{\inserver(l)}\cdot \pushbuffer} \triangleleft \ {\tsent}_h \cdot {\tsent}_t$
						%\henote{Aca no es cualquier l, es la identidad dle cliente que se movio. Revisar con la nueva formulacion}
					%\[
					%	  \mathrulean{\lemref{lemma:reduce}}
					%	  {\ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h
					%			\quad
					%			\pushbuffer \triangleleft {\tsent}_t}
  					%	{\ireduce{\igetdeltas{\inserver(l)}\cdot \pushbuffer} \triangleleft \ {\tsent}_h \cdot {\tsent}_t}  
					%\]
					%\henote{estas usando $\delta_p$ en lugar de $\pushbuffer$, gran lio si cambiamos las macros}.
			
							\item[\ref{prop_pending}.] By hypothesis, $\pending = \aroundtuplei[0]\ldots\aroundtuplei[h]$ and  
							$\ireduce{\adelta_0\cdots\adelta_h\cdot\pushbuffer} \triangleleft \flatten{\tpending}$.
							 Since $\pending \cdot \around = \aroundtuplei[0]\ldots\aroundtuplei[h]{\aroundtuple[@][@][\pushbuffer]}$,
							\henote{aca la ultima tupla no es ni $n_p$ ni $\cid_p$ son exactamente $n$ y $\cid$} 
							we need to prove that  $\ireduce{\adelta_0\cdots\adelta_h\cdot\adelta_p\cdot\emptydelta} \triangleleft \flatten{\tpending}$. 
							It holds by using \lemref{lemma:reduce}, and the fact that $\emptydelta \triangleleft \epsilon$.
							%It is easy to see that it is the same relation that our hypothesis, since $\adelta_p$ was moved to the pending sequence. Therefore this property also holds.
						\item[{--}] The remaining properties straightforwardly hold.
							
						\end{itemize}


\item {\bf rule \ruleName{receive}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate['']] \ \bigpar\ \iclient['']
					\\
					\isystemterm['] & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient['']
					\\
					\outserver(\cid) & \aseg\cdot\aseqseg
					
				  \end{array}
				\]

				Since $\implements{\isystemterm}{\systemterm}$, the property \refprop{prop_inclient} holds. We have three cases:
				\begin{itemize}
				
					\item  ${\inclient} = \agssegpairi[1] \cdots \agssegpairi[h']$, $\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, then $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \
       \flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]}$. By \lemref{lemma:reducefirst} \ we know that $\adelta_{h'+1}\triangleleft \flatten{\queuemessage[\tknown+\treceivebuffer .. \tknown+\treceivebuffer +m - 1]}$ with $m < |\queuemessage| - \tknown- \treceivebuffer$. Hence, 
       
     				\[\systemterm = \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. As $\tknown+ \treceivebuffer + m < |\queuemessage|$ then by inspection of rules in \henote{\figref{}}, 
				$\systemterm \arroi{\tau}\cdots\arroi{\tau} \systemterm[']$ with $m$ internal transitions. Then,
				\[\begin{array}{r@{=}l}
						\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+m}}[{\systemterm['']}]	
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{itemize}
				
					\item[\ref{prop_inclient}.] ${\inclient} = \agssegpairi[1] \cdots \agssegpairi[h']\cdot\agssegpairi[{h'+1}]$ and $\outserver(\cid) = \agssegpairi[h'+2] \cdots \agssegpairi[h]$. We prove that
					\[\ireduce{\adelta_1\cdots\adelta_{h'+1}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]}\]
					By $\lemref{lemma:reduce}$, $\flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
						$\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$ with
						$\anupdseq[_1] = \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}$,
						$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
						 Then, we can build the following proof 
						 
						\[
						  \mathrulean{\lemref{lemma:reduce}}
						       {\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \anupdseq[_1]
							\quad
							\adelta_{h'+1} \triangleleft \anupdseq[_2]}
  						       {\ireduce{\adelta_1\cdots\adelta_{h'+1}}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]}  
						\]
					It remains to prove that
					\[\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \flatten{\queuemessage[\tknown+\treceivebuffer+m..|\queuemessage| - 1]}\]
					
					
					
					By $\lemref{lemma:reducefirst}$, $\flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]$ and 
					$\adelta_{h'+1} \triangleleft \anupdseq[_1]$, with 
					$\anupdseq[_1] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
					$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}$,
					Then, we can build the following proof 
						 
					\[
						  \mathrulean{\lemref{lemma:reducefirst}}
						       {\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]
							\quad
							\adelta_{h'+1} \triangleleft \anupdseq[_1]}
  						       {\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \anupdseq[_2]}  
					\]
					
			%		\flatten{ \queuemessage[\tknown+\treceivebuffer..m-1]}$. Then,

					
						\item[{--}] The remaining properties straightforwardly hold.
							
					\end{itemize}	
					
					
				\item ${\inclient} = \agssegpair[{\astate[']}]\cdot\agssegpairi[{z+1}] \cdots \agssegpairi[h']$, 
              				  $\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, the case follows analogously to the previous case.
     		%$\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$,
               %$\astate['] \triangleleft \queuemessage[0 .. t - 1]$ and $t \leq \tknown_l+\treceivebuffer_l$; 


					
					\item  ${\inclient} = \epsilon$, 
     					          $\outserver(\cid) = \agssegpair[{\astate[']}]\cdot\agssegpairi[z+1] \cdots \agssegpairi[h]$, 
     						   $\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$
      						   $\astate['] \triangleleft \queuemessage[0 .. l - 1]$ and $\tknown+\treceivebuffer \leq l$;  
					then $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{h}]}}\triangleleft \flatten{\queuemessage}$. 
					Since $\astate['] = \iapply{\initialstate}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$, then $\astate[']\triangleleft \queuemessage[0..l-1]$ with $r = l - \tknown - \treceivebuffer$, besides $r \leq l < |\queuemessage|$.  Hence,
				
				\[\systemterm = \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. As $\tknown+ \treceivebuffer + r < |\queuemessage|$ then by inspection of rules in 				\henote{\figref{}}, 
				$\systemterm \arroi{\tau}\cdots\arroi{\tau} \systemterm^{r}$ with $r$ internal transitions. Then,
				\[\begin{array}{r@{=}l}
						\systemterm^{r} & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+r}}[{\systemterm['']}]	
				  \end{array}		
				\]
				
				Furthermore,
				$\systemterm^{r} \arroi{\tau} \ldots\ \arroi{\tau} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + r + m}}[{\systemterm['']}] \\
				  \end{array}		
				\]


				$m$ represents the amount of internal transition that performed by client $\cid$ to reach $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$. Hence, $m =  |\queuemessage| - l - 1$ which always is $< |\queuemessage|$.   


								
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{itemize}	
	
					\item[\ref{prop_inclient}.] It easy to see because the segment from $\outserver(\cid)$ was moved to $\inclient$ holdings the hypothesis.
					
					
					\item[{--}] The remaining properties straightforwardly hold.
							
				\end{itemize}	
	
					
							
				\end{itemize}
% \item ${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$; 
 %    \linebreak
  %    $\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft  \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1])$; and $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft 
   %    \queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1])$

				
%				\chnote{Si bien es obvio, lo pregunto. No estamos poniendo como hipotesis que i pertenece al outserver. Se infiere con la hipotesis, pero no es necesario?}
%				\henote{se puede agregar, no da\~na igual las pre no se evaluan en ningun orden, uno tuviese que decir con implicaicones y queda feo}
				

%				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
%				by checking the properties in \defref{def:implementation}.			



%						\begin{itemize}
%							\item[\ref{prop_inclient}.] It is immediate that this property holds because we move a segment from $\outserver(i)$ to $\inclient(i)$.
							
							
%						\item[{--}] The remaining properties straightforwardly hold.

%						\end{itemize}
					
	
	\item {\bf rule \ruleName{pull-1}}. Then, $\isystemterm  \arroi{\pulltran} \isystemterm '$ with 
	
	\henote{ver la definicion de N, el inc}
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@]
						[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						[@][@][@][n][{\agssegpair[{\adelta[']}]}\cdot\inclient]}
								\ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P]
						 [\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}][n][\epsilon]}\ \bigpar \ \isystemterm['']	\\
					   \aseqround['] & filter\ (\geq \amxrf[_n](\cid)) \ \aseqround \\
						\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_n]}][{\amxrf[_n]}]
				  \end{array}
				\]
		
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\systemterm\arroi{\pulltran} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer  {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm[''']}]	
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				
					\begin{enumerate}
					
					\item[\ref{prop_inclient}.] $\inclient$ = $\epsilon$ and $\treceivebuffer$ = 0, hence, $\ireduce{\epsilon} = \emptydelta$ and $\flatten{\queuemessage[\tknown .. \tknown - 1]} = \epsilon$ then It holds since $\medskip\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}.
							\item[\ref{prop_state_known}.] We should build the following proof for 
						$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]} \ $with $\treceivebuffer_l = h$
					\[
						  \mathrulean{\triangapply}
						  {
							\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
							\quad 
							\ireduce{\adelta[_1]\cdots\adelta[_n]}\triangleleft \queuemessage[\tknown_l ..  \tknown_l + \treceivebuffer_l - 1]
							}
						{\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}}  
					\]
					
						\item[\ref{prop_pending}.] We have to prove that $filter\ (\geq \amxrf[_n](\cid)) \ \aseqround \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$  
						\henote{(PENDIENTE)}
		
				

					\end{enumerate}




				\item {\bf rule \ruleName{read}}. Then, $\isystemterm  \arroi{\readtran{r}} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					v & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
					\end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\systemterm \arroi{\readtran{r}} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\\
					v' &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by property \ref{prop_state_known};
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						\end{itemize}
						
						Then, we can build the following proof for 
						$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						= 
						\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						\[
						  \mathrulean{\triangread}
						    {
								  \mathrulean{\lemref{lemma:apply}}
									{
										\mathrulean{\triangapply}
										{
										\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										\quad 
										\mathrulean{\lemref{lemma:reduce}}
											{
												\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												\quad
												\transactionbuffer \triangleleft \ttransactionbuffer
											}
											{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										}
										{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									}
									{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
								}
  						  {v'  = v}  
					\]
											
						\item[{--}] The remaining properties straightforwardly hold.
						

					\end{enumerate}

\item {\bf rule \ruleName{confirm}}. Then, $\isystemterm  \arroi{\confirmedtran} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm['']	
					\\
					v & (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) 
				  \end{array}
				\]
		
		
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\systemterm \arroi{\confirmedtran} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}
		{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	\\
					v' & \eval{(\tpending \cdot  \ttransactionbuffer == \epsilon)}
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						\end{itemize}
						Then, we know that the value of $\pending \cdot \pushbuffer$ is related to $\tpending$, thereby, when $\pending$ or $\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has any elements.
			
					\end{enumerate}
	
	
	
	
	
	\item {\bf rule \ruleName{batch}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \iserverins\ \bigpar \ \iclient
					\\
					\isystemterm['] & {\iserverins[{\astate[']}][{\amxrf[{'}]}][{\inserver[']}][{\outserver[']}]}\ \bigpar \ \iclient \\
					\agssegpair[@][{\amxrf[{'}]}] &\receiveroundsname{\inserver} \\ %=\append{\emptygssegment}{rs} \qquad 
					\astate[']&\iapply{\astate}{\adelta} \\
					\forall\cid.(\outserver['] (\cid)& \outserver(\cid)\cdot\agssegpair[@][{\amxrf[{'}]}]) \\
					\forall\cid.(\inserver['](\cid) & \epsilon)
				  \end{array}
				\]
				
				

				Since $\implements{\isystemterm}{\systemterm}$, for all $\cid \in\dom{\inserver}$
				$\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
				and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
				By $\lemref{lemma:reduce}$, $\flatten{\tsent} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
				$\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$. 
			

				Then, $\sum_{\cid=1}^{m} |\anupdseq[_1]_{\cid}| = h$. Furthermore, $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_1]] \cdot [\anupdseq[_2]]}{\treceivebuffer}[1]}[]\cdots\ \bigpar \ 
		              \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_1]] \cdot [\anupdseq[_2]]}{\treceivebuffer}[m]}[\queuemessage] \]
				
				 $h$ is the amount of internal transitions performed by the system. The first one, corresponds to the first block of update from $\anupdseq[_1]$ of client 1. It is called $\tsenthead_1$. The following transitions correspond to the remaining blocks of update of $\anupdseq[_1]$ from client 1 and  $\anupdseq[_1]$ from the rest of clients.  Then, 
				 
				$\systemterm \tr{\tau}_1 \ldots\ \tr{\tau}_m \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_2]]}{\treceivebuffer}[1]}[]\cdots\ \bigpar \ 
		              \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_2]]}{\treceivebuffer}[n]}[] \queuemessage \cdot[\tsenthead_1]\cdots[\tsenthead_m]\ 
		              
				  \end{array}		
				\]

				 
			%	 In particular,  $h$ = $|\inserver|$, hence the implementation send a only delta ($\delta$), it is a reduction of segments in $\inserver$, the abstract model can send tantos bloques de updates como cantidad de segmentos usados para construir el delta.\chnote{cambiar explicacion en castellano}
				
								\henote{Ac\'a tienen que avanzar todos los clientes? esto no me cierra mucho. Ac ten\'es que hacer que  el cliente 1 abstracto haga las
				send de todos los mensajes que  están en ins(1), despues (2) y as\'i con cada uno de los clientes}
				
				We  prove that $(\isystemterm',\systemterm[']) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
			
					\begin{enumerate}
						\item[\ref{prop_sent}.] For all client $\cid$, $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{{\tsent}}$ holds. Then, $\igetdeltas{\inserver(\cid)}$ is $\emptydelta$ since $\inserver(\cid)$ = $\epsilon$ and $\anupdseq[_1]$ = $\epsilon$. It holds since $\medskip\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}. Furthermore, we know that $\pushbuffer\triangleleft\anupdseq[_2]$.  We can build the following proof
						\[ \mathrulean{\lemref{lemma:reduce}}
						  {
							\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \anupdseq[_1]
							\quad 
							\pushbuffer\triangleleft\anupdseq[_2]
							}
						{\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \anupdseq[_1]\cdot\anupdseq[_2]}  
						\]
						
					      	\item[\ref{prop_inclient}.] For all $\cid$, $\outserver(\cid)$ has a new segment $ \agssegpair[@][{\amxrf[{'}]}]$ where $\adelta\triangleleft [\tsenthead_1]\cdots[\tsenthead_m]$. 
						Using $\lemref{lemma:reduce}$ and \refprop{prop_inclient} we build the following proof for 
						$\ireduce{\adelta_1\cdots\adelta_h\cdot\adelta} \triangleleft \ {\queuemessage}\cdot [\tsenthead_1]\cdots[\tsenthead_m]$
						\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {
								\ireduce{\adelta_1\cdots\adelta_h}\triangleleft    \flatten{\queuemessage[\tknown+\treceivebuffer ..  |\queuemessage|- 1]}									\quad 
								\adelta \triangleleft  [\tsenthead_1]\cdots[\tsenthead_m]				
							}
  						{\ireduce{\adelta_1\cdots\adelta_h\cdot\adelta} \triangleleft \ \flatten{\queuemessage}\cdot [\tsenthead_1]\cdots[\tsenthead_m]}  
					\]
						\item[\ref{prop_stateserver}.] 
						
						Since $\implements{\isystemterm}{\systemterm}$, $\astate \triangleleft \flatten{\queuemessage}$ holds by \refprop{prop_stateserver}. Furthermore, $\adelta \triangleleft  [\tsenthead_1]\cdots[\tsenthead_m]$. Then, by \lemref{lemma:storechanged} we build the following proof for:
						
						\[
						  \mathrulean{\lemref{lemma:storechanged}}
						  {
							\astate \triangleleft \flatten{\queuemessage}
							\quad 
							\adelta \triangleleft  [\tsenthead_1]\cdots[\tsenthead_m]
							}
  						{\iapply{\astate}{\ireduce{\adelta}} \triangleleft \ \flatten{\queuemessage} \cdot [\tsenthead_1]\cdots[\tsenthead_m]}  
					\]
						
						\item[{--}] The remaining properties straightforwardly hold.
				\end{enumerate}

	\item {\bf rule \ruleName{pull-2}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@][\aseqround][@][@][@][@][\inclient]}
			     \ \bigpar \ \iserverins[{\astate['']}][{\amxrf[']}] \ \bigpar\ \iclient
					\\
					\isystemterm['] & \addid{\iclientinst[P]
						 [\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_m]}}]
						 [{\aseqround'}]
						 [@][@]
						 [{\receivebuffer}]}
						\ \bigpar \ \iserverins[{\astate['']}][{\amxrf[']}][\inserver\upd{\cid}{\inserver(\cid)\cdot\aseqround[']}]
						\ \bigpar\ \iclient \\
						\aseqround['] & filter\ \geq \amxrf(\cid)) \ \aseqround \\
						\inclient  &\agssegpair[{\astate[']}]\cdot\agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_z]}][{\amxrf[_z]}]
				  \end{array}
				\]
			
			
			Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\systemterm \arroi{\tau} \ldots\ \arroi{\tau} \systemterm^{h}$ with
				\[\begin{array}{r@{=}l}
					\systemterm^{h} &  \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + h}}[{\systemterm['']}] \\
				  \end{array}		
				\]
			
				
				$h$ represents the amount of internal transition that performed by client $\cid$ to reach $\astate[']$.Note that $\astate['] = \iapply{\initialstate}{\ireduce{\adelta[_1]\cdots\adelta[_{m}]}}$ and $\astate[']\triangleleft \queuemessage[0..l-1]$. Hence, $h = l - \tknown_i - \treceivebuffer_i$, besides $h \leq l < |\queuemessage|$.   
				
				Furthermore,
				$\systemterm^{h} \arroi{\tau} \ldots\ \arroi{\tau} \systemterm^{r}$ with
				\[\begin{array}{r@{=}l}
					\systemterm^{r} &  \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + h + r}}[{\systemterm['']}] \\
				  \end{array}		
				\]
				
				$r$ represents the amount of internal transition that performed by client $\cid$ to reach $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$. Hence, $r =  |\queuemessage| - l - 1$ which always is $< |\queuemessage|$.   
		
				Now by inspection of rules in \figref{}, 
				$\systemterm^{r} \arroi{\pulltran} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclienti{\tprogram}{\tknown_i+h+r}{\tpending_i \setminus \queuemessage[\tknown_i .. \tknown_i + \treceivebuffer_i + h + r {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm[''']}]	
				  \end{array}		
				\]
		
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
					\item[\ref{prop_state_known}.] We should build the following proof for 
						$\iapply{\iapply{\initialstate}{\ireduce{\adelta[_1]\cdots\adelta[_m]}}}{\ireduce{\adelta[_1]\cdots\adelta[_z]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_i +h+r- 1]} \ $
					\[
						  \mathrulean{\triangapply}
						  {
							\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_m]}} \triangleleft \flatten {\queuemessage[0..\tknown_i+\treceivebuffer_i + h -1]}
							\quad 
							\ireduce{\adelta[_1]\cdots\adelta[_z]} \triangleleft \queuemessage[\tknown_i+\treceivebuffer_i + h.. \tknown_i+\treceivebuffer_i + h + r  - 1]
															}
  						{\iapply{\iapply{\initialstate}{\ireduce{\adelta[_1]\cdots\adelta[_m]}}}{\ireduce{\adelta[_1]\cdots\adelta[_z]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_i +h+r - 1]} }  
					\]
						\item[\ref{prop_inclient}.] $\inclient'_l$ = $\epsilon$ and $\treceivebuffer_l$ = 0, then by 
		\triangemptydelta, this property is hold. \chnote{modificar regla para inclient sea epsilon}
		\henote{Esto ya está o es otra cosa?}
						\item[\ref{prop_pending}.] We have to prove that $\ireduce{\adelta[_1]\cdots\adelta[_z]} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown_i + \treceivebuffer_i + h + r -1]}$ (PENDIENTE)
		\chnote{por que ocurre lo del inserver en pull 2?}
		\henote{que se esto}
											
						\item[{--}] The remaining properties straightforwardly hold.

					\end{enumerate}
	
	
			\item {\bf rule \ruleName{accept-conn}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \server{\astate}{\inserver}{\outserver} \ \bigpar\  \iclient 	\\
					\isystemterm['] & \server{\astate}{\inserver\upd\cid\epsilon}{\update{\outserver}{\cid}{\agsprefpair}}\ \bigpar\  \iclient 
				\end{array}
				\]

				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
				
					\item[\ref{prop_inclient}.] By \propref{prop_outserver2}, when $\outserver(i)$ has a state $\astate[']$ as prefix, then $\astate = \iapply{\astate[']}{\ireduce{\adelta_1\cdots\adelta_h}}$ . In particular, there do not exists deltas in $\outserver(i)$ so that $\astate = \astate[']$. By \propref{prop_stateserver}, we know that $\astate \triangleleft \queuemessage$, hence this property holds.
											
						\item[{--}] The remaining properties straightforwardly hold.

					\end{enumerate}

			\item {\bf rule \ruleName{drop-conn}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[@][@][\aseqround][@][@][@][@][\inclient]}
								   \ \bigpar \ \server{\astate}{\inserver}{\outserver} \ \bigpar \ \iclient 	\\
					\isystemterm['] & \addid{\iclientinst[@][@][\aseqround][@][@][@][@][\epsilon]}
									\ \bigpar \server{\astate}{\inserver \setminus\cid}{\outserver \setminus\cid}\ \bigpar \ \iclient 				
					\end{array}
				\]



				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
							
						\item[{--}] Properties straightforwardly hold.

					\end{enumerate}



				%
				%\item {\bf rule \ruleName{read}}. Then, $\systemterm  \arroi{\readtran{r}} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					%\\
					%v &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  %\end{array}
				%\]
		%
				%\henote{Ac\'a es $\systemterm['']$ porque $N$ es el que estas usando}.
				%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[ \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\readtran{r}} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					%v' & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by property \ref{prop_state_known};
							%\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%
						%Then, we can build the following proof for 
						%$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						%= 
						%\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						%\[
						  %\mathrulean{\triangread}
						    %{
								  %\mathrulean{\lemref{lemma:apply}}
									%{
										%\mathrulean{\triangapply}
										%{
										%\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										%\quad 
										%\mathrulean{\lemref{lemma:reduce}}
											%{
												%\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												%\quad
												%\transactionbuffer \triangleleft \ttransactionbuffer
											%}
											%{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											%\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										%}
										%{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									%\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									%}
									%{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									%\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
								%}
  						  %{v'  = v}  
					%\]
											%
						%\item to 9 straightforwardly hold.
						%
%
					%\end{enumerate}
					%
					%
			%\item {\bf rule \ruleName{update}}. Then, $\systemterm  \arroi{\updatetran{u}} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  %\end{array}
				%\]
				%\chnote{Deberi\'amos cambiar la regla del update en la imple para que guarde updates con vertices como hacemos en abs}.
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
%
				%\[\addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\updatetran{u}} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	\\
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the transaction buffers in client $\cid$. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%
						%Then, we can build the following proof for 
						%$\iappend{\transactionbuffer}{u}
						%\triangleleft 
						%\ttransactionbuffer \cdot \tupdate$
						%\[
						  %\mathrulean{\triangappend}
						      %{
						      %\transactionbuffer \triangleleft{\ttransactionbuffer}
						      %}
  						%{\iappend{\transactionbuffer}{u}]
						%\triangleleft 
						%\ttransactionbuffer \cdot \tupdate}  
					%\]
%
						 %\chnote{Esta prueba es m\'as inmediata, creo que aca no haria falta mostrar el detalle ya que es solo un paso. Con mencionar la regla del append tiene que alcanzar, lo dejo por si preferis que quede asi.}.
%
						%\item to 9 straightforwardly hold.
						%
%
					%\end{enumerate}
	
	
			
					%
	%
	%\item {\bf rule \ruleName{pull}}. Then, $\systemterm  \arroi{\pulltran} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm['']}]	
				  %\end{array}
				%\]
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[ \addid{\iclientinst[\tpullins][@]
						%[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						%[@][@][@][n][{\agssegpair[{\adelta[']}]}\cdot\inclient]}
								%\ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\pulltran} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P]
						 %[\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}]
						 %[\aseqround']
						 %[@][@]
						 %[{\receivebuffer}][n][\epsilon]}\ \bigpar \ \isystemterm['']	\\
					   %\aseqround['] & filter\ (\geq \amxrf[_k](\cid)) \ \aseqround \\
						%\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.	
						%\chnote{esta oka la regla pull1? el in del cliente no entiendo porque tiene el delta y la f, para que la usas?}
					%\begin{enumerate}
						%\item We will inspect the terms that have changed in client $\cid$ knowing as hypothesis that $\implements{\isystemterm}{\systemterm}$.
						%\begin{itemize}
							%\item By \propref{prop_state_known}, $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]} \ $, however, after $\pulltran$ transition, we should build the following proof for 
						%$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]} \ $
					%\[
						  %\mathrulean{\lemref{lemma:apply}}
						  %{
							%\mathrulean{\triangapply}
								%{
								%\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
								%\quad 
								%\adelta[_1] \triangleleft \queuemessage_A[\tknown_l] \ldots \adelta[_k] \triangleleft \queuemessage_A[\tknown_l + \treceivebuffer_l - 1]
								%}
								%{\iapply{\known}{\adelta[_1]\cdots\adelta[_k]}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}
								%}
							%}
  						%{\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}}  
					%\]
					  %The last step is worth by \propref{prop_inclient}.
						%\item By \propref{prop_inclient}, if $\inclient_l = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]$ then 
		%$\adelta[_1] \triangleleft \queuemessage[\tknown_i] \ldots \adelta[_k] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l - 1]$. After $\pulltran$ transition, $\inclient_l$['] = $\epsilon$ and $\treceivebuffer_l$ = 0, then by 
		%\triangemptydelta, this property is hold.
						%\item We have to prove that $\ireduce{\adelta[_m]\cdots\adelta[_h]} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$ (PENDIENTE)
						%\end{itemize}
		%
				%
%
					%\end{enumerate}
	
	
	        %\item {\bf rule \ruleName{confirm}}. Then, $\systemterm  \arroi{\confirmedtran} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}
		%{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					%\\
					%v & \eval{(\tpending \cdot  \ttransactionbuffer == \epsilon)}
				  %\end{array}
				%\]
		%
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[\addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\confirmedtran} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm['']	\\
					%v' & (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) 
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%Then, we know that the value of $\pending \cdot \pushbuffer$ is related to $\tpending$, thereby, when E.$\pending$ or E.$\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has any elements.
			%
					%\end{enumerate}
				%
				%
				%\item {\bf rule \ruleName{receive}}. Then, $\systemterm  \arroi{\tau} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1}}[{\systemterm['']}]	
					%
				  %\end{array}
				%\]
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[\addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate['']] \ \bigpar\ \iclient['']\]
				%%with $\implements{\isystemterm['']}{\systemterm['']}$. 
				%by inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\tau} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient[''] \\
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
%
						%\begin{itemize}
							%\item[4.] By \propref{prop_outserver}, we know that the firt element in $\outserver(i)$ = $\queuemessage[\tknown_l+\treceivebuffer_l]$ when $m$ = 1. Now, we should build the following proof for 
							%
						%${\ireduce{\adelta_0\cdots\adelta_{h+1}}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l]} \ $
					%\[
						  %\mathrulean{\lemref{lemma:reduce}}
						  %{
								%\ireduce{\adelta_0\cdots\adelta_{h}}\triangleleft  \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l - 1]
								%\quad 
								%\adelta[_{h+1}] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l] 							
							%}
  						%{\ireduce{\adelta_0\cdots\adelta_{h+1}}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l]}  
					%\]
							%\item[9.] By \propref{prop_outserver}, we know that for all natural $m$, such that $0 \leq m \leq |\outserver(i)|$ then $\outserver(i)[m] \triangleleft \queuemessage[\tknown + \treceivebuffer - 1 + m]$. Now, $|\outserver(i)|$ was decremented by one, however, this property holds.
						%\end{itemize}
					%
				
				
				%
					%
						%
%\item {\bf rule (\textsc{t-process})} If $A \arroi{\tau} A'$, then by rule (\textsc{\footnotesize{t-process}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\tsenthead] \cdot \tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage \cdot \tsenthead}$. Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. Analyzing cases:
					%
					%
					%
					%\begin{itemize}
						%\item If $\beta \ \in\ E_{i}.\outclient$ then, by rule (\textsc{\footnotesize{comm-client-server}}), $C \arroi{\tau} C'$, so that, $C'$ = $\clientr{P}{\update{E}{\outclient}{\tailround}} \bigpar\ \tilde{C} \ \bigpar\ \ \server{\state}{\update{\inserver}{i}{\headerround}}{\outserver}_C$ and $\delta_0 \triangleleft \beta$. Performing a new internal action by rule (\textsc{\footnotesize{batch}}),i.e., $C' \arroi{\tau} C''$, then $C''$ = $\server{\apply{\persistedstate}{d}}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}  \bigpar\ \tilde{C} \bigpar \clientr{P}{\stateclient}$. We have to prove that $(A',C'')$ belongs $\mathcal{R}$.
						%
						%\begin{enumerate}
							%\item Theirs terms do not change.
							%\item Our hypothesis is $\queuemessage_C.\state \triangleleft \queuemessage_A$ besides $\delta_0 \triangleleft \beta$, then using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item $\queuemessage_A$  has incremented by one, so that, by Hypothesis, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$, besides, $\Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$ because of neither $E_{i}.\inclient$ nor $\queuemessage_C.\outserver$ have changed.
%\item By Hypothesis, for all element in $\tsent$, those belongs to $E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$, in particular, $\tsent$ without a element keeps these guarantee.
						%\end{enumerate}
%\item If $\beta \ \in\ E_{i}.\inserver$ then, applying rule (\textsc{\footnotesize{batch}}), we can see that we are at above case.
					%\end{itemize}
					
\end{itemize}

\end{itemize}
%
%We have prove that if $A$ perform an action, $C$ also can perform an action, the terms after both transitions are in $\mathcal{R}$. Now, we will prove the opposite side. When $C$ perform an action, then A can perform an action and the news terms are in $\mathcal{R}$.
%
%
%\begin{itemize}
   %\item{\bf n=0}. Then $C$ = $\clientr{E}{\initialstate}$ and $A$ = $\tsystem{\tclienti{0}{\emptyset}{\emptyset}{\emptyset}{\emptyset}{0}\ \bigpar\ \tilde{A}}{\queuemessage_A}$. It is analogous to the base case previously proved.
			%
   %\item{\bf n=k+1}. $\forall (C,A) \ \in \ \mathcal{R}$
	%
			%
			%\begin{itemize}
				%\item {\bf rule (\textsc{comm-server-client})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-server-client}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		%\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					%\begin{enumerate}
						%\item to 6. Their terms do not changed.
						%\setcounter{enumi}{6}	
							%\item $l'$ = $(|E_{i}.\inclient| + 1)$, so that, we have to prove that $E_{i}.\inclient[l'] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 + l']$, however, it easy to see because by property 10. when $m$ = 0 then $\outserver(i)[0] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient|]$.
						%\item It is easy to see that $(|E_{i}.\inclient| + 1) + (|\queuemessage_C.\outserver|-1) > 0$.
						%\item It does not change.
						%\item It is easy to see, because, Property 10 is guaranteed with $0 \leq l$ therefore $1 \leq l$. 
					%\end{enumerate}
					%
					%
				%\item {\bf rule (\textsc{comm-client-server})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-client-server}}), $C'$ must be the following term: $\server{ps'}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}$, therefore, the client $i^{th}$ is the only one who has changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.				
					%\begin{enumerate}
						%\item to 8. Their terms do not changed.
						%\setcounter{enumi}{8}	
						%\item It is easy to see, because, we have exchanged a sequence from $\outclient$ to $\inserver$. 
						%\item It does not change.
						%\end{enumerate}
				%
%
%
				%
						%\item {\bf rule (\textsc{batch})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{batch}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		%\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. Hence	$(C,A)$ belongs to $\mathcal{R}$ then $A$ after of internal transition $\tau$ is $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ S_C}{\queuemessage \cdot \tsenthead}$. We will prove that $(C',A') \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.	
				%\begin{enumerate}
						%\item Their terms do not change.
						%\item Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. In particular, we consider $\beta \ \in \ \queuemessage_C.\inserver$, then there exists $\delta_o$ such that $\delta_0 \triangleleft \beta$, besides by Property 2., $\queuemessage_C.\state \triangleleft \queuemessage_A$, so that using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item $\queuemessage_C.\outserver$ is updated with the new persisted state however its size does not change. By Hypothesis 9, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$.
							%\item It does not change.
							%\item It does not change.
%
						%\end{enumerate}
		%
%
				%
			%\end{itemize}
		%\end{itemize}
		
\end{proof}
