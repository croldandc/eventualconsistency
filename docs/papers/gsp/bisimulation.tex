% !TEX root = main.tex

\section{Correctness of implementation}
\label{sec:simulation}

We now prove that  \igsp\ is a correct implementation 
of \gsp. We recall in \figref{fig:coherence-operation} the requirements for the
operations provided by the  types 
\statetype\ and \deltatype\ stated in~\cite{}. 
These requirements are formalised by the relation $\_\triangleleft \_$, which associates 
 delta and state objects with sequences of updates: $\adelta\triangleleft\anupdseq$
 (similarly, $\astate\triangleleft\anupdseq$)  means  that $\delta$ (correspondingly, $\astate$) 
 is a compact representation of $\anupdseq$. Then, it is also assume that 
$\astate\triangleleft\anupdseq$ implies  $\iread \aread \astate  = \rvalue \aread  \anupdseq$ for any $\aread$.

\begin{figure}[t]
{\small
\[
\begin{array}{l@{\quad\qquad}l@{\quad\qquad}l}
  \mathax{\triangemptydelta\medskip\medskip}{\medskip\medskip\emptydelta \triangleleft \epsilon}{} 
  &
  \mathrule{\triangappend}
  		{\adelta \triangleleft \anupdseq}
		{\iappend \adelta \anupd  \triangleleft \anupdseq \cdot \tupdate}
  &
 %  \mathrule{\triangreduce}
 % 		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
 %		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
  \mathrule{\triangread}
  		{\astate \triangleleft \anupdseq}
		{\iread r \astate  = \rvalue r  \anupdseq}  
\\  
\\
  \mathax{\trianginitialstate\medskip\medskip}{\medskip\medskip\initialstate \triangleleft \epsilon}{} 
  &
  \mathrule{\triangapply}
  		{\astate \triangleleft \anupdseq \quad \adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\iapply \astate {\adelta[_1]\cdots\adelta[_n]}  \triangleleft \anupdseq \cdot\anupdseq[_1] \cdots \anupdseq[_n]}
  & 

   \mathrule{\triangreduce}
   		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
\\
%\\
%&
%\mathax{\triangapplyemp\medskip\medskip}{\medskip\medskip\iapply \astate {\emptydelta}  \triangleleft \astate}{} 
  
%&
%\mathax{\triangreduceemp\medskip\medskip}{\medskip\medskip \ireduce{\epsilon} \triangleleft \emptydelta}{} 
  
%  \mathrule{\triangread}
 % 		{\astate \triangleleft \anupdseq}
%		{\iread r \astate  = \rvalue r  \anupdseq}  

%\\
%  \multicolumn{3}{c}{\mathrule{\triangremove}
%  		{\adelta[_1] \triangleleft \anupdseq[_1]\ \ldots\ \adelta[_n] \triangleleft \anupdseq[_n]}
%		{\iremove{\adelta[_1] \cdots \adelta[_n]}{\adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_{n-1}]}  }
\end{array}
\]
}
\caption{Coherence requirements for $\deltatype$ and $\statetype$ operators}
\label{fig:coherence-operation}
\end{figure}

%\begin{itemize}
%	\item On $\mathit{Delta} \times \mathit{Update}^*$, let $\triangleleft$ be the smallest relation such that (1) $\emptydelta \triangleleft []$, and
%(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates $u$, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$ and (4) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $\remove{d_1 \ldots d_{n}}{d_n} \triangleleft a_1 \cdots a_{n-1}$. \marginpar{El (4) lo agregamos nosotros. ¿Se aclara? ¿C\'omo?}
%  
%\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $\initialstate \triangleleft []$, and
%(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
%\end{itemize}
%
% 


\begin{definition} \label{def:implementation}
Let  $\systemterm = \abstsyst[@][@][\Absclient_j]$ be a \tgspcalculus\ system
 such that $\Absclient_l={\abstcliJ[@][m]}$ for all
$l\in\{0,\ldots,m\}$, and  $\isystemterm = \concsyst$  a \igsp\  system such that  $\iserver = \iserverins$ and $\iclient_l = \addid{\iclientinstJ}[{\cid{_l}}]$.
 We say {\em $\isystemterm$ implements $\systemterm$} if the following conditions hold:


\newpage

\begin{enumerate}
	\item \label{prop_transactions} ${\transactionbuffer}_l\triangleleft{\ttransactionbuffer}_l$.
%	\item \label{prop_sent} If $\cid_l \in \dom\inserver$ and $\cid_l \in \dom\outserver$ then ${\pushbuffer}_l \ \triangleleft \ {\tsent}_t$  $\tsent_l$ = ${\tsent}_h \cdot {\tsent}_t$ and and $ \ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h$
	\item \label{prop_sent}  
%	\begin{itemize}
%	   \item   
	   
	   if $\cid_l \in \dom\inserver$%, $\cid_l \in \dom\outserver$ 
	   then 
	 $ \ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer}_l} \triangleleft \ \flatten{{\tsent}_l}$. 
	 
	 Otherwise,
	     %($\cid_l \not\in\dom\inserver$), 
	      ${\pushbuffer}_l \triangleleft \ \flatten{{\tsent}_l}$.
			\henote{esto no vale: si partis con un sistema en donde vale la anterior y hay un drop, no vale ni la anterior ni esta}

%	\end{itemize}
%	\item \label{prop_sent}  
%	\begin{itemize}
%	   \item   $\cid_l \in \dom\inserver$%, $\cid_l \in \dom\outserver$ 
%	   and
%	 $ \ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer}_l} \triangleleft \ \flatten{{\tsent}_l}$; or
%	   \item  $\cid_l \not\in\dom\inserver,  {\pushbuffer}_l \triangleleft \ \flatten{{\tsent}_l}$
%			\henote{esto no vale}
%
%	\end{itemize}
%	

	\item \label{prop_pending} $\pending_l = \aroundtuplei[1]\ldots\aroundtuplei[h]$ and 
		$\ireduce{\adelta_1\cdots\adelta_h\cdot {\pushbuffer}_l} \triangleleft \flatten{\tpending_l}$.
	\item  \label{prop_size_buffersent} $m_l = n_l$ 
	
\item \label{prop_inclient} if $\cid_l \in \dom{\outserver}$ then either
    \begin{itemize}
   % \item  ${\inclient}_l \cdot \outserver(\cid_l)  = \agssegpair[{\astate[']}]\cdot\agssegpairi[1] \cdots \agssegpairi[h]$
    % and  
    % $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{h}]}}\triangleleft \flatten{\queuemessage} )$; or 
     \item ${\inclient}_l \cdot \outserver(\cid_l)  = \epsilon$, $\tknown_l = |\queuemessage|$ and $\treceivebuffer_l =0$;

     \item ${\inclient}_l \cdot \outserver(\cid_l)  = \agsprefpair[{\adelta[']}]\cdot\aseqseg$,
      $\ireduce{\igetdeltas{{\inclient}_l}}\triangleleft \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$,  and
      $\ireduce{\igetdeltas{\outserver(\cid_l)}}\triangleleft 
       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$,
  
%      \item ${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, 
%      
%      	      $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 
%	      
%	      
%
%     
%      $\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$, 
%      
%      $\ireduce{\adelta_h'+1\cdots\adelta_h}\triangleleft 
%       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$,
%           
     \item ${\inclient}_l = \agssegpair[{\astate[']}][{\amxrf[_0]}]\cdot\agssegpairi[1] \cdots \agssegpairi[h']$, 
     
      there exists $t \leq \tknown_l+\treceivebuffer_l$ s.t. $\astate['] \triangleleft \ \queuemessage[0 .. t - 1]$, 
      
              $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$,
              
     		$\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$,
                and 

     
     $\ireduce{\adelta_{z+1}\cdots\adelta_{h'}}\triangleleft \ \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ and 
     $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \
       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$; or
     
       
     \item ${\inclient}_l = \epsilon$, 
     $\outserver(\cid_l) = \agssegpair[{\astate[']}]\cdot\agssegpairi[z+1] \cdots \agssegpairi[h]$, 
     $\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$
      $\astate['] \triangleleft \ \queuemessage[0 .. t - 1]$ and $\tknown_l+\treceivebuffer_l \leq t$; 
     
     $\ireduce{\adelta_{z+1}\cdots\adelta_{h}}\triangleleft \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ 
     
	
	\end{itemize}	
	
        \item \label{prop_deltas} for all $\agssegpair\in\inclient_l\cdot\outserver(\cid_l)$, 
          \begin{itemize}
          	\item $\amxrf(\cid_l)\leq\irounds_l$,
		\item  for all $\aroundtuple[@][@][\adelta'] \in\pending_l$
        if $\irounds\leq\amxrf(\cid_l)$ then $\adelta\triangleleft \flatten{\queuemessage[x..x']}$ and  $\flatten{\adelta'\triangleleft \queuemessage[y..y']}$
        with $y'\leq x'$
	\end{itemize}
	\item \label{prop_state_known} $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]}$;
	
	\item \label{prop_stateserver} $\astate \triangleleft \flatten{\queuemessage}$.

\end{enumerate}



	
	
\end{definition}

Next theorem states one of most important result of the paper, saying that abstract GSP protocol and the implementation of GSP are weak bisimulation equivalent (or weakly bisimilar).

We use $\approx$ for standard weak bisimulation.

\begin{theorem}
\label{thm:simulation}
 If  $\isystemterm$ implements $\systemterm$, then $\isystemterm\approx\systemterm$. 
\end{theorem}


