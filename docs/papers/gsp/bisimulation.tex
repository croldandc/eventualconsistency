% !TEX root = main.tex

\section{Correctness of the Implementation}
\label{sec:simulation}

We now prove that  \igsp\ is a correctimplementation 
of \gsp. We recall in \figref{fig:coherence-operation} the requirements for the
operations provided by the  types 
\statetype\ and \deltatype\ stated in~\cite{}. 
These requirements are formalised by the relation $\_\triangleleft \_$, which associates 
 delta and state objects with sequences of updates: $\adelta\triangleleft\anupdseq$
 (similarly, $\astate\triangleleft\anupdseq$)  means  that $\delta$ (correspondingly, $\astate$) 
 is a compact representation of $\anupdseq$. Then, it is also assumed that 
$\astate\triangleleft\anupdseq$ implies  $\iread \aread \astate  = \rvalue \aread  \anupdseq$ for any $\aread$.
Building on the above relation, the next definition states when a
\igsp\ system its an implementation of a \gsp\ system.

\begin{figure}[t]
{\small
\[
\begin{array}{l@{\quad\qquad}l@{\quad\qquad}l}
  \mathax{\triangemptydelta\ \ }{\ \ \emptydelta \triangleleft \epsilon}{} 
  &
  \mathrule{\triangappend}
  		{\adelta \triangleleft \anupdseq}
		{\iappend \adelta \anupd  \triangleleft \anupdseq \cdot \tupdate}
  &
 %  \mathrule{\triangreduce}
 % 		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
 %		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
  \mathrule{\triangread}
  		{\astate \triangleleft \anupdseq}
		{\iread r \astate  = \rvalue r  \anupdseq}  
\\
  \mathax{\trianginitialstate\ \ }{\ \ \initialstate \triangleleft \epsilon}{} 
  &
  \mathrule{\triangapply}
  		{\astate \triangleleft \anupdseq \quad \adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\iapply \astate {\adelta[_1]\cdots\adelta[_n]}  \triangleleft \anupdseq \cdot\anupdseq[_1] \cdots \anupdseq[_n]}
  & 

   \mathrule{\triangreduce}
   		{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
		{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}
%\\
%&
%\mathax{\triangapplyemp\ \ }{\ \ \iapply \astate {\emptydelta}  \triangleleft \astate}{} 
  
%&
%\mathax{\triangreduceemp\ \ }{\ \  \ireduce{\epsilon} \triangleleft \emptydelta}{} 
  
%  \mathrule{\triangread}
 % 		{\astate \triangleleft \anupdseq}
%		{\iread r \astate  = \rvalue r  \anupdseq}  

%\\
%  \multicolumn{3}{c}{\mathrule{\triangremove}
%  		{\adelta[_1] \triangleleft \anupdseq[_1]\ \ldots\ \adelta[_n] \triangleleft \anupdseq[_n]}
%		{\iremove{\adelta[_1] \cdots \adelta[_n]}{\adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_{n-1}]}  }
\end{array}
\]
}
\caption{Coherence requirements for $\deltatype$ and $\statetype$ operators}
\label{fig:coherence-operation}
\end{figure}

%\begin{itemize}
%	\item On $\mathit{Delta} \times \mathit{Update}^*$, let $\triangleleft$ be the smallest relation such that (1) $\emptydelta \triangleleft []$, and
%(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates $u$, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$ and (4) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $\remove{d_1 \ldots d_{n}}{d_n} \triangleleft a_1 \cdots a_{n-1}$. \marginpar{El (4) lo agregamos nosotros. ¿Se aclara? ¿C\'omo?}
%  
%\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $\initialstate \triangleleft []$, and
%(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
%\end{itemize}
%
% 


\begin{definition} \label{def:implementation}
Let  $\systemterm = \abstsyst[@][@][\Absclient_j]$ be a \tgspcalculus\ system
 such that $\Absclient_l={\abstcliJ[@][m]}$ for all
$l\in\{0,\ldots,m\}$, and  $\isystemterm = \concsyst$  a \igsp\  system such that  $\iserver = \iserverins$ and $\iclient_l = \addid{\iclientinstJ}[{\cid{_l}}]$.
 We say {\em $\isystemterm$ implements $\systemterm$} if the following conditions hold:


\newpage

\begin{enumerate}
	\item \label{prop_stateserver} $\astate \triangleleft \flatten{\queuemessage}$;

	\item \label{prop_state_known} $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]}$;
	
	\item \label{prop_transactions} ${\transactionbuffer}_l\triangleleft{\ttransactionbuffer}_l$;
	
	\item \label{prop_pending}  
		$\ireduce{\igetdeltas{\pending_l}\cdot {\pushbuffer}_l} \triangleleft \flatten{\tpending_l}$;

%		\item \label{prop_pending} $\pending_l = \aroundtuplei[1]\ldots\aroundtuplei[h]$ and 
%		$\ireduce{\adelta_1\cdots\adelta_h\cdot {\pushbuffer}_l} \triangleleft \flatten{\tpending_l}$.

%	\item \label{prop_sent} If $\cid_l \in \dom\inserver$ and $\cid_l \in \dom\outserver$ then ${\pushbuffer}_l \ \triangleleft \ {\tsent}_t$  $\tsent_l$ = ${\tsent}_h \cdot {\tsent}_t$ and and $ \ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h$
	\item \label{prop_sent}  
%	\begin{itemize}
%	   \item   
	   
	   if $\cid_l \in \dom\inserver$ and $\inclient \cdot\outserver(\cid_l) \neq \agssegpair[{\astate[']}][{\amxrf}]\cdot\aseqseg$ %, $\cid_l \in \dom\outserver$ 
	   then 
	   
	   $ \ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer}_l} \triangleleft \ \flatten{{\tsent}_l}$. 
	 
%	 Otherwise,
%	     %($\cid_l \not\in\dom\inserver$), 
%	      ${\pushbuffer}_l \triangleleft \ \flatten{{\tsent}_l}$.
%			\henote{esto no vale: si partis con un sistema en donde vale la anterior y hay un drop, no vale ni la anterior ni esta}

%	\end{itemize}
%	\item \label{prop_sent}  
%	\begin{itemize}
%	   \item   $\cid_l \in \dom\inserver$%, $\cid_l \in \dom\outserver$ 
%	   and
%	 $ \ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer}_l} \triangleleft \ \flatten{{\tsent}_l}$; or
%	   \item  $\cid_l \not\in\dom\inserver,  {\pushbuffer}_l \triangleleft \ \flatten{{\tsent}_l}$
%			\henote{esto no vale}
%
%	\end{itemize}
%	


%	\item  \label{prop_size_buffersent} $m_l = n_l$ 
	
\item \label{prop_inclient} if $\cid_l \in \dom{\outserver}$ then either
    \begin{itemize}
   % \item  ${\inclient}_l \cdot \outserver(\cid_l)  = \agssegpair[{\astate[']}]\cdot\agssegpairi[1] \cdots \agssegpairi[h]$
    % and  
    % $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{h}]}}\triangleleft \flatten{\queuemessage} )$; or 
     \item ${\inclient}_l \cdot \outserver(\cid_l)  = \epsilon$, $\tknown_l = |\queuemessage|$ and $\treceivebuffer_l =0$;

     \item ${\inclient}_l = \agsprefpair[{\adelta[']}]\cdot\aseqseg$,
      $\ireduce{\igetdeltas{{\inclient}_l}}\triangleleft \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$,  and
      
      
      $\ireduce{\igetdeltas{\outserver(\cid_l)}}\triangleleft 
       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$,
  
%      \item ${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, 
%      
%      	      $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 
%	      
%	      
%
%     
%      $\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$, 
%      
%      $\ireduce{\adelta_h'+1\cdots\adelta_h}\triangleleft 
%       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$,
%           
     \item ${\inclient}_l = \agssegpair[{\astate[']}][{\amxrf[_0]}]\cdot\aseqseg$,      
  		 there exists $t \leq \tknown_l+\treceivebuffer_l$ s.t. $\astate['] \triangleleft \ \flatten{\queuemessage[0 .. t - 1]}$, 


     
     $\ireduce{\igetdeltas{\aseqseg}}\triangleleft \ \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ and 
     
     $\ireduce{\igetdeltas{\outserver(\cid_l) }}\triangleleft \
       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$; or
      
 %             $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$,
%              
%     		$\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$,
                 

%     
%     $\ireduce{\adelta_{z+1}\cdots\adelta_{h'}}\triangleleft \ \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ and 
%     $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \
%       \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$; or
     
       
     \item ${\inclient}_l = \epsilon$,  $\outserver(\cid_l) = \agssegpair[{\astate[']}]\cdot \aseqseg$ there exists $t \geq \tknown_l+\treceivebuffer_l $ s.t.
%     $\outserver(\cid_l) = \agssegpair[{\astate[']}]\cdot\agssegpairi[z+1] \cdots \agssegpairi[h]$, 
 %    $\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$
      $\astate['] \triangleleft \ \flatten{\queuemessage[0 .. t - 1]}$ %and $\tknown_l+\treceivebuffer_l \leq t$; 
     
       $\ireduce{\igetdeltas{\aseqseg}}\triangleleft \ \flatten{ \queuemessage[t..|\queuemessage| - 1]}$  
%   $\ireduce{\adelta_{z+1}\cdots\adelta_{h}}\triangleleft \flatten{ \queuemessage[t..\tknown_l+\treceivebuffer_l-1]}$ 
     
	
	\end{itemize}	
	
        \item \label{prop_deltas} for all $\agssegpair\in\inclient_l\cdot\outserver(\cid_l)$, 
          \begin{itemize}
          	\item $\amxrf(\cid_l)\leq\irounds_l$,
		\item  for all $\aroundtuple[@][@][\adelta'] \in\pending_l$
        if $\irounds\leq\amxrf(\cid_l)$ then $\adelta\triangleleft \flatten{\queuemessage[x..x']}$ and  $\flatten{\adelta'\triangleleft \queuemessage[y..y']}$
        with $y'\leq x'$
	\end{itemize}

\end{enumerate}
	
\end{definition}


The  first three conditions are self-explanatory. Condition (\ref{prop_pending})  ..\henote{Terminar cuando est\'e confirmado}

We  now show that \igsp\ is a correct implementation of \gsp\ by proving that all behaviours of $\isystemterm$  are allowed by $\systemterm$ 
whenever $\isystemterm$  implements $\systemterm$. Technically,  we prove that $\systemterm$ weakly simulates $\isystemterm$. 
 We rely on a standard notion of simulation but technically we take into account the fact that
the \gsp\ associates a fresh event identifier to each update while \igsp\ does not. Take  $\rightarrow = \tr{\tau} \bigcup_{\cid\in\idset} \arroi{\tau}$,
 $\Arro$ as the transitive closure of $\rightarrow$, \ie, $\Arro = \rightarrow^*$ and 
 $\Arroi{\lambda} \ = \ \Arro;\arroi{\lambda};\Arro$.
 
 

\begin{definition}[simulation] $\mathcal{R}$ is an {\em implementation simulation} if for all 
$(\isystemterm,\systemterm)\in\mathcal{R}$ we have:
\begin{enumerate}
   \item If $\isystemterm\arro{\updatetran{\anupd}}\isystemterm[']$ then  $\exists\systemterm['],\vertice[w]$ s.t.  $\systemterm\Arroi{\updatetranaux{\anupd^{\vertice[w][]}}}\systemterm[']$ and $(\isystemterm['],\systemterm['])\in\mathcal{R}$;
   \item If $\isystemterm\arro{\lambda}\isystemterm[']$ and $\lambda\neq \updatetran{\anupd},\tau$ then  $\exists\systemterm[']$  s.t.  $\systemterm\Arroi{\lambda}\systemterm[']$ and $(\isystemterm['],\systemterm['])\in\mathcal{R}$;
   \item If $\isystemterm\tr{}\isystemterm[']$  then  $\exists\systemterm[']$  s.t.  $\systemterm\Arro\systemterm[']$ and $(\isystemterm['],\systemterm['])\in\mathcal{R}$;
\end{enumerate} 
\end{definition}

As usual, we write $\isystemterm\precsim\systemterm$ if there exists an {simulation} $\mathcal{R}$ s.t.  
$(\isystemterm,\systemterm)\in\mathcal{R}$.

%
%Next theorem states one of most important result of the paper, saying that abstract GSP protocol and the implementation of GSP are weak bisimulation equivalent (or weakly bisimilar).
%
%We use $\approx$ for standard weak bisimulation.

\begin{theorem}
\label{thm:simulation}
 If  $\isystemterm$ implements $\systemterm$, then $\isystemterm\precsim\systemterm$. 
\end{theorem}

\begin{proof}
It follows by showing that $\mathcal{R} = \{ (\isystemterm, \systemterm) \ |\ \implements{\isystemterm{}}{\systemterm} \}$ is an 
implementation simulation.
\end{proof}

We remark that  $\mathcal{R}^{-1}$ is not a simulation. Essentially,  the implementation cannot mimic  the 
behaviour of the idealised model when a client  have performed two 
consecutive \pushcmd\ commands without sending the first block: in \gsp\, the global store is still able to interleave the two 
blocks with blocks arriving from other clients. Differently, the two blocks are treated as atomic in \igsp\  
because the client will send them as part of the same $\delta$ object. 