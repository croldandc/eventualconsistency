\newcommand{\ancho}{ p{\textwidth} <}

%\newcommand{\powerset}{\mathcal{P}_f}
%\newcommand{\compatible}{compatible}
%\newcommand{\compatibility}{compatibility}

%\newcommand{\bn}{\mathop{\mathrm{bn}}}
%\newcommand{\initial}{\mathop{I}}
%\newcommand{\fn}{\mathop{\mathrm{fn}}}
%\newcommand{\struct}{\equiv}
%%\newcommand{\rec}[2]{\mathsf{rec}\;{#1}.{#2}}
%\newcommand{\sep}{\;\;\mid\;\;}
%\newcommand{\locpar}{|}
%\newcommand{\install}[1]{\mathsf{install}[{#1}]}
%\newcommand{\sedef}{\Rightarrow}
%\newcommand{\merg}[2]{\mathsf{merge}^{#1}\ {#2}}
%\newcommand{\invoke}[1]{\mathsf{invoke}\ {#1}}

%LTS
\newcommandx{\action}[1][1={}]{\lambda{#1}}
\newcommandx{\actbyc}[1][1={}]{\mu{#1}}

\newcommand{\tr}[1]{\xrightarrow[]{#1}}

\newcommandx{\arro}[2][2=\cid]{\xrightarrow[]{#1}_{#2}}
\newcommand{\arroi}[1]{\arro{#1}}
\newcommand{\arrobyclient}[2]{\arro{#1}[#2]}



\newcommandx{\Arroaux}[2][2=\cid]{\xRightarrow[]{#1}_{#2}}

\newcommand{\Arroi}[1]{\Arroaux{#1}}
\newcommand{\Arrobyclient}[2]{\Arroaux{#1}[#2]}

\newcommand{\auxarro}[1]{\xmapsto{#1}}

%\newcommand{\typearro}[1]{\stackrel{#1}{\mapsto}}
%\newcommand{\labdef}[1]{\top #1}
%\newcommand{\session}{\rhd}
%\newcommand{\labinv}[1]{\bot #1}
%\newcommand{\labmerg}[2]{#1^{#2}}
\newcommand{\deduce}[2]{\frac{\displaystyle #1}{\displaystyle #2}}
\def \mathax #1#2{\begin{array}{l} {\mbox{\scriptsize {{\sc (#1)}}} } \\ #2
\end{array}}

\newcommand{\irule}[2]{\frac{\textstyle\rule[-1.3ex]{0cm}{3ex}#1}%
{\textstyle\rule[-.5ex]{0cm}{3ex}#2}}
%
\def \mathrule #1#2#3{\begin{array}{l}%
      {\mbox{\scriptsize {\ruleName{#1}}} }
    \\ \irule{#2}{#3}%
\end{array}}

%\def \mathrule #1#2#3{\begin{array}{l}
%        {\mbox{\scriptsize {\ruleName{#1}}} }
%        \\ \deduce{#2}{#3}
%\end{array}}

\def \mathrulean #1#2#3{\begin{array}{l}
        {\mbox{\scriptsize {\ruleName{#1}}} }
        \ \deduce{#2}{#3}
\end{array}}

\def \mathaxlean #1#2{\begin{array}{l}
        {\mbox{\scriptsize {\ruleName{#1}}} }
        \  {#2}
\end{array}}


\def \mathanrule #1#2{\begin{array}{l}
				\deduce{#1}{#2}
\end{array}}

\def \mathaxiom #1#2{\begin{array}{l}%
    {\mbox{\scriptsize ({\sc #1})} }%
    \\ \iaxiom{#2}%
    \end{array}}
\newcommand{\iaxiom}[1]{\textstyle\rule[-1.3ex]{0cm}{3ex}#1}
        
\newcommand{\ruleName}[1]{{\sc (#1)}}
      
\newcommand{\rName}[1]{\mbox{\scriptsize {\ruleName{#1}}} }


%\newcommand{\equal}[2]{#1 \stackrel{\cdot}{=} #2}
%\newcommand{\n}{\mathop{\mathrm{n}}}
%\newcommand{\muse}{$\mu\mathsf{se}$}
%\newcommand{\var}{{\mathcal A}}
%\newcommand{\varb}{{\mathcal B}}
%\newcommand{\subst}[2]{\{#1 / #2\}}
%\newcommand{\judge}[4]{#1\vdash #4:\{{#2}\,\nearrow\,{#3}\}}
%\newcommand{\judges}[3]{#1\vdash #3 :\{#2 \}}
%\newcommand{\compliance}{\thickapprox}

%\newcommand{\topfigrule}{\vskip2pt\noindent\rule{\textwidth}{1pt}}
%\newcommand{\olds}[1]{\oldstylenums{#1}}
%\newcommand{\oldsb}[1]{{\bfseries\olds{#1}}}
%\newif{\ifcomments}
%\commentsfalse \ifcomments
%\newcommand{\comment}[1]{\stepcounter{ncomm}%
%\vbox to0pt{\vss\llap{\tiny\oldsb{\arabic{ncomm}}}\vskip6pt}%
%\marginpar{\tiny\bf\raggedright%
%{\oldsb{\arabic{ncomm}}}.\hskip0.5em#1}}
%\newcounter{ncomm}
%\else
%\newcommand{\comment}[1]{}
%\fi
%\newcommand{\marginnote}[2]{\hrule\smallskip\textbf{#1}:{\sf #2}\smallskip\hrule}
%\newcommand{\rest}[1]{(\nu #1)}
%\newcommand{\pinull}{\mathbf{0}}
%\newcommand{\typenull}{\mathsf{0}}
%\newcommand{\subt}{\; \mbox{{{\tt <}} \hspace{-.29cm} \raisebox{.25ex}{\tt :}}\,}
%\newcommand{\bigfract}[2]{\frac{^{\textstyle #1}}{_{\textstyle #2}}}
%\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}}
%
%\newcommand{\wsdl}{{\sc wsdl}}
%\newcommand{\lredm}[1]{\stackrel{#1}{\longmapsto}}
%
%
%\newcommand{\bla}{\fbox{bla, bla, bla...}}
%\newcommand{\replace}[2]{{\fbox{#2}}\marginpar{$\star\star$}}
%\newcommand{\replace}[2]{{#2}}


%
% MACRO FOR COMMENTS
%
%\newcommand{\nota}[1]{\noindent \fbox{ \parbox{\textwidth}{#1} }  }
\newcommand{\nota}[1]{}

%
% ABBREVIATIONS AND SYMBOLS
%
\newcommand{\eg}{e.g.}
\newcommand{\ie}{i.e.}
\newcommand{\wrt}{w.r.t.}
\newcommand{\tdot}{..}

\newcommand{\dom}[1]{\textit{dom}(#1)}

\newcommand{\igsp}{\textcolor{red}{\sc igsp}}

\newcommand{\gsp}{\textcolor{red}{\sc gsp}}
\newcommand{\tgspcalculus}{{\sc gsp}}
\newcommand{\gspcalculus}{\textit{gsp-calculus}}

% SEQUENCES

\newcommand{\emptysequence}{\textcolor{OliveGreen}{\epsilon}}


%%%%SYNTAX GSP

\newcommandx{\Absclient}[1][1={}]{\textcolor{OliveGreen}{C{#1}}}
\newcommand{\queuemessage}{\textcolor{OliveGreen}{S}}
\newcommandx{\systemterm}[1][1={}]{\textcolor{OliveGreen}{N{#1}}}

\newcommand{\Absserver}{\textcolor{OliveGreen}{C}}


%sets 
\newcommand{\idset}{\textcolor{blue}{\mathcal{I}}}

\newcommand{\verticesets}{\textcolor{blue}{\mathbb{V}}}
\newcommand{\updatesets}{\textcolor{blue}{\mathcal{U}}}
\newcommand{\readset}{\textcolor{blue}{\mathcal{R}}}
\newcommand{\varset}{\textcolor{blue}{\mathcal{X}}}
\newcommand{\valueset}{\textcolor{blue}{\mathcal{V}}}
\newcommand{\opset}{\textcolor{blue}{\mathcal{O} }}
\newcommandx{\cid}[1][1={}]{\textcolor{blue}{{\sf i#1}}}
\newcommand{\cidj}{\textcolor{blue}{{\sf j}}}

\newcommand{\relrestriccion}[1]{\downarrow_{#1}}

\newcommand{\bigpar}{|\!|}
\newcommandx{\tsystem}[2][2=\systemterm]{#1\ \bigpar\ #2}

% Clients configuration
\newcommandx{\tclient}[8][7=\cid,8=\trounds,usedefault=@]{\langle #1 , #4, #5, #3,  #2, #6, #8\, \rangle_{#7}}
\newcommandx{\tclienti}[8][7=\cid,8=\trounds,usedefault=@]{{\tclient{#1}{#2}{#3}{#4}{#5}{#6}[#7][{#8}]}}

\newcommandx{\anabstcli}[7][1=\cid,2=\tprogram,3=\tknown,4=\tpending,5=\ttransactionbuffer,6=\tsent,7=\treceivebuffer,usedefault=@]
  {\tclient {#2_{#1}}{#3_{#1}}{#4_{#1}}{#5_{#1}}{#6_{#1}}{#7_{#1}}[#1]}
\newcommandx{\anabstcliprime}[7][1=\cid,2=\tprogram',3=\tknown',4=\tpending',5=\ttransactionbuffer',6=\tsent',7=\treceivebuffer']
  {\tclient {#2_{#1}}{#3_{#1}}{#4_{#1}}{#5_{#1}}{#6_{#1}}{#7_{#1}}[#1]}

\newcommand{\tknown}{\textcolor{OliveGreen}{k}}

\newcommandx{\anupd}[1][1={}]{\textcolor{OliveGreen}{{u#1}}}
\newcommandx{\aread}[1][1={}]{\textcolor{OliveGreen}{{r#1}}}

\newcommandx{\anupdseq}[1][1={}]{\textcolor{OliveGreen}{\mathsf{u#1}}}

\newcommandx{\ttransactionbuffer}[1][1={}]{\anupdseq[_{\sf T}#1]}
\newcommandx{\ublock}[2][1=\ttransactionbuffer,2=\cid]{\textcolor{Gray}{[#1]}}


\newcommandx{\blockseq}[1][1={}]{\textcolor{OliveGreen}{\mathsf{b#1}}}

\newcommandx{\tpending}[1][1={}]{\textcolor{OliveGreen}{\blockseq[_P]}}
\newcommand{\tsent}{\blockseq[_S]}
\newcommand{\tsenthead}[1][]{\textcolor{Gray}{[\ttransactionbuffer[']#1]}}

\newcommand{\treceivebuffer}{\textcolor{OliveGreen}{j}}

\newcommand{\trounds}{\textcolor{OliveGreen}{n}}

%%%%Syntax of processes
\newcommandx{\updcmd}[1][1=\anupd]{{\tt update}(#1)}
\newcommandx{\readcmd}[1][1= r]{{\tt read}(#1)}
\newcommand{\pullcmd}{{\tt pull}}
\newcommand{\pushcmd}{{\tt push}}
\newcommand{\confcmd}{{\tt confirmed}}



\newcommand{\tupdate}{\udec}

\newcommand{\tupdins}{\updcmd}
\newcommand{\tupdateins}{\tupdins;P}

\newcommandx{\treadins}[3][3=P]{{\tt let}\ #1 = {\tt read}(#2)\ {\tt in}\ #3}

%\newcommand{\treadins}[2]{{\tt let}\ #1 = {\tt read}(#2)\ {\tt in}\ P}
\newcommand{\tpushins}{{\tt push};P}
\newcommandx{\tconfirmedins}[2][2=P]{{\tt let}\ #1 = {\tt confirmed} \ {\tt in}\ #2}
\newcommand{\tpullins}{{\tt pull};P}

\newcommand{\cond}{\textcolor{OliveGreen}{{e}}}
\newcommand{\eval}[2]{#1\downarrow #2}

%\newcommandx{\pwhile}[3][3=P]{{\tt while} (#1)\ {\tt do}\ #2 \ {\tt od}; #3}
\newcommandx{\pwhile}[3][3=P]{{\tt while}\ #1\  \{ #2\};  #3}

\newcommandx{\pifte}[4][1=\cond,2=P,3=P,4=P]{{\tt if} (#1)\ {\tt then}\ #2 \ {\tt else}\ #3 \ {\tt fi}; #4}

\newcommand{\treceivetran}{{\tt receive}}

\newcommand{\plet}[3]{{\tt let}\ #1 = #2 \ {\tt in}\ #3}


\newcommand{\environmentterm}{\mathbb{A}}

\newcommand{\nat}{\textcolor{blue}{\mathbbm{N}}}

%Operational Semantics

\newcommand{\subst}[2]{\{#2/{#1}\}}

%Labels

\newcommandx{\udec}[2][1=\anupd,2=\vertice,usedefault=@]{\textcolor{OliveGreen}{#1\!^{\scalebox{.8}{$#2$}}}}
\newcommandx{\vertice}[2][1=v, 2={},usedefault=@]{\textcolor{OliveGreen}{\mathbbmss{#1}{#2}}}
\newcommand{\readtran}[1]{\textcolor{OliveGreen}{\textit{rd}(#1)}}
\newcommand{\readtranaux}[1]{\textcolor{OliveGreen}{\textit{rd}(#1)}}
%\newcommand{\receive}{\textcolor{red}{\textit{receive}}}
\newcommand{\pulltran}{\textcolor{OliveGreen}{\textit{pull}}}

\newcommand{\confirmedtran}{\textcolor{OliveGreen}{\textit{cfm}}}
\newcommand{\pushtran}{\textcolor{OliveGreen}{\textit{push}}}
\newcommandx{\updatetran}[2][2=\vertice]{\textcolor{OliveGreen}{\textit{wr}(\udec[{#1}][#2])}}
\newcommand{\updatetranaux}[1]{\textcolor{OliveGreen}{\textit{wr}(#1)}}

%\newcommand{\processtran}{\textit{process}}



%
% SERVER AND CLIENT
%

%IMPLEMENTATION DATA TYPES
\newcommand{\statetype}{{State}}
\newcommand{\deltatype}{{Delta}}


%\newcommand{\initialstate}{\textcolor{Orange}{\textit{initialstate}}}
\newcommand{\initialstate}{\textcolor{Orange}{\emptyset}}

%\newcommand{\emptydelta}{\textcolor{Orange}{\textit{emptydelta}}}
\newcommand{\emptydelta}{\textcolor{Orange}{\delta_\emptyset}}

\newcommand{\ireadname}{\textcolor{orange}{\textit{read}}}
\newcommand{\iread}[2]{\textcolor{orange}{\ireadname(#1,#2)}}

\newcommand{\iapplyname}{\textcolor{orange}{\textit{apply}}}
\newcommand{\iapply}[2]{\textcolor{orange}{\iapplyname(#1,#2)}}

\newcommand{\ireducename}{\textcolor{orange}{\textit{reduce}}}
\newcommand{\ireduce}[1]{\textcolor{orange}{\ireducename(#1)}}

\newcommand{\iappendname}{\textcolor{orange}{\textit{append}}}
\newcommand{\iappend}[2]{\textcolor{orange}{\iappendname(#1,#2)}}


\newcommand{\iremovename}{\textcolor{red}{\textit{remove}}}
\newcommand{\iremove}[2]{\textcolor{red}{\iremovename(#1,#2)}}

%%%%GS SOMETHING
\newcommandx{\astate}[2][1={},2=s,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}
\newcommandx{\adelta}[2][1={},2=\delta,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}
%\newcommandx{\adeltaseq}[2][1={},2=d,usedefault=@]{\textcolor{Brown}{\mathbbm{#2#1}}}
\newcommand{\nodelta}{\emptysequence}
\newcommandx{\amxrf}[2][1={},2=f,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}


\newcommandx{\adeltaorstate}[2][1={},2=x,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}

\newcommandx{\agspref}[2][1={},2=gsp,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}
\newcommandx{\agsprefpair}[2][1=\astate,2=\amxrf,usedefault=@]{
		\textcolor{Brown}{{\langle#1,#2\rangle}}}


\newcommandx{\agsseg}[2][1={},2=gss,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}
\newcommandx{\agssegpair}[2][1=\adelta,2=\amxrf,usedefault=@]{
		\textcolor{Brown}{{\langle#1,#2\rangle}}}

\newcommandx{\agssegpairi}[1][1=0]{\agssegpair[\adelta_{#1}][\amxrf_{#1}]}

\newcommandx{\aseg}[2][1={},2=seg,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}
\newcommandx{\aseqseg}[2][1={},2=seg,usedefault=@]{\textcolor{Brown}{\mathbbm{#2#1}}}

\newcommandx{\around}[2][1={},2=r,usedefault=@]{\textcolor{Brown}{\mathtt{#2#1}}}
\newcommandx{\aseqround}[2][1={},2=r,usedefault=@]{\textcolor{Brown}{\mathbbm{#2#1}}}
\newcommandx{\aroundtuple}[3][1=\cid,2=n,3=\adelta,usedefault=@]{
		\textcolor{Brown}{{\langle#1,#2,{#3}\rangle}}}

\newcommandx{\aroundtuplei}[1][1=i]{\aroundtuple[\cid_{#1}][n_{#1}][\adelta_{#1}]}
%$\newcommand{\igetdeltas}[1]{\textcolor{orange}{\textit{getdeltas}(#1)}}
\newcommand{\igetdeltas}[1]{\textcolor{orange}{\Delta(#1)}}


%\newcommand{\pendingtype}{\rho}
\newcommandx{\pendingtype}[1][1={},usedefault=@]{\textcolor{Brown}{\aseqround{#1}}}

%

%\newcommand{\server}[3]{\langle #1 , #2, #3\rangle}
\newcommandx{\server}[4][4=\amxrf]{\langle #1, #4,  #2, #3\rangle}

%\newcommand{\persistedstate}{\textit{ps}}
\newcommand{\persistedstate}{\agsseg}

%\newcommand{\transactionbuffertype}{\delta}
\newcommand{\transactionbuffertype}{\adelta}

%\newcommand{\pushbuffertype}{\delta}
\newcommand{\pushbuffertype}{\adelta}

%\newcommand{\receivebuffertype}{\gssegmenttype \cup \gsprefixtype}
\newcommand{\receivebuffertype}{\aseqseg}

\newcommandx{\inqueue}[1][1={}]{\textcolor{Brown}{\mathtt{in#1}}}
\newcommandx{\outqueue}[1][1={}]{\textcolor{Brown}{\mathtt{out#1}}}

\newcommandx{\inserver}[1][1={}]{\inqueue[_s{#1}]}
\newcommandx{\outserver}[1][1={}]{\outqueue[_s{#1}]}
%\newcommand{\inclient}{\inqueue[_c]}
\newcommand{\inclient}{\inqueue[_c]}

\newcommand{\outclient}{\outqueue[_c]}


\newcommand{\outclientlist}{\textit{\headerround} \cdot \textit{\tailround}}

\newcommand{\nroundtype}{\mathbb{N}}




\newcommandx{\isystemterm}[1][1={}]{\textcolor{Brown}{\mathtt{N{#1}}}}
\newcommandx{\iserver}[1][1={}]{\textcolor{Brown}{\mathtt{S{#1}}}}
\newcommandx{\iclient}[1][1={}]{\textcolor{Brown}{\mathtt{C{#1}}}}

\newcommandx{\clientr}[3][3=\cid]{\client{#1}{#2}_{#3}}
\newcommand{\client}[2]{\langle#1 , #2\rangle}

\newcommand{\irounds}{\textcolor{Brown}{n}}

\newcommandx{\iclientsyntax}[9]
	[1=P,2=\astate,3={\pendingtype},4=\pushbuffertype,5=\transactionbuffertype,
			6=\receivebuffertype,7=\irounds,8=\aseqseg,9=\outclient,usedefault=@]
	{
   	\langle #1,#2,#5,#4,#7,#3,#8\rangle
	%al cambiar esta, hay que cambiar la de abajo.
	}

\newcommandx{\iclientinst}[9]
	[1=P,2=\astate,3={\pending},4=\pushbuffer,5=\transactionbuffer,
			6=\receivebuffer,7=\irounds,8=\inclient,9=\outclient,usedefault=@]
	{
   	\langle #1,#2,#5,#4,#7,#3,#8\rangle
%   	\langle #1,#2,#3,#4,#5,#6,#7,#8,#9\rangle
	}
%\newcommandx{\iclientinst}[9]
%	[1=\_,2=\_,3=\_,4=\_,5=\_,
%			6=\_,7=\_,8=\_,9=\_,usedefault=@]
%	{
%   	\langle #1,#2,#3,#4,#5,#6,#7,#8,#9\rangle
%	}
\newcommandx{\iclientinstJ}{
	\iclientinst[P_l][\astate_l][{\pending}_l][{\pushbuffer}_l][{\transactionbuffer}_l][\receivebuffer_l][\irounds_l][\inclient_l][\outclient_l]}

\newcommandx{\iserverins}[4][1=\astate,2=\amxrf,3=\inserver, 4= \outserver,usedefault=@] {\langle #1,#2,#3,#4\rangle}

\newcommandx{\addid}[2][2=\cid]{#1_{#2}}

%\newcommand{\clienti}[9]{\langle#1 , #2, #3, #4, #5, #6, #7, #8\rangle_#9}

%\newcommand{\known}{\textit{k}}
\newcommand{\known}{\astate}

\newcommand{\pending}{\aseqround}
\newcommand{\transactionbuffer}{\textcolor{Brown}{\adelta_{\sf T}}}
\newcommand{\pushbuffer}{\textcolor{Brown}{\adelta_{\sf P}}}
\newcommand{\receivebuffer}{\aseqseg}


\newcommand{\state}{\textit{ps}}
\newcommand{\stateclient}{E}


%\newcommand{\updatetype}{\textit{Update}}
\newcommand{\updatetype}{\updatesets}
\newcommand{\readtype}{\readset}
%\newcommand{\readtype}{\textit{Read}}
%\newcommand{\valuetype}{\textit{Value}}
\newcommand{\valuetype}{\valueset}



\newcommand{\knowntype}{\statetype}

\newcommand{\rvaluename}{\textcolor{Orange}{\textit{rvalue}}}

\newcommand{\rvalue}[2]{\textcolor{Orange}{\rvaluename(#1, #2)}}
\newcommand{\maxround}{\textit{mr}}
\newcommand{\append}[2]{append(#1, #2)}
\newcommand{\apply}[2]{apply(#1, #2)}
\newcommand{\remove}[2]{remove(#1, #2)}

\newcommand{\gs}{\textit{gs}}
\newcommand{\gss}{\textit{gss}}
\newcommand{\gssegment}{\textless	\delta,\maxround \textgreater}
\newcommand{\emptygssegment}{\theta}
\newcommand{\gsprefix}{\textless	\state,\maxround \textgreater}
\newcommand{\round}[3]{\textless	#1, #2, #3 \textgreater}

\newcommand{\specfunction}[4]{#1 :: #2 $\times$ #3 $\rightarrow$ #4}
\newcommand{\specOperator}[4]{#1 :: #2 $\times$ #3  $\times$ #4}

\newcommand{\specfunctiononeparameter}[3]{#1 :: #2 $\rightarrow$ #3}
\newcommand{\specfunctionforparameters}[6]{#1 :: #2 $\times$ #3 $\times$ #4 $\times$ #5 $\rightarrow$ #6}
\newcommand{\specfunctionthreeparameters}[5]{#1 :: #2 $\times$ #3 $\times$ #4 $\rightarrow$ #5}

\newcommand{\cleannamefun}{\textbf{\textit{clean}}}


\newcommand{\gssegmenttype}{\textit{GSSegment}}
\newcommand{\gsprefixtype}{\textit{GSPrefix}}
\newcommand{\roundtype}{\textit{Round}}
\newcommand{\headerround}{\textless	i, n_0, \delta_0\textgreater}

\newcommand{\tailround}{\textit{rs}}

\newcommand{\partialfunction}[2]{#1 \rightarrow #2}
\newcommand{\appf}[2]{#1(#2)}

\newcommand{\reduce}[1]{\textbf{\textit{reduce}}(#1)}
\newcommand{\applyplus}[2]{\textbf{\textit{apply}}(#1, #2)}

\newcommand{\readplus}[2]{\readp{#1}{#2} = \textit{v}}

\newcommand{\readp}[2]{\textbf{\textit{read}}(#1, #2)}

\newcommand{\appendplus}[2]{\textbf{\textit{append}}(#1, #2)}

\newcommand{\reducestate}[2]{\textbf{\textit{reducestate}}(#1, #2)}


\newcommand{\gsprefixins}[2]{\textless #1, #2\textgreater}
\newcommand{\gssegmentins}[2]{\textless #1, #2\textgreater}


\newcommand{\updatevtran}[2]{\textit{update}(#1^#2)}
\newcommand{\syncupdtran}[1]{\textit{sync\_update}(#1)}

\newcommand{\updatebyclient}[1]{\textit{update}(u)_#1}
\newcommand{\readbyclient}[1]{\textit{read}(r)_#1}

\newcommand{\sendtran}{\textit{send}}
\newcommand{\dropconn}[1]{\dagger(#1)}
\newcommand{\dropconnectionclient}{\dagger}
\newcommand{\tprogram}{P}
\newcommand{\tflush}{\textit{flush()}}
\newcommand{\tsyncupd}[1]{\textit{sync\_update(#1)}}

\newcommand{\acceptconn}[1]{\oplus(#1)}
\newcommand{\crashandrecover}{\ddagger}
\newcommand{\undefined}{\perp}
\newcommand{\receiveroundsname}[1]{\textit{rnds}(#1)}
\newcommand{\notify}[3]{\textit{notify}(#1, #2, #3)}
\newcommand{\clean}[2]{\textit{\cleannamefun}(#1, #2)}
\newcommand{\sclean}[1]{\textit{\cleannamefun}(#1)}
\newcommand{\filter}[2]{\textit{filter}(#1,#2)}


\newcommand{\asoc}[2]{#1 \mapsto #2}
\newcommand{\upd}[2]{[\asoc{#1}{#2}]}

\newcommand{\updatein}[2]{#1^#2}
\newcommand{\update}[3]{#1\upd{#2}{#3}}
\newcommand{\updatethree}[7]{#1[#2 \mapsto #3; #4 \mapsto #5; #6 \mapsto #7]}
\newcommand{\updatetwo}[5]{#1[#2 \mapsto #3; #4 \mapsto #5]}
\newcommand{\updatefour}[9]{#1[#2 \mapsto #3; #4 \mapsto #5; #6 \mapsto #7; #8 \mapsto #9]}


\newcommandx{\updev}[2][1=u,2=v,usedefault=@]{\textcolor{blue}{#1^{#2}}}


\newcommand{\readins}[2]{\treadins}





\newcommand{\updateins}[1]{\textit{update}(#1);P}
\newcommand{\pushins}{\textit{push}();P}
\newcommand{\pullins}{\textit{pull}();P}
\newcommand{\curstate}[4]{\textit{curstate}(#1, #2, #3, #4)}
\newcommand{\nround}{\textit{n}}
\newcommand{\confirmedins}[1]{\textit{let}\ #1 = \textit{confirmed}();P}
\newcommand{\domround}{\mathcal{N} \times \mathbb{N} \times \deltatype}
\newcommand{\dominserver}{\mathbb{N} \times \deltatype}




\newcommand{\tuple}[1]{\vec{#1}}
\newcommand{\zero} {0}
\newcommand{\outp}[2]{\overline{#1}\langle #2 \rangle}
\newcommand{\inp}[2]{#1(#2)}
\newcommand{\ifte}[3]{{\bf if}\ #1\ {\bf then}\ #2\ {\bf else}\ #3}
\newcommand{\rec}[2]{{\bf rec}_{#1}\ #2}

\newcommand{\corrinst}[2]{#1\triangleright[#2]}

\newcommand{\service}[4]{#1_{#2}\{#3\ ,\ #4\}}



\newcommand{\denote}[1]{\llbracket #1\rrbracket}

 \newcommand{\unexcplbl}[1]{[#1]}
 \newcommand{\unexcp}{\circledast 	}

 \newcommand{\mayhandle}[2]{#1\downarrow_{#2}}
 \newcommand{\maynothandle}[2]{#1\not\downarrow_{#2}}

\newcommand{\Arro}{\Rightarrow}



\newcommand{\condition}[2]{\neg(\eval{#1})=#2}
\newcommandx{\updopentx}[2][1=\vertice]{{\nabla}_{#1}(#2)}
\newcommandx{\instanceset}{V}

%CONSISTENCY GRAMMAR

\newcommandx{\environment}[6][6=\sse]{\langle #1 , #2, #6,  #3, #4, #5\rangle}
\newcommand{\environmenttran}[8]{\{#1 , #2, #3, #4, #5, #6, #7, #8\}}

\newcommand{\vis}{\textsc{\scriptsize{VIS}}}
\newcommand{\op}{\textsc{\scriptsize{OP}}}
\newcommand{\arb}{\textsc{\scriptsize{AR}}}
\newcommand{\so}{\textsc{\scriptsize{SO}}}
\newcommand{\sse}{\textsc{\scriptsize{SS}}}


\newcommand{\soby}[2]{#1\triangleright_i{#2}}
\newcommand{\updateinqueuemessage}[2]{\queuemessage[#1]_#2}
\newcommand{\rb}{\textsc{\scriptsize{RB}}}
\newcommand{\tx}{\textsc{\scriptsize{TO}}}
\newcommand{\tc}{\textsc{\scriptsize{TC}}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% COMMENTS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cf}[2]{
    \fontsize{#1}{#1}{\selectfont{#2}}
  }

\newcommand{\hernan}[1]{{\marginpar{\cf{6}{{HM: #1}}}}}
%\newcommand{\emi}[1]{{\marginpar{\cf{6}{{#1}}}}}
%  \newcommand{\cf}[2]{
%    \fontsize{#1}{#1}{\selectfont{#2}}
%  }
%\newcommand{\emic}[2]{\shadowbox{\fbox{\parbox{.8\textwidth}{\begin{description}\item[\cf{8}{\sc\bf #2}]\cf{8}{#1}\end{description}}}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Para Borrar
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ignorar}[1]{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type system
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\type}{\mathcal{T}}
\newcommand{\patternmtch}{\owedge}
\newcommand{\tjudge}[4]{#1 \vdash #2 : {#3} ,#4}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%c%%%%%%%%%%
% Cross-ref
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\equref}[1]{Eq.~\eqref{#1}}
\newcommand{\thmref}[1]{Thm.~\ref{#1}}
\newcommand{\lemref}[1]{Lem.~\ref{#1}}
\newcommand{\figref}[1]{Fig.~\ref{#1}}
\newcommand{\defref}[1]{Def.~\ref{#1}}
\newcommand{\secref}[1]{\S~\ref{#1}}
\newcommand{\exref}[1]{Ex.~\ref{#1}}
\newcommand{\propref}[1]{Prop.~\ref{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% comments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\changed}[2]{\textcolor{blue}{#2}}
\newcommand{\henote}[1]{\textcolor{red}{[H: #1]}}
\newcommand{\chnote}[1]{\textcolor{green}{[C: #1]}}

%\newcommand{\flatten}[1]{\textcolor{Orange}{\textit{flatten}(#1)}}
\newcommand{\flatten}[1]{\textcolor{Orange}{\underline{#1}}}

\newcommand{\length}[1]{|#1|}

\newcommandx{\iupdatetran}[2][2=\vertice]{\textcolor{OliveGreen}{\textit{wr}(\udec[{#1}])}}


%%%%%
% Section 3
%%%%
\newcommand{\paralelo}[4]{\parallel_{#1\in #2} {#3} \parallel \ #4}

%\newcommandx{\abstsyst}[4][1=l,2=L,3=\Absclient_j, 4=\queuemessage,usedefault=@]{\paralelo{#1}{#2}{#3}{#4}}

\newcommandx{\abstsyst}[4][1=l,2=L,3=\Absclient_j, 4=\queuemessage,usedefault=@]{\Absclient_0\ \bigpar \ldots\bigpar\  \Absclient_m\ \bigpar\ \queuemessage}


\newcommandx{\abstcliJ}[2][1=l,2=n,usedefault=@]{\tclienti{\tprogram_{#1}}{\tknown_{#1}}{\tpending_{#1}}{\ttransactionbuffer_{#1}}{\tsent_{#1}}{\treceivebuffer_{#1}}[{\cid_{#1}}][{#2}_{#1}]}


%\newcommandx{\concsyst}[4][1=l,2=L,3={\iclient_l},4=\iserver,usedefault=@]{\paralelo{#1}{#2}{#3}{#4}}
\newcommandx{\concsyst}[4][1=l,2=L,3=\Absclient_j, 4=\queuemessage,usedefault=@]{\iclient_0\ \bigpar \ldots\bigpar\  \iclient_m\ \bigpar\ \iserver}



%labels inferencia triangulitos
\newcommand{\triangemptydelta}{$\triangleleft\emptydelta$}
\newcommand{\triangappend}{$\triangleleft\iappendname$}
\newcommand{\triangreduce}{$\triangleleft$-\ireducename}
\newcommand{\triangremove}{$\triangleleft$-\iremovename}

\newcommand{\trianginitialstate}{$\triangleleft-\initialstate$}
\newcommand{\triangapply}{$\triangleleft$-\iapplyname}
\newcommand{\triangread}{$\triangleleft$-\ireadname}

\newcommand{\triangreduceemp}{$\triangleleft$-\ireducename-$\emptydelta$}
\newcommand{\triangapplyemp}{$\triangleleft$-\iapplyname-$\emptysequence$}


\newcommand{\implements}[2]{{#1}\ \mathit{ implements}	\ {#2}}
%volver


%SECTION 4
\newcommand{\rest}[1]{\!\!\downarrow_{#1}}
\newcommand{\restRel}[3]{#1\rest{#2\times#3}}
\newcommand{\restUR}[1]{\restRel{#1}{\mathbb{U}}{\mathbb{R}}}
\newcommand{\restUO}[1]{\restRel{#1}{\mathbb{U}}{\mathbb{O}}}
\newcommand{\restRO}[1]{\restRel{#1}{\mathbb{R}}{\mathbb{O}}}
\newcommand{\restUU}[1]{\restRel{#1}{\mathbb{U}}{\mathbb{U}}}
\newcommand{\restOU}[1]{\restRel{#1}{\mathbb{O}}{\mathbb{U}}}


%Section 5
\newcommandx{\syncupdcmd}[1][1=\anupd]{{\tt syncUpd}(#1)}



\newcommand{\waitcmd}{{\tt wait}}

\newcommandx{\tsyncupdins}[2][1=\anupd,2=\tprogram,usedefault=@]{\syncupdcmd[#1];#2}
\newcommandx{\ttrans}[2][1=\tprogram,2=\tprogram,usedefault=@]{[#1];#2}

\newcommandx{\tguarded}[3][1=e,2=\tprogram,3=\tprogram,usedefault=@]{#1\triangleright(#2);#3}



\newcommand{\startsynctran}{\dagger}
\newcommand{\finishsynctran}{\dagger}


\newcommandx{\tupdlbl}[2][1=\anupd,2=\vertice,usedefault=@]{*\textit{wr}(\udec[{#1}][#2])}


\newcommand{\ovis}{\mathsf{\scriptsize{VIS}}}
\newcommand{\oarb}{\mathsf{\scriptsize{AR}}}

\newcommandx{\roarb}[1][1=F]{\oarb\rest{#1}}


\newcommand{\refprop}[1]{\defref{def:implementation}, Prop. \ref{#1}}






