% !TEX root = main.tex

\section{Proof of results in \secref{sec:simulation}}

\begin{lemma} \label{lemma:sim-aux}
The followings properties holds,
\begin{enumerate}
\item \label{lemma:apply} $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ iff $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$
\item \label{lemma:reduce} $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]\cdot \adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq[']$ $\adelta[_n] \triangleleft \anupdseq['']$
\item \label{lemma:reducefirst} $\ireduce{\adelta[_0]\cdot\adelta[_1]\cdots\adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\adelta[_0] \triangleleft \anupdseq['], \ireduce{\adelta[_1]\cdots\adelta[_{n}]}\triangleleft \anupdseq['']$
\item \label{lemma:reduceinreduce} $\ireduce{\adelta[_0]\cdots\ireduce{\adelta['_{0}]\cdots\adelta['_{m}]}\cdots\adelta[_{n}]}\triangleleft \ \anupdseq$ iff $\ireduce{\adelta[_0]\cdots\adelta['_0]\cdots\adelta['_{m}]\cdots\adelta[_{n}]}\triangleleft \anupdseq$
\item \label{lemma:storechanged} Let $\adelta[_0]\cdots\adelta[_{n-1}]$ a delta sequence, such that, $\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_0] \triangleleft \anupdseq[_n]$ and the following relation $\astate \triangleleft \anupdseq$ then $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_n]$
\end{enumerate}

\end{lemma}


%\begin{lemma}\label{lemma:apply} $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ iff $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.
%\end{lemma}

\begin{proof} \ref{lemma:apply}. $\Rightarrow)$ The only possible derivation for $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ is

\[
   \mathrulean{\triangapply}
  		{ \astate \triangleleft \anupdseq['] \qquad\qquad
	   		\mathrulean{\triangreduce}
   				{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
				{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}	  
		}
		{\iapply \astate {\ireduce{\adelta[_0]\cdots\adelta[_n]}}  \triangleleft  \anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]}
\]
and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.



$\Leftarrow)$ Follows analogously. 
\end{proof}


%\begin{lemma}\label{lemma:reduce} $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]\cdot \adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq[']$ $\adelta[_n] \triangleleft \anupdseq['']$.
%\end{lemma}

\begin{proof} \ref{lemma:reduce}. $\Rightarrow)$ The only possible derivation for $\ireduce {\adelta[_1] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq$ is

\[
   \mathrulean{\triangreduce}
  					{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]\qquad\qquad
	   		\adelta[_n] \triangleleft \anupdseq[_n]  
		}
		{\ireduce {\adelta[_0] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq[_0]\cdots\anupdseq[_{n-1}] \cdot \anupdseq[_n]}	
\]
Hence, $\anupdseq['] = \anupdseq[_0]\cdots\anupdseq[_{n-1}]$ and $\anupdseq[''] = \anupdseq[_n]$. The proof is completed by using rule \ruleName{\triangreduce} on
$\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]$.

 \[  \mathrulean{\triangreduce}
   		{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]}
		{\ireduce {\adelta[_0] \cdots \adelta[_{n-1}]} \triangleleft \anupdseq[_0] \cdots \anupdseq[_{n-1}]}
\]
 
$\Leftarrow)$ Follows analogously. 
\end{proof}

%\begin{lemma}\label{lemma:reducefirst} $\ireduce{\adelta[_0]\cdot\adelta[_1]\cdots\adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\adelta[_0] \triangleleft \anupdseq['], \ireduce{\adelta[_1]\cdots\adelta[_{n}]}\triangleleft \anupdseq['']$.
%\end{lemma}


%\begin{lemma}\label{lemma:reduceinreduce} $\ireduce{\adelta[_0]\cdots\ireduce{\adelta['_{0}]\cdots\adelta['_{m-1}]}\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$ iff $\ireduce{\adelta[_0]\cdots\adelta['_0]\cdots\adelta['_{m-1}]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$

%\end{lemma}

%\begin{lemma}\label{lemma:storechanged} Let $\adelta[_0]\cdots\adelta[_{n-1}]$ a delta sequence, such that, $\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_0] \triangleleft \anupdseq[_n]$ and the following relation $\astate \triangleleft \anupdseq$ then $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_n]$
%\end{lemma}

\begin{proof} \ref{lemma:storechanged}. The proof follows by induction on the length of the sequence.

\begin{itemize}
   \item{\bf n=0}. It is easy to see that $\iapply{\astate}{\ireduce{\emptydelta}}\triangleleft \anupdseq$ is $\astate \triangleleft \anupdseq$.
   \item{\bf n=k+1}. Then, our inductive hypothesis is $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_k]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_k]$, we should build the following proof for 
							
						$\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_{k+1}]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_{k+1}] \ $
					\[
						  \mathrulean{\lemrefprop{lemma:sim-aux}{lemma:apply}}
						  {
								\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_k]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_k]
								\quad \quad 
								\anupdseq[_{k+1}]\triangleleft\anupdseq[_{k+1}] 							
							}
  						{\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_{k+1}]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_{k+1}]}  
					\]
	

\end{itemize}


\end{proof}




\begin{proof} [of ~\thmref{thm:simulation}]
 We show that the following relation is a weak simulation.
\[
\mathcal{R} = \{ (\isystemterm, \systemterm) \ |\ \implements{\isystemterm{}}{\systemterm} \}
\]


			
			\begin{itemize}
%				\item {\bf rule (\textsc{t-read})}. If $\systemterm  \arroi{\readtran{r}} \systemterm '$, then by rule (\textsc{\footnote{?}notesize{t-read}}), $\systemterm $ must be the following term: 
%				$\tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				, therefore, the client $i^{th}$ is the only one who have changed. So that, $\systemterm'$ is 
%				$\tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				. As $(\systemterm,\isystemterm)$ belongs $\mathcal{R}^{-1}$ then $\isystemterm$ must be $\clientr{\readins{x}{r}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $\isystemterm$ can perform.
%				Then by rule (\textsc{read}), $\isystemterm' = \clientr{\update{P}{x}{v}}{\stateclient}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We will prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}^{-1}$ if the ten properties introduced are keeping.
\item {\bf rule \ruleName{i-update}}. Then, $\isystemterm  \arroi{\updatetranaux{\anupd^{\vertice[@][']}}} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	
				  \end{array}
				\]
				
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\systemterm = \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. 
				By  using rule \ruleName{update}, 
				$\systemterm \arroi{\updatetran{u}} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
						\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  \end{array}		
				\]
				.
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$.
				Note that the only terms that have changed are the transaction buffers 
				$\ttransactionbuffer$ and $\ttransactionbuffer$	corresponding to the client $\cid$. 	
				Therefore, we only check that condition \refprop{prop_transactions}
				still holds for client $\cid$.
				%	\begin{enumerate}
				%		\item[\ref{prop_transactions}.] 
				Since 
						$\implements{\isystemterm}{\systemterm}$, it holds that 
						$\transactionbuffer \triangleleft{\ttransactionbuffer}$ by \refprop{prop_transactions}. 						
						Then, $\iappend{\transactionbuffer}{u} \triangleleft \ttransactionbuffer \cdot \tupdate$ holds by
						rule \ruleName{\triangappend}.

\item {\bf rule \ruleName{i-push}}. Then, $\isystemterm  \arroi{\pushtran} \isystemterm '$ with 

				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpushins]} \ \bigpar \ \isystemterm[''] 
					\\
					\isystemterm['] & {\addid{\iclientinst[P][@][@][\ireduce{\pushbuffer\cdot \transactionbuffer}][\epsilon][@][\irounds+1]}\ \bigpar \ \isystemterm['']}
				  \end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				$ \tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] $
				with $\implements{\isystemterm['']}{\systemterm['']}$. 
				
				By using rule \ruleName{push}, 
				$\systemterm \arroi{\pushtran} \systemterm[']$ with
				
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot \ublock[\ttransactionbuffer]}{\emptydelta}{\tsent \cdot \ublock[\ttransactionbuffer]}{\treceivebuffer}[@][\trounds+1]}[{\systemterm['']}]\\
				  \end{array}		
				\]
								
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$.
				Since the computations involve only client $\cid$, we only need to check that  properties in \defref{def:implementation} still hold for $\cid$.		
					
					\begin{enumerate}
					
						\item[\ref{prop_transactions}.] It  holds since $\medskip\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}.
						
						\item[\ref{prop_pending}.] 	Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by \refprop{prop_transactions};  
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending}$ by  \refprop{prop_pending}.
						\end{itemize}
						We know that $\flatten{\tpending\cdot [\ttransactionbuffer]}$ = $\flatten{\tpending} \cdot \ttransactionbuffer$.
						 Then, we  build the following proof 
						$\ireduce{\igetdeltas{\pending}\cdot\ireduce{{\pushbuffer}\cdot \transactionbuffer}}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}$
						 

						\[
					  	 \mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduceinreduce}}
					   	{
						  	\mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduce}}
						  	{\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
						    	\quad
						    	\transactionbuffer \triangleleft \ttransactionbuffer}
  							{\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}\cdot \transactionbuffer}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
					   	}
					   	{\ireduce{\igetdeltas{\pending}\cdot\ireduce{{\pushbuffer}\cdot \transactionbuffer}}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
						\]
					
						 
						\item[\ref{prop_sent}.] 		
						 Since $\implements{\isystemterm}{\systemterm}$, if $\cid_l \in \dom\inserver$ and $\inclient \cdot\outserver(\cid_l) \neq \agssegpair[{\astate[']}][{\amxrf}]\cdot\aseqseg$ then
						 $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
						 and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
						 By $\lemrefprop{lemma:sim-aux}{lemma:reduce}$, $\flatten{\tsent} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
						 $\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$. 
						 Then, we build the following proof 
						% \[\ireduce{\igetdeltas{\inserver(\cid)}\cdot\ireduce{\pushbuffer\cdot \transactionbuffer}} \triangleleft \ \flatten{{\tsent}\cdot[\ttransactionbuffer]}\]
						 {\scriptsize
						\[
						  \mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduce}}
						  {
						  \ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1] 
						  \quad
						  \mathrulean{\triangreduce}
						    	{\pushbuffer \triangleleft {\anupdseq[_2]}
								\quad
								\transactionbuffer \triangleleft \ttransactionbuffer}
  							{\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft \anupdseq[_2]\cdot\ttransactionbuffer}  
							}
							{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\ireduce{\pushbuffer\cdot \transactionbuffer}} \triangleleft \ \anupdseq[_1]\cdot(\anupdseq[_2]\cdot \ttransactionbuffer)}
						\]}

						 The proof is completed by noting that $\anupdseq[_1]\cdot(\anupdseq[_2]\cdot \ttransactionbuffer) = \flatten{{\tsent}\cdot[\ttransactionbuffer]}$.
						 \medskip


					%	\item  \textcolor{red}{$\cid\notin\dom\inserver$: 
					%	 Since $\implements{\isystemterm}{\systemterm}$, 
					%	 $\pushbuffer \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
					%	 and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
					%	 Then, we build the following proof 
					%	\[
					%	  \mathrulean{\lemref{lemma:reduce}}
					%	  {
					%	  \igetdeltas{\inserver(\cid)} \triangleleft \ \anupdseq[_1] 
					%	  \quad
					%	 \transactionbuffer \triangleleft \ttransactionbuffer}
  					%	 {\ireduce{\pushbuffer\cdot \transactionbuffer} \triangleleft \ \anupdseq[_1]\cdot\ttransactionbuffer}
					%	\]
					%	The proof is completed by noting that $\anupdseq[_1] = \flatten{{\tsent}}$.
					%	}
					%	\end{itemize}
						
						
					\item[\ref{prop_deltas}.] Since  $\implements{\isystemterm}{\systemterm}$,  \refprop{prop_deltas} ensures 
					that 
					for all $\agssegpair\in\inclient\cdot\outserver(\cid)$, $\amxrf(\cid)\leq\irounds$. Consequently
					$\amxrf(\cid)<\irounds_l+1$. Second item holds straightforwardly because 
					$\inclient$, $\outserver(\cid)$ and $\pending$ have not been changed. 
								
					\end{enumerate}
 The remaining properties straightforwardly hold.
						

\item {\bf rule \ruleName{i-send}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient['']\ \\
					\isystemterm['] & \addid{\iclientinst[@][@][\pending \cdot \around][\emptydelta]}
		\ \bigpar \ \iserverins[{\astate[']}][@][\inserver\upd{\cid}{\inserver(\cid)\cdot\around}]
		\ \bigpar\ \iclient[''] \\
		
				\multicolumn 2 l{\pushbuffer\neq\emptydelta}\\
				\multicolumn 2 l	{\cid\in\dom\inserver}\\
				\around & \aroundtuple[\cid][\nround][\pushbuffer]\\
				\multicolumn 2 l	{\inclient \cdot\outserver(\cid) \neq \agssegpair[{\astate[']}][{\amxrf}]\cdot\aseqseg}

					\end{array}
				\]
				
				Then, we take $\systemterm'=\systemterm$ and 							
				  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$. Since the changes only affect 
				  client $\cid$ and the input buffer for $\cid$  on the server, we need to check that properties in \defref{def:implementation}
				  still hold for $\cid$.			

						\begin{itemize}
						
								\item[\ref{prop_pending}.] By hypothesis, $\pending = \aroundtuplei[0]\ldots\aroundtuplei[h]$ and  
							$\ireduce{\adelta_0\cdots\adelta_h\cdot\pushbuffer} \triangleleft \flatten{\tpending}$.
							 Since $\pending \cdot \around = \aroundtuplei[0]\ldots\aroundtuplei[h]\cdot{\aroundtuple[@][@][\pushbuffer]}$,
							we need to prove that  $\ireduce{\adelta_0\cdots\adelta_h\cdot\adelta_p\cdot\emptydelta} \triangleleft \flatten{\tpending}$. 
							It holds by using \lemrefprop{lemma:sim-aux}{lemma:reduce}, and the fact that $\emptydelta \triangleleft \epsilon$.
							%It is easy to see that it is the same relation that our hypothesis, since $\adelta_p$ was moved to the pending sequence. Therefore this property also holds.
							

							\item[\ref{prop_sent}.] 
							Since $\implements{\isystemterm}{\systemterm}$ and $\cid\in\dom\inserver$ and $\inclient \cdot\outserver(\cid) \neq \agssegpair[{\astate[']}][{\amxrf}]\cdot\aseqseg$ then $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{{\tsent}}$ 
							holds by \refprop{prop_sent}. On the other hand, $\around = \aroundtuple[\cid][\nround][\pushbuffer]$. 
														%Since the hypothesis of the rule states that $\cid\in\dom\inserver$,
							 We need to prove that
							\[\ireduce{\igetdeltas{\inserver(\cid)\cdot \around}\cdot \emptydelta} \triangleleft \ \flatten{\tsent} \]
							
							Note that $\igetdeltas{\inserver(\cid)\cdot \around} = \igetdeltas{\inserver(\cid)}\cdot\pushbuffer$. Then,
							\[
						  	\mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduce}}
						  	{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\pushbuffer} \triangleleft \ \flatten{\tsent}
								\quad
								\emptydelta \triangleleft \epsilon}
  							{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\around\cdot\emptydelta} \triangleleft \ \flatten{\tsent}}  
							\]
							
							\item[\ref{prop_deltas}.] Since $\implements{\isystemterm}{\systemterm}$,  for all 
							$\agssegpairi[0]\in\inclient\cdot\outserver(\cid)$
						  {\refprop{prop_deltas}} ensures that 
  							 \begin{itemize}
          							\item $\amxrf_0(\cid)\leq\irounds$,
								\item  for all $\aroundtuple[@][\irounds'][\adelta'] \in\pending$
								 if $\irounds'\leq\amxrf_0(\cid)$ then $\adelta_0\triangleleft \queuemessage[x..x']$ and  
								 $\adelta'\triangleleft \queuemessage[y..y']$ with $y'\leq x'$.
							  \end{itemize}
						  It remains to prove that for 
						  $\around = \aroundtuple[\cid][\nround][\pushbuffer]$  if $\irounds\leq\amxrf_0(\cid)$ then 
						  $\adelta_0\triangleleft \queuemessage[x..x']$ and  
								 $\adelta'\triangleleft \queuemessage[y..y']$ with $y'\leq x'$. 
						 By well-formed condition \refiwellformprop{wf-igsp-pending}, $\pushbuffer\neq\emptydelta$ implies $\irounds>\amxrf_0(\cid)$.
						 Hence, the condition trivially holds.

							
							%We have moved the ${\pushbuffer}$ to $\inserver(\cid)$, leaving in the push buffer, $\emptydelta$. Furthermore, ${\tsent}_t$ is $\epsilon$. By \triangemptydelta this part of the property holds. 	
						%	We build the following proof for 
						%$\ireduce{\igetdeltas{\inserver(l)}\cdot \pushbuffer} \triangleleft \ {\tsent}_h \cdot {\tsent}_t$
						%\henote{Aca no es cualquier l, es la identidad dle cliente que se movio. Revisar con la nueva formulacion}
					%\[
					%	  \mathrulean{\lemref{lemma:reduce}}
					%	  {\ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h
					%			\quad
					%			\pushbuffer \triangleleft {\tsent}_t}
  					%	{\ireduce{\igetdeltas{\inserver(l)}\cdot \pushbuffer} \triangleleft \ {\tsent}_h \cdot {\tsent}_t}  
					%\]
					%\henote{estas usando $\delta_p$ en lugar de $\pushbuffer$, gran lio si cambiamos las macros}.
			
					
							
						\end{itemize}
 The remaining properties straightforwardly hold.


\item {\bf rule \ruleName{receive}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{\  =\  }l}
					{\isystemterm} & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient['']
					\\
					{\isystemterm[']} & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient['']
					\\
					\outserver(\cid) & \aseg\cdot\aseqseg
					
				  \end{array}
				\]

				Moreover, 
				\[\systemterm = \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\queuemessage\ \bigpar\ \Absclient'' }]. \]
			
			
				Since $\implements{\isystemterm}{\systemterm}$, \refprop{prop_inclient} holds. We have three interesting cases:
				\begin{itemize}

					\item  ${\inclient} = \agssegpairi[1] \cdots \agssegpairi[h']$, 
					
					$\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 

					\begin{equation}
					\label{eq:sim-receive-c1-c}
     					 \ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}  
					 \end{equation}
					 %
    					 \begin{equation}
					\label{eq:sim-receive-c1-d}
					\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft  \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}
					\end{equation}
	
	
	
					By $\lemrefprop{lemma:sim-aux}{lemma:reducefirst}$ on \equref{eq:sim-receive-c1-d}, 
					$\flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]$, 
					$\adelta_{h'+1} \triangleleft \anupdseq[_1]$ and 
					$\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \anupdseq[_1u] $.
					%					 
					Therefore, there exists $m \geq 0$ s.t. 
					 $\tknown+\treceivebuffer+m \leq  |\queuemessage| -1$ and 
					$\anupdseq[_1] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
					$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}$. Hence,
					%
					\begin{equation}
					\label{eq:sim-receive-c1-a}
					\adelta_{h'+1} \triangleleft \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}
					\end{equation}
					%
					\begin{equation}
					\label{eq:sim-receive-c1-b}
					 \ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}
					\end{equation}
					%	
				If $m=0$, then take $\systemterm['] = \systemterm$. Otherwise, note that $\tknown+ \treceivebuffer + m < |\queuemessage|$  allows
				for  $m$ applications of rule \ruleName{send}. Hence,  
				$\systemterm \arroi{\tau}\cdots\arroi{\tau} \systemterm[']$ 
				with
				\[\begin{array}{r@{=}l}
						\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+m}}[{\queuemessage\ \bigpar\ \Absclient'' }]	
				  \end{array}		
				\]
				
				We check now that  $\implements{\isystemterm[']}{\systemterm[']}$. Since the unique elements that are modified by the reductions 
				are $\inclient$, $\outserver(\cid)$ and $\treceivebuffer$, we  only need to check that \refprop{prop_inclient} still holds for client $\cid$.
				
				\begin{itemize}
				
					\item[\ref{prop_inclient}.] Take ${\inclient'} = \agssegpairi[1] \cdots \agssegpairi[h']\cdot\agssegpairi[{h'+1}]$ and
					
					 $\outserver(\cid)' = \agssegpairi[h'+2] \cdots \agssegpairi[h]$. We prove that
					\[\ireduce{\adelta_1\cdots\adelta_{h'+1}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]}\]
					by using \lemrefprop{lemma:sim-aux}{lemma:reduce} with the hypothesis \equref{eq:sim-receive-c1-c} and \equref{eq:sim-receive-c1-a}, \ie,
										
%					Since $\implements{\isystemterm}{\systemterm}$,  \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}
%					By $\lemref{lemma:reduce}$, $\flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
%						$\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$ with
%						$\anupdseq[_1] = \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}$,
%						$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
%						 Then, we can build the following proof 
						{\small 
						\[
						  \deduce%{\lemref{lemma:reduce}}
						       {%\label{eq:sim-receive-c1-c}
     					 \ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]} 
							\quad
							\adelta_{h'+1} \triangleleft \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}}
  						       {\ireduce{\adelta_1\cdots\adelta_{h'+1}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]}}  
						\]
						}
						
						
					Note that
					$\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \flatten{\queuemessage[\tknown+\treceivebuffer+m..|\queuemessage| - 1]}$
					also holds because of \equref{eq:sim-receive-c1-b}.
					
					\item[\ref{prop_deltas}.] It straightforwardly follows because $\pending$ and $\agssegpair\in\inclient\cdot\outserver(\cid)$
					have not changed. 

					


%					
%					
%					By $\lemref{lemma:reducefirst}$, $\flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
%					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]$ and 
%					$\adelta_{h'+1} \triangleleft \anupdseq[_1]$, with 
%					$\anupdseq[_1] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
%					$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}$,
%					Then, we can build the following proof 
%						 
%					\[
%						  \mathrulean{\lemref{lemma:reducefirst}}
%						       {\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]
%							\quad
%							\adelta_{h'+1} \triangleleft \anupdseq[_1]}
%  						       {\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \anupdseq[_2]}  
%					\]
%					
%			%		\flatten{ \queuemessage[\tknown+\treceivebuffer..m-1]}$. Then,
%
					
							
					\end{itemize}	
					
					
				\item ${\inclient} = \agssegpair[{\astate[']}]\cdot\agssegpairi[{z+1}] \cdots \agssegpairi[h']$, 	
								
				$\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 
				%\setcounter{equation}{0}
					
					\begin{equation}
					\label{eq:sim-receive-c2-c}
     					 \ireduce{\igetdeltas{\agssegpairi[{z+1}] \cdots \agssegpairi[h']}}\triangleleft \ \flatten{ \queuemessage[t..\tknown+\treceivebuffer-1]}
					 \end{equation}
					%\begin{equation}
					%\astate['] \triangleleft \ \flatten{\queuemessage[0 .. t - 1]}
					%\end{equation}
    					 \begin{equation}
					\label{eq:sim-receive-c2-d}
					\ireduce{\igetdeltas{\outserver(\cid)}} \triangleleft \ \flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]}
				\end{equation}
				
				Where $t \leq \tknown+\treceivebuffer$ s.t. $\astate['] \triangleleft \ \flatten{\queuemessage[0 .. t - 1]}$.

				The case follows analogously to the previous case, since, \equref{eq:sim-receive-c1-d} and \equref{eq:sim-receive-c2-d} are equals and the only difference between \equref{eq:sim-receive-c1-c} and \equref{eq:sim-receive-c2-c}  is the init of the subsequence above $\queuemessage$. The proof for \refprop{prop_inclient} holds 					by using \lemrefprop{lemma:sim-aux}{lemma:reduce} with the hypothesis \equref{eq:sim-receive-c2-c} and \equref{eq:sim-receive-c1-a}.

     		%$\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$,
               %$\astate['] \triangleleft \queuemessage[0 .. t - 1]$ and $t \leq \tknown_l+\treceivebuffer_l$; 


					
					\item  ${\inclient} = \epsilon$, 
     					          $\outserver(\cid) = \agssegpair[{\astate[']}]\cdot\agssegpairi[z+1] \cdots \agssegpairi[h]$, 
     						   $\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$
      						   $\astate['] \triangleleft \queuemessage[0 .. l - 1]$ and $\tknown+\treceivebuffer \leq l$;  
					then $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{h}]}}\triangleleft \flatten{\queuemessage}$. 
					Since $\astate['] = \iapply{\initialstate}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$, then $\astate[']\triangleleft \queuemessage[0..l-1]$ with $r = l - \tknown - \treceivebuffer$, besides $r \leq l < |\queuemessage|$.  Hence,
				
				\[\systemterm = \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. As $\tknown+ \treceivebuffer + r < |\queuemessage|$ then by inspection of rules in 				\figref{fig:OS-tgsp}, 
				$\systemterm \arroi{\tau}\cdots\arroi{\tau} \systemterm^{r}$ with $r$ internal transitions. Then,
				\[\begin{array}{r@{=}l}
						\systemterm^{r} & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+r}}[{\systemterm['']}]	
				  \end{array}		
				\]
				
				Furthermore,
				$\systemterm^{r} \arroi{\tau} \ldots\ \arroi{\tau} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + r + m}}[{\systemterm['']}] \\
				  \end{array}		
				\]


				$m$ represents the amount of internal transition that performed by client $\cid$ to reach $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$. Hence, $m =  |\queuemessage| - l - 1$ which always is $< |\queuemessage|$.   


								
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{itemize}	
	
					\item[\ref{prop_inclient}.] It easy to see because the segment from $\outserver(\cid)$ was moved to $\inclient$ holdings the hypothesis.
					
					
					\item[{--}] The remaining properties straightforwardly hold.
							
				\end{itemize}	
	
	
							
				\end{itemize}
							The remainging case is straightforward since the hyphotesis is false, hence the property holds.

% \item ${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$; 
 %    \linebreak
  %    $\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft  \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1])$; and $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft 
   %    \queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1])$

				
%				\chnote{Si bien es obvio, lo pregunto. No estamos poniendo como hipotesis que i pertenece al outserver. Se infiere con la hipotesis, pero no es necesario?}
%				\henote{se puede agregar, no da\~na igual las pre no se evaluan en ningun orden, uno tuviese que decir con implicaicones y queda feo}
				

%				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
%				by checking the properties in \defref{def:implementation}.			



%						\begin{itemize}
%							\item[\ref{prop_inclient}.] It is immediate that this property holds because we move a segment from $\outserver(i)$ to $\inclient(i)$.
							
							
%						\item[{--}] The remaining properties straightforwardly hold.

%						\end{itemize}
					
	
	\item {\bf rule \ruleName{i-pull${_1}$}}. Then, $\isystemterm  \arroi{\pulltran} \isystemterm '$ with 
	
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@]
						[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						[@][@][@][n]}
								\ \bigpar  \ {\iserverins[\astate[']]} \ \bigpar\ \iclient[']				\\
					%\outserver(\cid) & \agssegpair[{\adelta_{1}'}][{\amxrf_1'}]\ldots \agssegpair[{\adelta_{h}'}][{\amxrf_{h}'}]
					%\\
					\isystemterm['] & \addid{\iclientinst[P]
						 [\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}][n][\epsilon]}\  \bigpar  \ {\iserverins[\astate[']]} \ \bigpar\ \iclient[']
					\\
					\aseqround['] & \filter{\amxrf_{h'}(\cid)}{\aseqround} 
					\\
					\inclient & \agssegpair[{\adelta_1}][{\amxrf_1}]\ldots \agssegpair[{\adelta_{h'}}][{\amxrf_{h'}}]
					
				  \end{array}
				\]
		
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\queuemessage}\ \bigpar\ \Absclient[']] \]
				
				
				By rule  \ruleName{pull}, 
				$\systemterm\arroi{\pulltran} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  
					\tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown +
						 \treceivebuffer  {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\queuemessage\ \bigpar\ \Absclient[']}]	
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$. 
				Since the reduction only affects the client $\cid$, we only need to check
				that  properties in \defref{def:implementation} still hold for $\cid$.	
									\chnote{Hablamos de agregar en el texto principal que $\ireduce{\epsilon} = \emptydelta$. Qué hacemos?}

					\begin{enumerate}
					\item[\ref{prop_state_known}.]  By \refprop{prop_state_known}, we know that $\known\ \triangleleft\ \flatten {\queuemessage[0..\tknown-1]}$. 
					By \refprop{prop_inclient},  $\ireduce{\adelta[_1]\cdots\adelta[_{h'}]}\triangleleft \queuemessage[\tknown ..  \tknown + \treceivebuffer - 1]$. 
					Then, we can derive 
		%				$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}\triangleleft \flatten{\queuemessage[0 .. \tknown+\treceivebuffer - 1]} \ $					\[
					\[	  \mathrulean{\triangapply}
						  {
							\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
							\quad 
							\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \queuemessage[\tknown ..  \tknown + \treceivebuffer - 1]
							}
						{\iapply{\known}{\ireduce{\adelta_1\cdots\adelta_{h'}}}\triangleleft \flatten{\queuemessage[0 .. \tknown +\treceivebuffer - 1]}}  
					\]
					
						\item[\ref{prop_pending}.] We have to prove that 
						$\ireduce{\igetdeltas{\filter{\amxrf_{h'}(\cid)}{\pending}}} 
							\triangleleft 
							\flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$.
					         By \refprop{prop_pending}, 
					         $\ireduce{\igetdeltas{\pending}\cdot\pushbuffer} \triangleleft \flatten{\tpending}$
					         and  by \refprop{prop_inclient},
					         $\ireduce{\igetdeltas{\outserver(\cid)}}\triangleleft 
       							\flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]}$.

					         By \refprop{prop_deltas} for all $\agssegpair\in\inclient\cdot\outserver(\cid)$, 
					         for all $\aroundtuple[@][@][\adelta'] \in\pending_l$
					         if $\irounds\leq\amxrf(\cid_l)$ then $\adelta\triangleleft \queuemessage[x..x']$ and  
					         $\adelta'\triangleleft \queuemessage[y..y']$        with $y'\leq x'$.
					         
					          In particular, for $\amxrf_{h'}$,  holds that for all
					          $\aroundtuple[@][@][\adelta'] \in\pending_l$
					         if $\irounds\leq\amxrf_{h'}(\cid)$ then  
					         $\adelta'\triangleleft \queuemessage[y..y']$ with $y'\leq \tknown + \treceivebuffer -1$.
					         By well-formedness condition \refwellformprop{wf-gsp-pending}, 
					         $\tknown\leq x' < y'$.
					         
					         Therefore, each $\aroundtuple[@][@][\adelta'] \in\pending_l$
					         and $\irounds\leq\amxrf_{h'}(\cid)$ corresponds to a segment within 
					         $\queuemessage[\tknown+\treceivebuffer.. \tknown + \treceivebuffer -1]$. 
					         \henote{Creo que hay que agregar una condición para lo que sigue} 
					         Similarly, 
					         it can be concluded that $\aroundtuple[@][@][\adelta'] \in\pending_l$
					         and $\irounds>\amxrf_{h'}(\cid)$ corresponds to  segments beyond 
					         $\queuemessage[0.. \tknown + \treceivebuffer -1]$.
					         Therefore, 
					         $\ireduce{\igetdeltas{\filter{\amxrf_{h'}(\cid)}{\pending}}} 
							\triangleleft 
							\flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$.


					
					\item[\ref{prop_inclient}.] If follows because $\ireduce{\epsilon} = \emptydelta$,
					$\flatten{\queuemessage[\tknown+\treceivebuffer .. \tknown+\treceivebuffer + 0 - 1]} = \epsilon$ and 
					 $\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}. 
					 Morevoer, \refprop{prop_inclient} ensures
					 $\ireduce{\igetdeltas{\outserver(\cid)}}\triangleleft   
					 \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$,
					 If $\outserver(\cid) =\epsilon$, then
					 $\ireduce{\epsilon}\triangleleft   
					 \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$ implies
					 $\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1] =\epsilon$, and hence, 
					 $\tknown_l+\treceivebuffer_l = |\queuemessage|$.
				
				
				    
				
					
					
					\item[\ref{prop_deltas}.] It follows immediately because of \refprop{prop_deltas} and the fact that 
				              	$\agssegpair\in\epsilon\cdot\outserver(\cid)$ implies $\agssegpair\in\inclient_l\cdot\outserver(\cid)$.
					
					
					
					
								
				
%					
%					${\transactionbuffer}\triangleleft{\ttransactionbuffer}$
%					
%%					$\pending= \aroundtuple[\cid][n'_1][\adelta'_1]\ldots \aroundtuple[\cid][n'_k][\adelta'_k]$  
%					
%					$\ireduce{\adelta_1'\cdots\adelta_h'\cdot {\pushbuffer}} \triangleleft \flatten{\tpending}$
%					
%					${\inclient}= \agssegpairi[1] \cdots \agssegpairi[h']$, 
%					
%					$\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 
%					
%					$\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}$ and 
%					
%					
%					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft  \flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]}$
%					
%					$\pending = \aroundtuple[\cid][n_1][\adelta'_1]\ldots\aroundtuple[\cid][n_k][\adelta'_k]$ and for all $j\in\{1,\ldots,k\}$
%      $\irounds_j \leq \amxrf_{h'}(\cid)$ implies $\adelta'_{j}\ \triangleleft\ \queuemessage[a..b]$ with $\tknown\leq a < b < \tknown+\treceivebuffer-1$.
%       
%
%					$\astate \triangleleft \flatten {\queuemessage[0 .. \tknown - 1]}$
%					
%					
%					$\astate \triangleleft \flatten{\queuemessage}$
					
					\end{enumerate}




				\item {\bf rule \ruleName{read}}. Then, $\isystemterm  \arroi{\readtran{r}} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					v & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
					\end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By rule ~\ruleName{read}, 
				$\systemterm \arroi{\readtran{r}} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\\
					v' &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  \end{array}		
				\]
				
				We  show that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$. by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
				 The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by  \refprop{prop_state_known};
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by  \refprop{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by  \refprop{prop_transactions};
						\end{itemize}
						
						Then, we can build the following proof for 
						$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						= 					\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						
						{\small
						\[
								  \mathrulean{\lemrefprop{lemma:sim-aux}{lemma:apply}}
									{
										\mathrulean{\triangapply}
										{
										\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										\quad 
										\mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduce}}
											{
												\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												\quad
												\transactionbuffer \triangleleft \ttransactionbuffer
											}
											{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										}
										{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									}
									{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
					\]}
					Then, we conclude $v=v'$ by \triangread.
						 				\lemrefprop{lemma:sim-aux}{lemma:apply}										
					The remaining properties straightforwardly hold.
						


\item {\bf rule \ruleName{i-confirm}}. Then, $\isystemterm  \arroi{\confirmedtran} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm['']	
					\\
					v & (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) 
				  \end{array}
				\]
		
		
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By rule \ruleName{confirm}, 
				$\systemterm \arroi{\confirmedtran} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}
		{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	\\
					v' & \eval{(\tpending \cdot  \ttransactionbuffer == \epsilon)}
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.
				The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by  \refprop{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by  \refprop{prop_transactions};
						\end{itemize}
						Then, we know that the value of $\pending \cdot \pushbuffer$ is related to $\tpending$, thereby, when $\pending$ or $\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has any elements.
				
	
	
	
	
	\item {\bf rule \ruleName{i-batch}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \iserverins\ \bigpar \ \iclient_0 \bigpar \ldots \bigpar \iclient_m
					\\
					\isystemterm['] & {\iserverins[{\astate[']}][{\amxrf[{'}]}][{\inserver[']}][{\outserver[']}]}\ \bigpar \iclient_0\bigpar \ldots \bigpar \iclient_m\\
					\agssegpair[@][{\amxrf[{'}]}] &\receiveroundsname{\inserver} \\ %=\append{\emptygssegment}{rs} \qquad 
					\astate[']&\iapply{\astate}{\adelta} \\
					\forall\cid.(\outserver['] (\cid)& \outserver(\cid)\cdot\agssegpair[@][{\amxrf[{'}]}]) \\
					\forall\cid.(\inserver['](\cid) & \epsilon)
				  \end{array}
				\]
				
				

				Since $\implements{\isystemterm}{\systemterm}$, we have $\systemterm = \abstsyst[@][@][\Absclient_m]$
				satisfying all conditions in \defref{def:implementation}.
				
				
				
				
				Then, 
				$\ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer}} \triangleleft \ \flatten{\tsent_l}$ holds for any  
				$\cid_l \in\dom{\inserver}$ (\refprop{prop_sent}) 
				and  $\transactionbuffer_l \triangleleft{\ttransactionbuffer_l}$ (\refprop{prop_transactions}). 
				By $\lemrefprop{lemma:sim-aux}{lemma:reduce}$, $\flatten{\tsent_l} = \flatten{\anupdseq[_1]_l}\cdot\flatten{\anupdseq[_2]_l}$, 
				%
				\begin{equation}
				\label{eq:sim-batch-deltainserver}		
				\ireduce{\igetdeltas{\inserver(\cid_l)}} \triangleleft \ \flatten{\anupdseq[_1]_l}
				\end{equation}
				and 
				$ {\pushbuffer_l}  \triangleleft \ \flatten{\anupdseq[_2]_l}$. 
				Hence, 
				
				\[
				  \mathrulean{\textcolor{red}{JUSTIFICAR}}
				  {\igetdeltas{\inserver(\cid_0)} \triangleleft \ \flatten{\anupdseq[_0]_1}
				  	\quad \ldots \quad
					\igetdeltas{\inserver(\cid_m)} \triangleleft \ \flatten{\anupdseq[_1]_m}
				   }
					{\ireduce{\igetdeltas{\inserver(\cid_0)}\cdots\igetdeltas{\inserver(\cid_m)}}\triangleleft 
						\flatten{\anupdseq[_0]_1\cdots\anupdseq[_0]_m}}
				\]
				
				By definition, $\adelta = \ireduce{\igetdeltas{\inserver(\cid_0)}\cdots\igetdeltas{\inserver(\cid_m)}}$. Hence,
				
				\begin{equation}
				\label{eq:sim-batch-delta}
				\adelta \triangleleft \flatten{\anupdseq[_1]_0\cdots\anupdseq[_1]_m}
				\end{equation}
				
				For $\cid_l \not\in\dom{\inserver}$, define $\anupdseq[_1]_l = \epsilon$ and $\anupdseq[_2]_l = \tsent_l$.
				Therefore, 
				\[ \Absclient_l = \tclient{\tprogram_l}{\tknown_l}{\tpending_l}{\ttransactionbuffer_l}{\anupdseq[_1]_l \cdot \anupdseq[_2]_l}{\treceivebuffer_l}[\cid_l][\trounds_l] \]
			

				Define $h = \sum_{\cid=0}^{m} |\anupdseq[_1]_{\cid}|$ and note we can use rule \ruleName{send} $h$ times ($|{\anupdseq[_1]}_{\cid}|$ times
				for each client) to derive the following computation:
 				
				
				
%				times for each client to obtained $\systemterm$ can Furthermore, $(\isystemterm,\systemterm)\in \mathcal{R}$,
%				
%				
%				\[\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_1]] \cdot [\anupdseq[_2]]}{\treceivebuffer}[1]}[]
%				\cdots\ \bigpar \ 
%		              \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_1]] \cdot [\anupdseq[_2]]}{\treceivebuffer}[m]}[\queuemessage] \]
%				
%				 $h$ is the amount of internal transitions performed by the system. The first one, corresponds to the first block of 
%				update from $\anupdseq[_1]$ of client 1. It is called $\tsenthead[_1]$. The following transitions correspond to 
%				the remaining blocks of update of $\anupdseq[_1]$ from client 1 and  $\anupdseq[_1]$ from the rest of clients.  Then, 
%				 
				$\systemterm \tr{\tau}_0 \ldots\ \tr{\tau}_m \systemterm[']$ with
				
				\[  \systemterm['] = \Absclient'_0 \ \bigpar\ \cdots\ \bigpar\ \Absclient'_m \ \bigpar\ \queuemessage'\]
				
				where 
				\[ \Absclient'_l = \tclient{\tprogram_l}{\tknown_l}{\tpending_l}{\ttransactionbuffer_l}{\anupdseq[_2]_l}{\treceivebuffer_l}[\cid_l][\trounds_l] \]
				and
				\[\queuemessage' =\queuemessage \cdot\anupdseq[_1]_0\cdots\anupdseq[_1]_m\]
%				\[\begin{array}{r@{=}l}
%					\systemterm['] &  \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_2]]}{\treceivebuffer}[1]}[]\cdots\ \bigpar \ 
%		              \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_2]]}{\treceivebuffer}[n]}[] \queuemessage \cdot\tsenthead[_1]\cdots\tsenthead[_m]\ 
%		              
%				  \end{array}		
%				\]
%
				 
			%	 In particular,  $h$ = $|\inserver|$, hence the implementation send a only delta ($\delta$), it is a reduction of segments in $\inserver$, the abstract model can send tantos bloques de updates como cantidad de segmentos usados para construir el delta.\chnote{cambiar explicacion en castellano}
				
				
				We  prove that $(\isystemterm',\systemterm[']) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
			
					\begin{enumerate}
						\item[\ref{prop_sent}.] 
%						For all client $\cid_l$, 
%						$\ireduce{\igetdeltas{\inserver(\cid_l)}\cdot {\pushbuffer_l}} \triangleleft \ \flatten{{\tsent}}$ holds by 
%						hypothesis. 
						Note that $\igetdeltas{\inserver'(\cid_l)} = \emptydelta$ because $\inserver'(\cid_l)$ = $\epsilon$. By 
						 rule \ruleName{\triangemptydelta}, 
						$\emptydelta \triangleleft \epsilon$. Moreover, 
						 %It holds since $\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}. Furthermore, we know that
						  $\pushbuffer_l\triangleleft\anupdseq[_2]_l$.  Then, we can build the following proof
						\[ \mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduce}}
						  {
							\ireduce{\igetdeltas{\inserver'(\cid_l)}} \triangleleft \epsilon
							\quad 
							\pushbuffer_l\triangleleft\anupdseq[_2]_l
							}
						{\ireduce{\igetdeltas{\inserver'(\cid_l)}\cdot {\pushbuffer_l}} \triangleleft \ \anupdseq[_2]_l}  
						\]
						
					      	\item[\ref{prop_inclient}.] Since $\implements{\isystemterm}{\systemterm}$,  \refprop{prop_inclient} 
						ensures that for all $\cid_l \in \dom\outserver$,
						
						${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, 
						
						$\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 
						
						$\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$, 
						
						$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}$,
     
						 Note that ${\inclient}_l ' ={\inclient}_l$. Moreover, 
						 $\ireduce{\adelta_1\cdots\adelta_{h'}}\ \triangleleft\ \flatten{ \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1]}$ 
						 implies 
						 \[\ireduce{\adelta_1\cdots\adelta_{h'}}\ \triangleleft\ 
						 	\flatten{ \queuemessage'[\tknown_l..\tknown_l+\treceivebuffer_l-1]}
						\]

						Additionally, $\outserver'(\cid_l) = \outserver(\cid_l) \cdot \agssegpair[@][{\amxrf[{'}]}]$.
						By \equref{eq:sim-batch-delta},
						 
						\[ \adelta \triangleleft \flatten{\anupdseq[_1]_0\cdots\anupdseq[_1]_m}\] 
						By using $\lemrefprop{lemma:sim-aux}{lemma:reduce}$, % and \refprop{prop_inclient} we build the following proof for 
						%$\ireduce{\adelta_1\cdots\adelta_h\cdot\adelta} \triangleleft \ {\queuemessage}\cdot \tsenthead[_1]\cdots\tsenthead[_m]$
						\[
						  \mathrulean{\lemrefprop{lemma:sim-aux}{lemma:reduce}}
						  {	  
						  \ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}												\quad 
								\adelta \triangleleft \flatten{ \anupdseq[_1]_0\cdots\anupdseq[_1]_m}			
						}
  						{\ireduce{\adelta_1\cdots\adelta_h\cdot\adelta} \triangleleft \ 
						\flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1] \cdot\anupdseq[_1]_0\cdots\anupdseq[_1]_m}}
						\]
						Note that $|\queuemessage'| =  |\queuemessage| + |\anupdseq[_1]_0\cdots\anupdseq[_1]_m|$.
						Then, the proof is completed by noting that 
						\[
						\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1] \cdot\anupdseq[_1]_0\cdots\anupdseq[_1]_m
						= \queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage'| - 1]
						\]
						
					
					
					       \item[\ref{prop_deltas}.] Since $\implements{\isystemterm[']}{\systemterm[']}$, \refprop{prop_deltas} ensures that 
					       \begin{equation}
						%\begin{itemize}
%						\item $\amxrf_0(\cid_l)\leq\irounds_l$,
						%\item  
						\begin{array}{l}
						\label{eq:bisim-batch-deltas-hip}
						\forall\agssegpairi[0]\in\inclient_l\cdot\outserver(\cid_l), 
						\forall \aroundtuple[@][@][\adelta'] \in\pending,
						\\
						\qquad\mbox{if }\ \irounds\leq\amxrf_0(\cid_l)\ \mbox{then }\ \adelta_0\triangleleft \queuemessage[x..x'],
						 \adelta'\triangleleft \queuemessage[y..y'],
						\mbox{ and}\  y'\leq x'
						\end{array}
						\end{equation}
						%\end{itemize}
						
						
						Since $\inclient'_l = \inclient_l$ and
						 $\outserver['] (\cid) = \outserver(\cid)\cdot\agssegpair[@][{\amxrf}{[{\amxrf[{'}]}]}]$, it remains to prove that 
						 %$\amxrf_0(\cid_l)<\irounds_l$, and
						  for all $\aroundtuple[@][@][\adelta'] \in\pending_l$,
						 if $\irounds\leq{\amxrf}{[{\amxrf[{'}]}]}(\cid_l)$ then $\adelta\triangleleft \queuemessage'[x..x']$ and  
						 $\adelta'\triangleleft \queuemessage'[y..y']$
						with $y'\leq x'$.
						
						By well-formednes condition, either
						\begin{itemize}
						 
						   \item $\pending_l = \inserver(\cid_l)\cdot\pending_l'$. There are two cases,
						       \begin{itemize}
						       		\item $\inserver(\cid_l)\neq \epsilon$. Then, 
								$\inserver(\cid_l) = \aseqround\cdot\aroundtuple[\cid_l][\irounds_a][\adelta_a]$.
								By definition,  $\agssegpair[@][{\amxrf[{'}]}] = \receiveroundsname{\inserver}$ and
								$\amxrf[{'}](\cid_l)=\irounds_a$. Hence, ${\amxrf}{[{\amxrf[{'}]}]} (\cid_l) = \amxrf[{'}](\cid_l)=\irounds_a$.
								By well-formedness condition,  
								$\aroundtuple[@][@][\adelta'] \in\pending_l'$ implies $\irounds > \irounds_a = \amxrf[{'}](\cid_l)$ and
								$\aroundtuple[@][@][\adelta']\in \inserver(\cid_l)$ implies $\irounds \leq\irounds_a = \amxrf[{'}](\cid_l)$.
								Hence, we only need to consider $\aroundtuple[@][@][\adelta']\in \inserver(\cid_l)$.
								Since, 				
								$\queuemessage' =\queuemessage \cdot\anupdseq[_1]_0\cdots\anupdseq[_1]_m$,
								$\adelta \triangleleft \flatten{\anupdseq[_1]_0\cdots\anupdseq[_1]_m}$ and
								$\ireduce{\igetdeltas{\inserver(\cid_l)}} \triangleleft \ \flatten{\anupdseq[_1]_l}$.
								It is straightforward to notice that 
								 $\adelta\triangleleft \queuemessage[(|\queuemessage'|-h-1) ..|\queuemessage'|-1]$ 
								 and   $\adelta'\triangleleft \queuemessage'[y..y']$ with $y'\leq |\queuemessage'|-1$.
								
								 \item $\inserver(\cid_l) = \epsilon$. Therefore ${\amxrf}{[{\amxrf[{'}]}]} (\cid_l) = \amxrf(\cid_l)=\irounds_a$.
								 By well-formedness, 
								 either (i) $\inclient_l\cdot\outserver (\cid_l) = \aseqseg\cdot\agssegpair[\_][{\amxrf}]$ (and hence the case 
								  holds by \equref{eq:bisim-batch-deltas-hip}), or (ii) for all $\aroundtuple[@][@][\adelta'] \in\pending_l$, 
								 it holds $\irounds > {\amxrf} (\cid_l)$ (and hence the case trivially holds).
							\end{itemize}
							
							
						  
						  
						  \item $\pending_l =\pending_l''
						  \cdot{\aroundtuple[\cid_l][{\irounds_{lst}}][\adelta_{lst}]}
						  \cdot \inserver(\cid_l)\cdot\pending_l'$  and 
						  $\inclient_l\cdot\outserver (\cid_l) = \aseqseg\cdot\agssegpair[\delta'_{lst}][{\amxrf_{lst}}]$  with
						  ${\amxrf_{lst}} (\cid_l) = \irounds_{lst}$.
						  
						  By reasoning analogously to the previous case we show that  
						  for all $\aroundtuple[@][@][\adelta'] \in\inserver(\cid_l)\cdot\pending_l'$,
						  if $\irounds\leq{\amxrf}{[{\amxrf[{'}]}]}(\cid_l)$ then $\adelta\triangleleft \queuemessage'[x..x']$, 
						  $\adelta'\triangleleft \queuemessage'[y..y']$
						  and $y'\leq x'$.
						
						  For $\aroundtuple[@][@][\adelta'] \in\pending_l''
						  \cdot{\aroundtuple[\cid_l][{\irounds_{lst}}][\adelta_{lst}]}$ we proceed as follows. 
						  By \equref{eq:bisim-batch-deltas-hip},
						  $\adelta'_{lst}\triangleleft \queuemessage[x..x'],
						 \adelta'\triangleleft \queuemessage[y..y'],
						\mbox{ and}\  y'\leq x'$.
						Since, $\queuemessage' =\queuemessage \cdot\anupdseq[_1]_0\cdots\anupdseq[_1]_m$ and
						$\adelta \triangleleft \flatten{\anupdseq[_1]_0\cdots\anupdseq[_1]_m}$, 
						it is immediate to notice that
						$y'\leq|\queuemessage'|-1$.
						  
						  
						  
						  
						\end{itemize}
						
						 

					
						\item[\ref{prop_stateserver}.] 
						
						
						Since $\implements{\isystemterm}{\systemterm}$, $\astate \triangleleft \flatten{\queuemessage}$  by \refprop{prop_stateserver}.
						 Furthermore, $\adelta \triangleleft \flatten{ \anupdseq[_1]_0\cdots\anupdseq[_1]_m}$ by \equref{eq:sim-batch-delta}. 
						 Then, by \lemrefprop{lemma:sim-aux}{lemma:storechanged} we build the following proof:
						
						\[
						  \mathrulean{\lemref{lemma:storechanged}}
						  {
							\astate \triangleleft \flatten{\queuemessage}
							\quad 
							\adelta \triangleleft   \flatten{ \anupdseq[_1]_0\cdots\anupdseq[_1]_m}			
							}
  						{\iapply{\astate}{\ireduce{\adelta}} \triangleleft \ \flatten{\queuemessage \cdot   \anupdseq[_1]_0\cdots\anupdseq[_1]_m}			}  
					\]
						
						\item[{--}] The remaining properties straightforwardly hold.
				\end{enumerate}

	\item {\bf rule \ruleName{i-pull$_2$}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@][\aseqround][@][@][@][@][\inclient]}
			     \ \bigpar \ \iserverins[{\astate[']}][{\amxrf}] \ \bigpar\ \iclient
			              \\
			              						\inclient  & \agssegpair[{\astate[''']}][{\amxrf[_0]}]\cdot\agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]\\

					\isystemterm['] & \addid{\iclientinst[P]
						 [{\astate['']}]
						 [{\aseqround'}]
						 [@][@]
						 [{\receivebuffer}]}
						\ \bigpar \ \iserverins[{\astate[']}][{\amxrf}][\inserver\upd{\cid}{\inserver(\cid)\cdot\aseqround[']}]
						\ \bigpar\ \iclient \\
						
						
					       \astate['']  & \iapply{\astate[''']}	{\ireduce{\emptydelta\cdot\adelta[_1]\cdots\adelta[_k]}} \\	

						\aseqround['] & \filter{\amxrf[_k](\cid)} \aseqround \\
					 \end{array}
				\]
			
			
			Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By rule \ruleName{pull}, 
				$\systemterm \arroi{\pulltran} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm[']&  \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm['']}] \\
				  \end{array}		
				\]
		
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
				\item[\ref{prop_inclient}.] $\inclient$ = $\epsilon$ and $\treceivebuffer$ = 0, then it holds by 
					\refprop{prop_state_known}.
		
					\item[\ref{prop_state_known}.] By \propref{prop_inclient} we know that 
%					$\astate['''] = \iapply{\initialstate}{\ireduce{\adelta[']_1\cdots\adelta[']_{z}}}$  
%					and
				       $\astate['] \triangleleft \ \queuemessage[0 .. t - 1]$ and $t \leq \tknown+\treceivebuffer$ and  
					$\ireduce{\adelta_{1}\cdots\adelta_{k}}\triangleleft \ \flatten{ \queuemessage[t..\tknown+\treceivebuffer-1]}$.
					 Then,
%					  we should build the following proof for 
%						\[\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown +\treceivebuffer- 1]} \]
					\[
						  \mathrulean{\triangapply}
						  {
							\astate['] \triangleleft \flatten {\queuemessage[0..t-1]}
							\quad 
							\ireduce{\adelta[_1]\cdots\adelta[_k]} \triangleleft \flatten{\queuemessage[t .. \tknown+\treceivebuffer  - 1]}
															}
  						{\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown +\treceivebuffer - 1]} }  
					\]
						
						\item[\ref{prop_pending}.] Follows 
						analogously to rule \ruleName{i-pull$_1$}.
						
						\item[\ref{prop_deltas}.] 
						It follows immediately because of \refprop{prop_deltas} and the fact that 
				              	$\agssegpair\in\epsilon\cdot\outserver(\cid)$ implies $\agssegpair\in\inclient_l\cdot\outserver(\cid)$.											
						
					\end{enumerate}
					 The remaining properties straightforwardly hold.

	
	
			\item {\bf rule \ruleName{i-accept-cxn}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \server{\astate}{\inserver}{\outserver} \ \bigpar\  \iclient 	\\
					\isystemterm['] & \server{\astate}{\inserver\upd\cid\epsilon}{\update{\outserver}{\cid}{\agsprefpair}}\ \bigpar\  \iclient 
				\end{array}
				\]

				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
				
					\item[\ref{prop_inclient}.] By \propref{prop_outserver2}, when $\outserver(i)$ has a state $\astate[']$ as prefix, then $\astate = \iapply{\astate[']}{\ireduce{\adelta_1\cdots\adelta_h}}$ . In particular, there do not exists deltas in $\outserver(i)$ so that $\astate = \astate[']$. By \propref{prop_stateserver}, we know that $\astate \triangleleft \queuemessage$, hence this property holds.
											
						\item[{--}] The remaining properties straightforwardly hold.

					\end{enumerate}

			\item {\bf rule \ruleName{drop-conn}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[@][@][\aseqround][@][@][@][@][\inclient]}
								   \ \bigpar \ \server{\astate}{\inserver}{\outserver} \ \bigpar \ \iclient 	\\
					\isystemterm['] & \addid{\iclientinst[@][@][\aseqround][@][@][@][@][\epsilon]}
									\ \bigpar \server{\astate}{\inserver \setminus\cid}{\outserver \setminus\cid}\ \bigpar \ \iclient 				
					\end{array}
				\]



				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
							
						\item[{--}] Properties straightforwardly hold.

					\end{enumerate}



				%
				%\item {\bf rule \ruleName{read}}. Then, $\systemterm  \arroi{\readtran{r}} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					%\\
					%v &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  %\end{array}
				%\]
		%
				%\henote{Ac\'a es $\systemterm['']$ porque $N$ es el que estas usando}.
				%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[ \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\readtran{r}} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					%v' & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by property \ref{prop_state_known};
							%\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%
						%Then, we can build the following proof for 
						%$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						%= 
						%\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						%\[
						  %\mathrulean{\triangread}
						    %{
								  %\mathrulean{\lemref{lemma:apply}}
									%{
										%\mathrulean{\triangapply}
										%{
										%\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										%\quad 
										%\mathrulean{\lemref{lemma:reduce}}
											%{
												%\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												%\quad
												%\transactionbuffer \triangleleft \ttransactionbuffer
											%}
											%{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											%\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										%}
										%{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									%\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									%}
									%{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									%\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
								%}
  						  %{v'  = v}  
					%\]
											%
						%\item to 9 straightforwardly hold.
						%
%
					%\end{enumerate}
					%
					%
			%\item {\bf rule \ruleName{update}}. Then, $\systemterm  \arroi{\updatetran{u}} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  %\end{array}
				%\]
				%\chnote{Deberi\'amos cambiar la regla del update en la imple para que guarde updates con vertices como hacemos en abs}.
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
%
				%\[\addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\updatetran{u}} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	\\
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the transaction buffers in client $\cid$. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%
						%Then, we can build the following proof for 
						%$\iappend{\transactionbuffer}{u}
						%\triangleleft 
						%\ttransactionbuffer \cdot \tupdate$
						%\[
						  %\mathrulean{\triangappend}
						      %{
						      %\transactionbuffer \triangleleft{\ttransactionbuffer}
						      %}
  						%{\iappend{\transactionbuffer}{u}]
						%\triangleleft 
						%\ttransactionbuffer \cdot \tupdate}  
					%\]
%
						 %\chnote{Esta prueba es m\'as inmediata, creo que aca no haria falta mostrar el detalle ya que es solo un paso. Con mencionar la regla del append tiene que alcanzar, lo dejo por si preferis que quede asi.}.
%
						%\item to 9 straightforwardly hold.
						%
%
					%\end{enumerate}
	
	
			
					%
	%
	%\item {\bf rule \ruleName{pull}}. Then, $\systemterm  \arroi{\pulltran} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm['']}]	
				  %\end{array}
				%\]
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[ \addid{\iclientinst[\tpullins][@]
						%[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						%[@][@][@][n][{\agssegpair[{\adelta[']}]}\cdot\inclient]}
								%\ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\pulltran} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P]
						 %[\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}]
						 %[\aseqround']
						 %[@][@]
						 %[{\receivebuffer}][n][\epsilon]}\ \bigpar \ \isystemterm['']	\\
					   %\aseqround['] & filter\ (\geq \amxrf[_k](\cid)) \ \aseqround \\
						%\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.	
						%\chnote{esta oka la regla pull1? el in del cliente no entiendo porque tiene el delta y la f, para que la usas?}
					%\begin{enumerate}
						%\item We will inspect the terms that have changed in client $\cid$ knowing as hypothesis that $\implements{\isystemterm}{\systemterm}$.
						%\begin{itemize}
							%\item By \propref{prop_state_known}, $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]} \ $, however, after $\pulltran$ transition, we should build the following proof for 
						%$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]} \ $
					%\[
						  %\mathrulean{\lemref{lemma:apply}}
						  %{
							%\mathrulean{\triangapply}
								%{
								%\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
								%\quad 
								%\adelta[_1] \triangleleft \queuemessage_A[\tknown_l] \ldots \adelta[_k] \triangleleft \queuemessage_A[\tknown_l + \treceivebuffer_l - 1]
								%}
								%{\iapply{\known}{\adelta[_1]\cdots\adelta[_k]}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}
								%}
							%}
  						%{\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}}  
					%\]
					  %The last step is worth by \propref{prop_inclient}.
						%\item By \propref{prop_inclient}, if $\inclient_l = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]$ then 
		%$\adelta[_1] \triangleleft \queuemessage[\tknown_i] \ldots \adelta[_k] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l - 1]$. After $\pulltran$ transition, $\inclient_l$['] = $\epsilon$ and $\treceivebuffer_l$ = 0, then by 
		%\triangemptydelta, this property is hold.
						%\item We have to prove that $\ireduce{\adelta[_m]\cdots\adelta[_h]} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$ (PENDIENTE)
						%\end{itemize}
		%
				%
%
					%\end{enumerate}
	
	
	        %\item {\bf rule \ruleName{confirm}}. Then, $\systemterm  \arroi{\confirmedtran} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}
		%{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					%\\
					%v & \eval{(\tpending \cdot  \ttransactionbuffer == \epsilon)}
				  %\end{array}
				%\]
		%
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[\addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\confirmedtran} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm['']	\\
					%v' & (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) 
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%Then, we know that the value of $\pending \cdot \pushbuffer$ is related to $\tpending$, thereby, when E.$\pending$ or E.$\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has any elements.
			%
					%\end{enumerate}
				%
				%
				%\item {\bf rule \ruleName{receive}}. Then, $\systemterm  \arroi{\tau} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1}}[{\systemterm['']}]	
					%
				  %\end{array}
				%\]
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[\addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate['']] \ \bigpar\ \iclient['']\]
				%%with $\implements{\isystemterm['']}{\systemterm['']}$. 
				%by inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\tau} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient[''] \\
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
%
						%\begin{itemize}
							%\item[4.] By \propref{prop_outserver}, we know that the firt element in $\outserver(i)$ = $\queuemessage[\tknown_l+\treceivebuffer_l]$ when $m$ = 1. Now, we should build the following proof for 
							%
						%${\ireduce{\adelta_0\cdots\adelta_{h+1}}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l]} \ $
					%\[
						  %\mathrulean{\lemref{lemma:reduce}}
						  %{
								%\ireduce{\adelta_0\cdots\adelta_{h}}\triangleleft  \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l - 1]
								%\quad 
								%\adelta[_{h+1}] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l] 							
							%}
  						%{\ireduce{\adelta_0\cdots\adelta_{h+1}}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l]}  
					%\]
							%\item[9.] By \propref{prop_outserver}, we know that for all natural $m$, such that $0 \leq m \leq |\outserver(i)|$ then $\outserver(i)[m] \triangleleft \queuemessage[\tknown + \treceivebuffer - 1 + m]$. Now, $|\outserver(i)|$ was decremented by one, however, this property holds.
						%\end{itemize}
					%
				
				
				%
					%
						%
%\item {\bf rule (\textsc{t-process})} If $A \arroi{\tau} A'$, then by rule (\textsc{\footnotesize{t-process}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\tsenthead] \cdot \tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage \cdot \tsenthead}$. Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. Analyzing cases:
					%
					%
					%
					%\begin{itemize}
						%\item If $\beta \ \in\ E_{i}.\outclient$ then, by rule (\textsc{\footnotesize{comm-client-server}}), $C \arroi{\tau} C'$, so that, $C'$ = $\clientr{P}{\update{E}{\outclient}{\tailround}} \bigpar\ \tilde{C} \ \bigpar\ \ \server{\state}{\update{\inserver}{i}{\headerround}}{\outserver}_C$ and $\delta_0 \triangleleft \beta$. Performing a new internal action by rule (\textsc{\footnotesize{batch}}),i.e., $C' \arroi{\tau} C''$, then $C''$ = $\server{\apply{\persistedstate}{d}}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}  \bigpar\ \tilde{C} \bigpar \clientr{P}{\stateclient}$. We have to prove that $(A',C'')$ belongs $\mathcal{R}$.
						%
						%\begin{enumerate}
							%\item Theirs terms do not change.
							%\item Our hypothesis is $\queuemessage_C.\state \triangleleft \queuemessage_A$ besides $\delta_0 \triangleleft \beta$, then using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item $\queuemessage_A$  has incremented by one, so that, by Hypothesis, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$, besides, $\Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$ because of neither $E_{i}.\inclient$ nor $\queuemessage_C.\outserver$ have changed.
%\item By Hypothesis, for all element in $\tsent$, those belongs to $E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$, in particular, $\tsent$ without a element keeps these guarantee.
						%\end{enumerate}
%\item If $\beta \ \in\ E_{i}.\inserver$ then, applying rule (\textsc{\footnotesize{batch}}), we can see that we are at above case.
					%\end{itemize}
					
\end{itemize}

%
%We have prove that if $A$ perform an action, $C$ also can perform an action, the terms after both transitions are in $\mathcal{R}$. Now, we will prove the opposite side. When $C$ perform an action, then A can perform an action and the news terms are in $\mathcal{R}$.
%
%
%\begin{itemize}
   %\item{\bf n=0}. Then $C$ = $\clientr{E}{\initialstate}$ and $A$ = $\tsystem{\tclienti{0}{\emptyset}{\emptyset}{\emptyset}{\emptyset}{0}\ \bigpar\ \tilde{A}}{\queuemessage_A}$. It is analogous to the base case previously proved.
			%
   %\item{\bf n=k+1}. $\forall (C,A) \ \in \ \mathcal{R}$
	%
			%
			%\begin{itemize}
				%\item {\bf rule (\textsc{comm-server-client})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-server-client}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		%\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					%\begin{enumerate}
						%\item to 6. Their terms do not changed.
						%\setcounter{enumi}{6}	
							%\item $l'$ = $(|E_{i}.\inclient| + 1)$, so that, we have to prove that $E_{i}.\inclient[l'] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 + l']$, however, it easy to see because by property 10. when $m$ = 0 then $\outserver(i)[0] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient|]$.
						%\item It is easy to see that $(|E_{i}.\inclient| + 1) + (|\queuemessage_C.\outserver|-1) > 0$.
						%\item It does not change.
						%\item It is easy to see, because, Property 10 is guaranteed with $0 \leq l$ therefore $1 \leq l$. 
					%\end{enumerate}
					%
					%
				%\item {\bf rule (\textsc{comm-client-server})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-client-server}}), $C'$ must be the following term: $\server{ps'}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}$, therefore, the client $i^{th}$ is the only one who has changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.				
					%\begin{enumerate}
						%\item to 8. Their terms do not changed.
						%\setcounter{enumi}{8}	
						%\item It is easy to see, because, we have exchanged a sequence from $\outclient$ to $\inserver$. 
						%\item It does not change.
						%\end{enumerate}
				%
%
%
				%
						%\item {\bf rule (\textsc{batch})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{batch}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		%\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. Hence	$(C,A)$ belongs to $\mathcal{R}$ then $A$ after of internal transition $\tau$ is $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ S_C}{\queuemessage \cdot \tsenthead}$. We will prove that $(C',A') \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.	
				%\begin{enumerate}
						%\item Their terms do not change.
						%\item Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. In particular, we consider $\beta \ \in \ \queuemessage_C.\inserver$, then there exists $\delta_o$ such that $\delta_0 \triangleleft \beta$, besides by Property 2., $\queuemessage_C.\state \triangleleft \queuemessage_A$, so that using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item $\queuemessage_C.\outserver$ is updated with the new persisted state however its size does not change. By Hypothesis 9, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$.
							%\item It does not change.
							%\item It does not change.
%
						%\end{enumerate}
		%
%
				%
			%\end{itemize}
		%\end{itemize}
		
\end{proof}
