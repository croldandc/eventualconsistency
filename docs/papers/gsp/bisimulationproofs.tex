% !TEX root = main.tex

\section{Proof of results in \secref{sec:simulation}}



\begin{lemma}\label{lemma:apply} $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ iff $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.
\end{lemma}

\begin{proof} $\Rightarrow)$ The only possible derivation for $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq$ is

\[
   \mathrulean{\triangapply}
  		{ \astate \triangleleft \anupdseq['] \qquad\qquad
	   		\mathrulean{\triangreduce}
   				{\adelta[_1] \triangleleft \anupdseq[_1] \ldots \adelta[_n] \triangleleft \anupdseq[_n]}
				{\ireduce {\adelta[_1] \cdots \adelta[_n]} \triangleleft \anupdseq[_1] \cdots \anupdseq[_n]}	  
		}
		{\iapply \astate {\ireduce{\adelta[_0]\cdots\adelta[_n]}}  \triangleleft  \anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]}
\]
and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.



$\Leftarrow)$ Follows analogously. 
\end{proof}


\begin{lemma}\label{lemma:reduce} $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]\cdot \adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\ireduce{\adelta[_0]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq[']$ $\adelta[_n] \triangleleft \anupdseq['']$.
\end{lemma}

\begin{proof} $\Rightarrow)$ The only possible derivation for $\ireduce {\adelta[_1] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq$ is

\[
   \mathrulean{\triangreduce}
  					{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]\qquad\qquad
	   		\adelta[_n] \triangleleft \anupdseq[_n]  
		}
		{\ireduce {\adelta[_0] \cdots \adelta[_{n-1}] \cdot \adelta[_{n}]} \triangleleft \anupdseq[_0]\cdots\anupdseq[_{n-1}] \cdot \anupdseq[_n]}	
\]
Hence, $\anupdseq['] = \anupdseq[_0]\cdots\anupdseq[_{n-1}]$ and $\anupdseq[''] = \anupdseq[_n]$. The proof is completed by using rule \ruleName{\triangreduce} on
$\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]$.

 \[  \mathrule{\triangreduce}
   		{\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_{n-1}] \triangleleft \anupdseq[_{n-1}]}
		{\ireduce {\adelta[_0] \cdots \adelta[_{n-1}]} \triangleleft \anupdseq[_0] \cdots \anupdseq[_{n-1}]}
\]
 
%and $\anupdseq =\anupdseq['] \cdot \anupdseq[_1] \cdots \anupdseq[_n]$. By  rule \ruleName{\triangapply} on the premises of the 
%above proof, we conclude that  $\iapply{\astate}{\adelta[_0]\cdots\adelta[_n]}\triangleleft \anupdseq$.

$\Leftarrow)$ Follows analogously. 
\end{proof}

\begin{lemma}\label{lemma:reducefirst} $\ireduce{\adelta[_0]\cdot\adelta[_1]\cdots\adelta[_n]}\triangleleft \anupdseq$ iff  $\anupdseq = \anupdseq[']\cdot\anupdseq['']$, $\adelta[_0] \triangleleft \anupdseq['], \ireduce{\adelta[_1]\cdots\adelta[_{n}]}\triangleleft \anupdseq['']$.
\end{lemma}


\begin{lemma}\label{lemma:reduceinreduce} $\ireduce{\adelta[_0]\cdots\ireduce{\adelta['_{0}]\cdots\adelta['_{m-1}]}\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$ iff $\ireduce{\adelta[_0]\cdots\adelta['_0]\cdots\adelta['_{m-1}]\cdots\adelta[_{n-1}]}\triangleleft \anupdseq$

\end{lemma}

%\begin{itemize}
%	\item On $\mathit{Delta} \times \mathit{Update}^*$, let $\triangleleft$ be the smallest relation such that (1) $\emptydelta \triangleleft []$, and
%(2) $d \triangleleft a$ implies $append(d,u) \triangleleft a \cdot u$ for all updates $u$, and (3) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $reduce(d_1 \ldots d_n) \triangleleft a_1 \cdots a_n$ and (4) $d_1 \triangleleft a_1 \ldots d_n \triangleleft a_n$ implies $\remove{d_1 \ldots d_{n}}{d_n} \triangleleft a_1 \cdots a_{n-1}$. \marginpar{El (4) lo agregamos nosotros. Â¿Se aclara? Â¿C\'omo?}
%  
%\item On $State \times Update^*$, let $\triangleleft$ be the smallest relation such that (1) $\initialstate \triangleleft []$, and
%(2) $s \triangleleft a \land \ d_1 \triangleleft a_1 \land \ \ldots \ \land \ d_n \triangleleft a_n$ implies $apply(s,d_1 \ldots d_n) \triangleleft a \cdot a_1 \cdots a_n$.
%\end{itemize}
%
% 


\begin{lemma}\label{lemma:storechanged} Let $\adelta[_0]\cdots\adelta[_{n-1}]$ a delta sequence, such that, $\adelta[_0] \triangleleft \anupdseq[_0] \ldots \adelta[_0] \triangleleft \anupdseq[_n]$ and the following relation $\astate \triangleleft \anupdseq$ then $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_n]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_n]$
\end{lemma}

\begin{proof} The proof follows by induction on the length of the sequence.

\begin{itemize}
   \item{\bf n=0}. It is easy to see that $\iapply{\astate}{\ireduce{\emptydelta}}\triangleleft \anupdseq$ is $\astate \triangleleft \anupdseq$.
   \item{\bf n=k+1}. Then, our inductive hypothesis is $\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_k]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_k]$, we should build the following proof for 
							
						$\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_{k+1}]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_{k+1}] \ $
					\[
						  \mathrulean{\lemref{lemma:apply}}
						  {
								\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_k]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_k]
								\quad \quad 
								\anupdseq[_{k+1}]\triangleleft\anupdseq[_{k+1}] 							
							}
  						{\iapply{\astate}{\ireduce{\adelta[_0]\cdots\adelta[_{k+1}]}}\triangleleft \anupdseq \cdot \anupdseq[_0]\cdots\anupdseq[_{k+1}]}  
					\]
	

\end{itemize}


\end{proof}




\begin{proof} [of ~\thmref{thm:simulation}]
 We show that the following relation is a weak simulation.
\[
\mathcal{R} = \{ (\isystemterm, \systemterm) \ |\ \implements{\isystemterm{}}{\systemterm} \}
\]


%Let $A$ be a system from abstract GSP Protocol, defined as  then both system are weakly bisimilar, written $A \approx C$, if $(A,C)  \in \ \mathcal{R}$, where $\mathcal{R}$ be a binary relation defined as $\{ (\parallel_{i \ \in\ I_{\{0 \ldots n\}}} A_i \parallel \ \queuemessage_A),(\parallel_{i \ \in\ I_{\{0 \ldots n\}}} C_i \parallel \ \queuemessage_C) \ | \ \forall i \ \in\ \nat, \forall r: \readtype, A_i = \ \tclient{\tprogram_i}{\tknown_i}{\tpending_i}{\ttransactionbuffer_i}{\tsent_i}{\treceivebuffer_i} \land C_i = \client{P_i}{\stateclient_i}$ and the conjunction of the following properties: %\land \ \rvalue{r}{\flatten(\queuemessage_{A}[0..\tknown-1] \cdot \tpending) \cdot \ttransactionbuffer} = \readp{r}{\curstate{E_{i}.\known}{E_{i}.\pending}{E_{i}.\pushbuffer}{E_{i}.\transactionbuffer}} \land \ \queuemessage_C.\state \triangleleft \queuemessage_A \land \ E_{i}.\transactionbuffer = [\ttransactionbuffer_i] \land \ E_{i}.\receivebuffer[0].delta \triangleleft \queuemessage_A[\tknown_i] \ldots\ E_{i}.\receivebuffer[j - 1].delta \triangleleft \queuemessage_A[\tknown_i + \treceivebuffer_i] - 1 \ \land \ E_{i}.known \triangleleft \queuemessage_A[0 \ldots \tknown_i - 1] \ \land \  E_{i}.\pending \cdot E_{i}.\pushbuffer \triangleleft \tpending_i \ \land \ \forall l, 1 \leq l < |\inclient|, E_{i}.\inclient[l] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 +l] \ \land \ \tknown + \treceivebuffer + 1 \leq |\queuemessage_A| \Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0 \ \land \ \forall \beta \ \in \ \tsent_i, \beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver
%\marginpar{Ac\'Ã¡ deber\'ia decir que R cumple las propiedades de weak bisimulation. C\'omo lo escribo mejor?}


%The proof follows by induction on the length of the derivation $\arro{} ^*$.
 %We use $\tilde{A}$ and $\tilde{C}$ to denote clients, except client $i^{th}$, interacting concurrently, i.e., $\parallel_{j \ \in\ I_{\{0 \ldots n\} - i}}$ $A_j$ or $C_j$ respectively.

\begin{itemize}
   
	
   \item%{\bf n=k+1}. $\forall (\isystemterm ,\systemterm ) \ \in \ \mathcal{R}$
   
  % \henote{Para no escribir $\mathcal{R}^{-1}$ podemos cambiar la definici\'on $\mathcal{R}$}
		
			
			\begin{itemize}
%				\item {\bf rule (\textsc{t-read})}. If $\systemterm  \arroi{\readtran{r}} \systemterm '$, then by rule (\textsc{\footnotesize{t-read}}), $\systemterm $ must be the following term: 
%				$\tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				, therefore, the client $i^{th}$ is the only one who have changed. So that, $\systemterm'$ is 
%				$\tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}$
%				. As $(\systemterm,\isystemterm)$ belongs $\mathcal{R}^{-1}$ then $\isystemterm$ must be $\clientr{\readins{x}{r}}{\stateclient} \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$, and the read transition is the only one that $\isystemterm$ can perform.
%				Then by rule (\textsc{read}), $\isystemterm' = \clientr{\update{P}{x}{v}}{\stateclient}\ \bigpar\ \tilde{C} \ \bigpar\ \ \queuemessage_C$. We will prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}^{-1}$ if the ten properties introduced are keeping.
\item {\bf rule \ruleName{i-update}}. Then, $\isystemterm  \arroi{\updatetranaux{\anupd^{\vertice[@][']}}} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	
				  \end{array}
				\]
				
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\systemterm = \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. 
				By  using rule \ruleName{update}, 
				$\systemterm \arroi{\updatetran{u}} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
						\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  \end{array}		
				\]
				.
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$.
				Note that the only terms that have changed are the transaction buffers 
				$\ttransactionbuffer$ and $\ttransactionbuffer$	corresponding to the client $\cid$. 	
				Therefore, we only check that condition \refprop{prop_transactions}
				hold for client $\cid$.
					\begin{enumerate}
						\item[\ref{prop_transactions}.] Since 
						$\implements{\isystemterm}{\systemterm}$, it holds that 
						$\transactionbuffer \triangleleft{\ttransactionbuffer}$ by \refprop{prop_transactions}. 						
						Then, $\iappend{\transactionbuffer}{u} \triangleleft \ttransactionbuffer \cdot \tupdate$ holds by
						rule \ruleName{\triangappend}.

%						We can build the following proof for 
%						$\iappend{\transactionbuffer}{u}
%						\triangleleft 
%						\ttransactionbuffer \cdot \tupdate$
%						\[
%						  \mathrulean{\triangappend}
%						      {
%						      \transactionbuffer \triangleleft{\ttransactionbuffer}
%						      }
%  						{\iappend{\transactionbuffer}{u}]
%						\triangleleft 
%						\ttransactionbuffer \cdot \tupdate}  
%					\]

%						 \chnote{Esta prueba es m\'as inmediata, creo que aca no haria falta mostrar el detalle ya que es solo un paso. Con mencionar la regla del append tiene que alcanzar, lo dejo por si preferis que quede asi.}.

						%\item[{--}] The remaining properties straightforwardly hold.
						

					\end{enumerate}


\item {\bf rule \ruleName{i-push}}. Then, $\isystemterm  \arroi{\pushtran} \isystemterm '$ with 

				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpushins]} \ \bigpar \ \isystemterm[''] 
					\\
					\isystemterm['] & {\addid{\iclientinst[P][@][@][\ireduce{\pushbuffer\cdot \transactionbuffer}][\epsilon][@][\irounds+1]}\ \bigpar \ \isystemterm['']}
				  \end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				$ \tsystem{\tclienti{\tpushins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] $
				with $\implements{\isystemterm['']}{\systemterm['']}$. 
				
				By using rule \ruleName{push}, 
				$\systemterm \arroi{\pushtran} \systemterm[']$ with
				
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending \cdot \ublock[\ttransactionbuffer]}{\emptydelta}{\tsent \cdot \ublock[\ttransactionbuffer]}{\treceivebuffer}[@][\trounds+1]}[{\systemterm['']}]\\
				  \end{array}		
				\]
								
				We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$.
				Since the computations involve only client $\cid$, we only need to check that  properties in \defref{def:implementation} still hold for $\cid$.		
					
					\begin{enumerate}
					
						\item[\ref{prop_transactions}.] It  holds since $\medskip\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}.
						 
						\item[\ref{prop_sent}.] There are two cases:
						
						\begin{itemize}
			
						\item $\cid\in\dom\inserver$:  
						 Since $\implements{\isystemterm}{\systemterm}$, 
						 $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
						 and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
						 By $\lemref{lemma:reduce}$, $\flatten{\tsent} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
						 $\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$. 
						 Then, we build the following proof 
						% \[\ireduce{\igetdeltas{\inserver(\cid)}\cdot\ireduce{\pushbuffer\cdot \transactionbuffer}} \triangleleft \ \flatten{{\tsent}\cdot[\ttransactionbuffer]}\]
						 {\scriptsize
						\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {
						  \ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1] 
						  \quad
						  \mathrulean{\triangreduce}
						    	{\pushbuffer \triangleleft {\anupdseq[_2]}
								\quad
								\transactionbuffer \triangleleft \ttransactionbuffer}
  							{\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft \anupdseq[_2]\cdot\ttransactionbuffer}  
							}
							{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\ireduce{\pushbuffer\cdot \transactionbuffer}} \triangleleft \ \anupdseq[_1]\cdot(\anupdseq[_2]\cdot \ttransactionbuffer)}
						\]}

						 The proof is completed by noting that $\anupdseq[_1]\cdot(\anupdseq[_2]\cdot \ttransactionbuffer) = \flatten{{\tsent}\cdot[\ttransactionbuffer]}$.
						 \medskip
						 
%						  Then $\implements{\isystemterm}{\systemterm}$ by hypothesis. is that $\tsent$ = ${\tsent}_h \cdot {\tsent}_t $ and $ {\pushbuffer}_l\ \triangleleft \ {\tsent}_t$ 
%						 and $\ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h$. Now, $\tsent$ and $\pushbuffer$ 
%						 have changed, in particular ${\tsent}_t $ has a new block. $\inserver$ has not changed. 
%						 We should build the following proof for $\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft {\tsent}_t\cdot\ttransactionbuffer \ $.
%						\[
%						  \mathrulean{\lemref{lemma:reduce}}
%						  {\pushbuffer \triangleleft {\tsent}_t
%								\quad
%								\transactionbuffer \triangleleft \ttransactionbuffer}
%  						{\ireduce{{\pushbuffer}\cdot \transactionbuffer}\triangleleft {\tsent}_t\cdot\ttransactionbuffer}  
%					\]
%						Then, this property holds.

						\item  \textcolor{red}{$\cid\notin\dom\inserver$: 
						 Since $\implements{\isystemterm}{\systemterm}$, 
						 $\pushbuffer \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
						 and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
						 Then, we build the following proof 
%						\[\ireduce{\pushbuffer\cdot \transactionbuffer} \triangleleft \ \flatten{{\tsent}\cdot[\ttransactionbuffer]}\]
						\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {
						  \igetdeltas{\inserver(\cid)} \triangleleft \ \anupdseq[_1] 
						  \quad
						 \transactionbuffer \triangleleft \ttransactionbuffer}
  						 {\ireduce{\pushbuffer\cdot \transactionbuffer} \triangleleft \ \anupdseq[_1]\cdot\ttransactionbuffer}
						\]
						The proof is completed by noting that $\anupdseq[_1] = \flatten{{\tsent}}$.
						}
						\end{itemize}
						
						
						
						
						\item[\ref{prop_pending}.] 	Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by \refprop{prop_transactions};  
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending}$ by  \refprop{prop_pending}.
						\end{itemize}
						We know that $\flatten{\tpending\cdot [\ttransactionbuffer]}$ = $\flatten{\tpending} \cdot \ttransactionbuffer$.
						 Then, we  build the following proof 
						$\ireduce{\igetdeltas{\pending}\cdot\ireduce{{\pushbuffer}\cdot \transactionbuffer}}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}$
						 

					\[
					   \mathrulean{\lemref{lemma:reduceinreduce}}
					   {
						  \mathrulean{\lemref{lemma:reduce}}
						  {\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
						    \quad
						    \transactionbuffer \triangleleft \ttransactionbuffer}
  						{\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}\cdot \transactionbuffer}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
					   }
					   {\ireduce{\igetdeltas{\pending}\cdot\ireduce{{\pushbuffer}\cdot \transactionbuffer}}\triangleleft \flatten{\tpending\cdot [\ttransactionbuffer]}}  
					\]
					
						
						\item[\ref{prop_size_buffersent}.] It trivially holds since in both cases the counters are incremented by one. \chnote{Esta hipotesis sospechamos que sobra.}
								
					\end{enumerate}
 The remaining properties straightforwardly hold.
						

\item {\bf rule \ruleName{i-send}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient['']\ \\
					\isystemterm['] & \addid{\iclientinst[@][@][\pending \cdot \around][\emptydelta]}
		\ \bigpar \ \iserverins[{\astate[']}][@][\inserver\upd{\cid}{\inserver(\cid)\cdot\around}]
		\ \bigpar\ \iclient[''] \\
					\around & \aroundtuple[\cid][\nround][\pushbuffer]
					\end{array}
				\]
				
				Then, we take $\systemterm'=\systemterm$ and 							
				  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$. Since the changes only affect 
				  client $\cid$ and the input buffer for $\cid$  on the server, we need to check that properties in \defref{def:implementation}
				  still hold for $\cid$.			

						\begin{itemize}
						
							\item[\ref{prop_sent}.] $\around = \aroundtuple[\cid][\nround][\pushbuffer]$. 
							%and $\igetdeltas{\inserver(\cid)} = \adelta[_0] \cdots \adelta[_{n-1}]\cdot\pushbuffer$ where the $n$ first deltas belonged to $\inserver(\cid)$ before the send transition.  
							Since $\implements{\isystemterm}{\systemterm}$,  $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{{\tsent}}$ 
							holds by \textcolor{red}{\propref{prop_sent}}. 
														%Since the hypothesis of the rule states that $\cid\in\dom\inserver$,
							 We need to prove that
							\[\ireduce{\igetdeltas{\inserver(\cid)\cdot \around}\cdot \emptydelta} \triangleleft \ \flatten{\tsent} \]
							
							Note that $\igetdeltas{\inserver(\cid)\cdot \around} = \igetdeltas{\inserver(\cid)}\cdot\pushbuffer$. Then,
							\[
						  	\mathrulean{\lemref{lemma:reduce}}
						  	{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\pushbuffer} \triangleleft \ \flatten{\tsent}
								\quad
								\emptydelta \triangleleft \epsilon}
  							{\ireduce{\igetdeltas{\inserver(\cid)}\cdot\around\cdot\emptydelta} \triangleleft \ \flatten{\tsent}}  
							\]
							
							
							%We have moved the ${\pushbuffer}$ to $\inserver(\cid)$, leaving in the push buffer, $\emptydelta$. Furthermore, ${\tsent}_t$ is $\epsilon$. By \triangemptydelta this part of the property holds. 	
						%	We build the following proof for 
						%$\ireduce{\igetdeltas{\inserver(l)}\cdot \pushbuffer} \triangleleft \ {\tsent}_h \cdot {\tsent}_t$
						%\henote{Aca no es cualquier l, es la identidad dle cliente que se movio. Revisar con la nueva formulacion}
					%\[
					%	  \mathrulean{\lemref{lemma:reduce}}
					%	  {\ireduce{\igetdeltas{\inserver(l)}} \triangleleft \ {\tsent}_h
					%			\quad
					%			\pushbuffer \triangleleft {\tsent}_t}
  					%	{\ireduce{\igetdeltas{\inserver(l)}\cdot \pushbuffer} \triangleleft \ {\tsent}_h \cdot {\tsent}_t}  
					%\]
					%\henote{estas usando $\delta_p$ en lugar de $\pushbuffer$, gran lio si cambiamos las macros}.
			
							\item[\ref{prop_pending}.] By hypothesis, $\pending = \aroundtuplei[0]\ldots\aroundtuplei[h]$ and  
							$\ireduce{\adelta_0\cdots\adelta_h\cdot\pushbuffer} \triangleleft \flatten{\tpending}$.
							 Since $\pending \cdot \around = \aroundtuplei[0]\ldots\aroundtuplei[h]\cdot{\aroundtuple[@][@][\pushbuffer]}$,
							we need to prove that  $\ireduce{\adelta_0\cdots\adelta_h\cdot\adelta_p\cdot\emptydelta} \triangleleft \flatten{\tpending}$. 
							It holds by using \lemref{lemma:reduce}, and the fact that $\emptydelta \triangleleft \epsilon$.
							%It is easy to see that it is the same relation that our hypothesis, since $\adelta_p$ was moved to the pending sequence. Therefore this property also holds.
						\item[{--}] The remaining properties straightforwardly hold.
							
						\end{itemize}


\item {\bf rule \ruleName{receive}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{\  =\  }l}
					{\isystemterm} & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate[']] \ \bigpar\ \iclient['']
					\\
					{\isystemterm[']} & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient['']
					\\
					\outserver(\cid) & \aseg\cdot\aseqseg
					
				  \end{array}
				\]

				Moreover, 
				\[\systemterm = \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\queuemessage\ \bigpar\ \Absclient'' }]. \]
			
			
				Since $\implements{\isystemterm}{\systemterm}$, \refprop{prop_inclient} holds. We have three cases:
				\begin{itemize}
				
					\item  ${\inclient} = \agssegpairi[1] \cdots \agssegpairi[h']$, 
					
					$\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 

					\begin{equation}
					\label{eq:sim-receive-c1-c}
     					 \ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}  
					 \end{equation}
					 %
    					 \begin{equation}
					\label{eq:sim-receive-c1-d}
					\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft  \flatten{\queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1]}
					\end{equation}
	
	
	
					By $\lemref{lemma:reducefirst}$ on \equref{eq:sim-receive-c1-d}, 
					$\flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]$, 
					$\adelta_{h'+1} \triangleleft \anupdseq[_1]$ and 
					$\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \anupdseq[_1u] $.
					%					 
					Therefore, there exists $m \geq 0$ s.t. 
					 $\tknown+\treceivebuffer+m \leq  |\queuemessage| -1$ and 
					$\anupdseq[_1] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
					$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}$. Hence,
					%
					\begin{equation}
					\label{eq:sim-receive-c1-a}
					\adelta_{h'+1} \triangleleft \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}
					\end{equation}
					%
					\begin{equation}
					\label{eq:sim-receive-c1-b}
					 \ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}
					\end{equation}
					%	
				If $m=0$, then take $\systemterm['] = \systemterm$. Otherwise, note that $\tknown+ \treceivebuffer + m < |\queuemessage|$  allows
				for  $m$ applications of rule \ruleName{send}. Hence,  
				$\systemterm \arroi{\tau}\cdots\arroi{\tau} \systemterm[']$ 
				with
				\[\begin{array}{r@{=}l}
						\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+m}}[{\queuemessage\ \bigpar\ \Absclient'' }]	
				  \end{array}		
				\]
				
				We check now that  $\implements{\isystemterm[']}{\systemterm[']}$. Since the unique elements that are modified by the reductions 
				are $\inclient$, $\outserver(\cid)$ and $\treceivebuffer$, we  only need to check that \refprop{prop_inclient} still holds for client $\cid$.
				
				\begin{itemize}
				
					\item[\ref{prop_inclient}.] Take ${\inclient'} = \agssegpairi[1] \cdots \agssegpairi[h']\cdot\agssegpairi[{h'+1}]$ and
					
					 $\outserver(\cid)' = \agssegpairi[h'+2] \cdots \agssegpairi[h]$. We prove that
					\[\ireduce{\adelta_1\cdots\adelta_{h'+1}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]}\]
					by using \lemref{lemma:reduce} with the hypothesis \equref{eq:sim-receive-c1-c} and \equref{eq:sim-receive-c1-a}, \ie,
										
%					Since $\implements{\isystemterm}{\systemterm}$,  \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}
%					By $\lemref{lemma:reduce}$, $\flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
%						$\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$ with
%						$\anupdseq[_1] = \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}$,
%						$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
%						 Then, we can build the following proof 
						{\small 
						\[
						  \deduce%{\lemref{lemma:reduce}}
						       {%\label{eq:sim-receive-c1-c}
     					 \ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]} 
							\quad
							\adelta_{h'+1} \triangleleft \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}}
  						       {\ireduce{\adelta_1\cdots\adelta_{h'+1}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer+m-1]}}  
						\]
						}
						
						
					Note that
					$\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \flatten{\queuemessage[\tknown+\treceivebuffer+m..|\queuemessage| - 1]}$
					also holds because of \equref{eq:sim-receive-c1-b}

					


%					
%					
%					By $\lemref{lemma:reducefirst}$, $\flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
%					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]$ and 
%					$\adelta_{h'+1} \triangleleft \anupdseq[_1]$, with 
%					$\anupdseq[_1] = \flatten{ \queuemessage[\tknown+\treceivebuffer..\tknown+\treceivebuffer+m-1]}$,
%					$\anupdseq[_2] = \flatten{ \queuemessage[\tknown+\treceivebuffer+m .. |\queuemessage| -1]}$,
%					Then, we can build the following proof 
%						 
%					\[
%						  \mathrulean{\lemref{lemma:reducefirst}}
%						       {\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft \anupdseq[_1]\cdot\anupdseq[_2]
%							\quad
%							\adelta_{h'+1} \triangleleft \anupdseq[_1]}
%  						       {\ireduce{\adelta_{h'+2}\cdots\adelta_h}\triangleleft \anupdseq[_2]}  
%					\]
%					
%			%		\flatten{ \queuemessage[\tknown+\treceivebuffer..m-1]}$. Then,
%
					
							
					\end{itemize}	
					
					
				\item ${\inclient} = \agssegpair[{\astate[']}]\cdot\agssegpairi[{z+1}] \cdots \agssegpairi[h']$, 
              				  $\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, the case follows analogously to the previous case.
				  \henote{Seguro? las hipotesis son bastante distintas. Por otro lado, dudo de la caracterisaci\'on en la def}
     		%$\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$,
               %$\astate['] \triangleleft \queuemessage[0 .. t - 1]$ and $t \leq \tknown_l+\treceivebuffer_l$; 


					
					\item  ${\inclient} = \epsilon$, 
     					          $\outserver(\cid) = \agssegpair[{\astate[']}]\cdot\agssegpairi[z+1] \cdots \agssegpairi[h]$, 
     						   $\astate['] = \iapply{\initialstate}{\ireduce{\adelta_1\cdots\adelta_{z}}}$
      						   $\astate['] \triangleleft \queuemessage[0 .. l - 1]$ and $\tknown+\treceivebuffer \leq l$;  
					then $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{h}]}}\triangleleft \flatten{\queuemessage}$. 
					Since $\astate['] = \iapply{\initialstate}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$, then $\astate[']\triangleleft \queuemessage[0..l-1]$ with $r = l - \tknown - \treceivebuffer$, besides $r \leq l < |\queuemessage|$.  Hence,
				
				\[\systemterm = \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. As $\tknown+ \treceivebuffer + r < |\queuemessage|$ then by inspection of rules in 				\figref{fig:OS-tgsp}, 
				$\systemterm \arroi{\tau}\cdots\arroi{\tau} \systemterm^{r}$ with $r$ internal transitions. Then,
				\[\begin{array}{r@{=}l}
						\systemterm^{r} & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+r}}[{\systemterm['']}]	
				  \end{array}		
				\]
				
				Furthermore,
				$\systemterm^{r} \arroi{\tau} \ldots\ \arroi{\tau} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer + r + m}}[{\systemterm['']}] \\
				  \end{array}		
				\]


				$m$ represents the amount of internal transition that performed by client $\cid$ to reach $\iapply{\astate[']}{\ireduce{\adelta[_1]\cdots\adelta[_{z}]}}$. Hence, $m =  |\queuemessage| - l - 1$ which always is $< |\queuemessage|$.   


								
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{itemize}	
	
					\item[\ref{prop_inclient}.] It easy to see because the segment from $\outserver(\cid)$ was moved to $\inclient$ holdings the hypothesis.
					
					
					\item[{--}] The remaining properties straightforwardly hold.
							
				\end{itemize}	
	
					
							
				\end{itemize}
% \item ${\inclient}_l = \agssegpairi[1] \cdots \agssegpairi[h']$, $\outserver(\cid_l) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$; 
 %    \linebreak
  %    $\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft  \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l-1])$; and $\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft 
   %    \queuemessage[\tknown_l+\treceivebuffer_l..|\queuemessage| - 1])$

				
%				\chnote{Si bien es obvio, lo pregunto. No estamos poniendo como hipotesis que i pertenece al outserver. Se infiere con la hipotesis, pero no es necesario?}
%				\henote{se puede agregar, no da\~na igual las pre no se evaluan en ningun orden, uno tuviese que decir con implicaicones y queda feo}
				

%				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
%				by checking the properties in \defref{def:implementation}.			



%						\begin{itemize}
%							\item[\ref{prop_inclient}.] It is immediate that this property holds because we move a segment from $\outserver(i)$ to $\inclient(i)$.
							
							
%						\item[{--}] The remaining properties straightforwardly hold.

%						\end{itemize}
					
	
	\item {\bf rule \ruleName{i-pull${_1}$}}. Then, $\isystemterm  \arroi{\pulltran} \isystemterm '$ with 
	
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@]
						[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						[@][@][@][n]}
								\ \bigpar  \ {\iserverins[\astate[']]} \ \bigpar\ \iclient[']				\\
					\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_{h'}]}][{\amxrf[_{h'}]}]
					\\
					\outserver(\cid) & \agssegpair[{\adelta[_{h'+1}]}][{\amxrf[_{h'+1}]}]\ldots \agssegpair[{\adelta[_{h'}]}][{\amxrf[_{h'}]}]
					\\
					\isystemterm['] & \addid{\iclientinst[P]
						 [\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}][n][\epsilon]}\  \bigpar  \ {\iserverins[\astate[']]} \ \bigpar\ \iclient[']
					\\
					\aseqround['] & \filter{\amxrf[_k](\cid)}{\aseqround} 
					\\
				  \end{array}
				\]
		
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\queuemessage}\ \bigpar\ \Absclient[']] \]
				
				
				By rule  \ruleName{pull}, 
				$\systemterm\arroi{\pulltran} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  
					\tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown +
						 \treceivebuffer  {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\queuemessage\ \bigpar\ \Absclient[']}]	
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$. 
				Since the reduction only affects the client $\cid$, we only need to check
				that  properties in \defref{def:implementation} still hold for $\cid$.	
									\henote{Agregar en el texto principal que $\ireduce{\epsilon} = \emptydelta$}

					\begin{enumerate}
					\item[\ref{prop_inclient}.] If follows because $\ireduce{\epsilon} = \emptydelta$,
					$\flatten{\queuemessage[\tknown+\treceivebuffer .. \tknown+\treceivebuffer + 0 - 1]} = \epsilon$ and 
					 $\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}.
					 
					\item[\ref{prop_state_known}.]  By \refprop{prop_state_known}, we know that $\known\ \triangleleft\ \flatten {\queuemessage[0..\tknown-1]}$. 
					By \refprop{prop_inclient},  $\ireduce{\adelta[_1]\cdots\adelta[_{h'}]}\triangleleft \queuemessage[\tknown ..  \tknown + \treceivebuffer - 1]$. 
					Then, we can derive 
		%				$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}\triangleleft \flatten{\queuemessage[0 .. \tknown+\treceivebuffer - 1]} \ $					\[
					\[	  \mathrulean{\triangapply}
						  {
							\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
							\quad 
							\ireduce{\adelta[_1]\cdots\adelta[_{h'}]}\triangleleft \queuemessage[\tknown ..  \tknown + \treceivebuffer - 1]
							}
						{\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_{h'}]}}\triangleleft \flatten{\queuemessage[0 .. \tknown +\treceivebuffer - 1]}}  
					\]
					
						\item[\ref{prop_pending}.] We have to prove that $\filter{\amxrf[_k](\cid)}{\aseqround} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$  
					
								$\cid\in\dom\inserver$ because $\inclient \neq \epsilon$
			
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@]
						[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						[@][@][@][n]}
								\ \bigpar  \ {\iserverins[\astate[']]} \ \bigpar\ \iclient[']				\\
					\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_{h'}]}][{\amxrf[_{h'}]}]
					\\
					\outserver(\cid) & \agssegpair[{\adelta[_{h'+1}]}][{\amxrf[_{h'+1}]}]\ldots \agssegpair[{\adelta[_{h}]}][{\amxrf[_{h}]}]
					\\
					\isystemterm['] & \addid{\iclientinst[P]
						 [\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_n]}}]
						 [\aseqround']
						 [@][@]
						 [{\receivebuffer}][n][\epsilon]}\  \bigpar  \ {\iserverins[\astate[']]} \ \bigpar\ \iclient[']
					\\
					\aseqround['] & \filter{\amxrf[_k](\cid)}{\aseqround} 
					\\
				  \end{array}
				\]
	
					
					${\transactionbuffer}\triangleleft{\ttransactionbuffer}$
					
%					$\pending= \aroundtuple[\cid][n'_1][\adelta'_1]\ldots \aroundtuple[\cid][n'_k][\adelta'_k]$  
					
					$\ireduce{\adelta_1'\cdots\adelta_h'\cdot {\pushbuffer}} \triangleleft \flatten{\tpending}$
					
					${\inclient}= \agssegpairi[1] \cdots \agssegpairi[h']$, 
					
					$\outserver(\cid) = \agssegpairi[h'+1] \cdots \agssegpairi[h]$, 
					
					$\ireduce{\adelta_1\cdots\adelta_{h'}}\triangleleft \flatten{ \queuemessage[\tknown..\tknown+\treceivebuffer-1]}$ and 
					
					
					$\ireduce{\adelta_{h'+1}\cdots\adelta_h}\triangleleft  \flatten{\queuemessage[\tknown+\treceivebuffer..|\queuemessage| - 1]}$
					
					$\pending = \aroundtuple[\cid][n_1][\adelta'_1]\ldots\aroundtuple[\cid][n_k][\adelta'_k]$ and for all $j\in\{1,\ldots,k\}$
      $\irounds_j \leq \amxrf_{h'}(\cid)$ implies $\adelta'_{j}\ \triangleleft\ \queuemessage[a..b]$ with $\tknown\leq a < b < \tknown+\treceivebuffer-1$.
       

					$\astate \triangleleft \flatten {\queuemessage[0 .. \tknown - 1]}$
					
					
					$\astate \triangleleft \flatten{\queuemessage}$
					
					\end{enumerate}




				\item {\bf rule \ruleName{read}}. Then, $\isystemterm  \arroi{\readtran{r}} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					v & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
					\end{array}
				\]
		
				Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				\[ \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\systemterm \arroi{\readtran{r}} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\\
					v' &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by property \ref{prop_state_known};
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						\end{itemize}
						
						Then, we can build the following proof for 
						$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						= 
						\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						\[
						  \mathrulean{\triangread}
						    {
								  \mathrulean{\lemref{lemma:apply}}
									{
										\mathrulean{\triangapply}
										{
										\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										\quad 
										\mathrulean{\lemref{lemma:reduce}}
											{
												\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												\quad
												\transactionbuffer \triangleleft \ttransactionbuffer
											}
											{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										}
										{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									}
									{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
								}
  						  {v'  = v}  
					\]
											
						\item[{--}] The remaining properties straightforwardly hold.
						

					\end{enumerate}

\item {\bf rule \ruleName{confirm}}. Then, $\isystemterm  \arroi{\confirmedtran} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm['']
					\\
					\isystemterm['] & \addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm['']	
					\\
					v & (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) 
				  \end{array}
				\]
		
		
				Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]\]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				$\systemterm \arroi{\confirmedtran} \isystemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}
		{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	\\
					v' & \eval{(\tpending \cdot  \ttransactionbuffer == \epsilon)}
				  \end{array}		
				\]
				
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.			
					\begin{enumerate}
						\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						$\implements{\isystemterm}{\systemterm}$, the following holds
						\begin{itemize}
							\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						\end{itemize}
						Then, we know that the value of $\pending \cdot \pushbuffer$ is related to $\tpending$, thereby, when $\pending$ or $\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has any elements.
			
					\end{enumerate}
	
	
	
	
	
	\item {\bf rule \ruleName{batch}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \iserverins\ \bigpar \ \iclient
					\\
					\isystemterm['] & {\iserverins[{\astate[']}][{\amxrf[{'}]}][{\inserver[']}][{\outserver[']}]}\ \bigpar \ \iclient \\
					\agssegpair[@][{\amxrf[{'}]}] &\receiveroundsname{\inserver} \\ %=\append{\emptygssegment}{rs} \qquad 
					\astate[']&\iapply{\astate}{\adelta} \\
					\forall\cid.(\outserver['] (\cid)& \outserver(\cid)\cdot\agssegpair[@][{\amxrf[{'}]}]) \\
					\forall\cid.(\inserver['](\cid) & \epsilon)
				  \end{array}
				\]
				
				

				Since $\implements{\isystemterm}{\systemterm}$, for all $\cid \in\dom{\inserver}$
				$\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{\tsent}$ (\refprop{prop_sent}) 
				and  $\transactionbuffer \triangleleft{\ttransactionbuffer}$ (\refprop{prop_transactions}). 
				By $\lemref{lemma:reduce}$, $\flatten{\tsent} = \anupdseq[_1]\cdot\anupdseq[_2]$, 
				$\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \ \anupdseq[_1]$ and $ {\pushbuffer}  \triangleleft \ \anupdseq[_2]$. 
			

				Then, $\sum_{\cid=1}^{m} |\anupdseq[_1]_{\cid}| = h$. Furthermore, $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_1]] \cdot [\anupdseq[_2]]}{\treceivebuffer}[1]}[]\cdots\ \bigpar \ 
		              \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_1]] \cdot [\anupdseq[_2]]}{\treceivebuffer}[m]}[\queuemessage] \]
				
				 $h$ is the amount of internal transitions performed by the system. The first one, corresponds to the first block of update from $\anupdseq[_1]$ of client 1. It is called $\tsenthead[_1]$. The following transitions correspond to the remaining blocks of update of $\anupdseq[_1]$ from client 1 and  $\anupdseq[_1]$ from the rest of clients.  Then, 
				 
				$\systemterm \tr{\tau}_1 \ldots\ \tr{\tau}_m \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm['] &  \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_2]]}{\treceivebuffer}[1]}[]\cdots\ \bigpar \ 
		              \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\anupdseq[_2]]}{\treceivebuffer}[n]}[] \queuemessage \cdot\tsenthead[_1]\cdots\tsenthead[_m]\ 
		              
				  \end{array}		
				\]

				 
			%	 In particular,  $h$ = $|\inserver|$, hence the implementation send a only delta ($\delta$), it is a reduction of segments in $\inserver$, the abstract model can send tantos bloques de updates como cantidad de segmentos usados para construir el delta.\chnote{cambiar explicacion en castellano}
				
				
				We  prove that $(\isystemterm',\systemterm[']) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
			
					\begin{enumerate}
						\item[\ref{prop_sent}.] For all client $\cid$, $\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \flatten{{\tsent}}$ holds. Then, $\igetdeltas{\inserver(\cid)}$ is $\emptydelta$ since $\inserver(\cid)$ = $\epsilon$ and $\anupdseq[_1]$ = $\epsilon$. It holds since $\medskip\emptydelta \triangleleft \epsilon$, by rule \ruleName{\triangemptydelta}. Furthermore, we know that $\pushbuffer\triangleleft\anupdseq[_2]$.  We can build the following proof
						\[ \mathrulean{\lemref{lemma:reduce}}
						  {
							\ireduce{\igetdeltas{\inserver(\cid)}} \triangleleft \anupdseq[_1]
							\quad 
							\pushbuffer\triangleleft\anupdseq[_2]
							}
						{\ireduce{\igetdeltas{\inserver(\cid)}\cdot {\pushbuffer}} \triangleleft \ \anupdseq[_1]\cdot\anupdseq[_2]}  
						\]
						
					      	\item[\ref{prop_inclient}.] For all $\cid$, $\outserver(\cid)$ has a new segment $ \agssegpair[@][{\amxrf[{'}]}]$ where $\adelta\triangleleft \tsenthead[_1]\cdots\tsenthead[_m]$. 
						Using $\lemref{lemma:reduce}$ and \refprop{prop_inclient} we build the following proof for 
						$\ireduce{\adelta_1\cdots\adelta_h\cdot\adelta} \triangleleft \ {\queuemessage}\cdot \tsenthead[_1]\cdots\tsenthead[_m]$
						\[
						  \mathrulean{\lemref{lemma:reduce}}
						  {
								\ireduce{\adelta_1\cdots\adelta_h}\triangleleft    \flatten{\queuemessage[\tknown+\treceivebuffer ..  |\queuemessage|- 1]}									\quad 
								\adelta \triangleleft  \tsenthead[_1]\cdots\tsenthead[_m]			
							}
  						{\ireduce{\adelta_1\cdots\adelta_h\cdot\adelta} \triangleleft \ \flatten{\queuemessage}\cdot \tsenthead[_1]\cdots\tsenthead[_m]}  
					\]
						\item[\ref{prop_stateserver}.] 
						
						Since $\implements{\isystemterm}{\systemterm}$, $\astate \triangleleft \flatten{\queuemessage}$ holds by \refprop{prop_stateserver}. Furthermore, $\adelta \triangleleft  \tsenthead_1\cdots\tsenthead_m$. Then, by \lemref{lemma:storechanged} we build the following proof for:
						
						\[
						  \mathrulean{\lemref{lemma:storechanged}}
						  {
							\astate \triangleleft \flatten{\queuemessage}
							\quad 
							\adelta \triangleleft  \tsenthead[_1]\cdots\tsenthead[_m]
							}
  						{\iapply{\astate}{\ireduce{\adelta}} \triangleleft \ \flatten{\queuemessage} \cdot \tsenthead[_1]\cdots\tsenthead[_m]}  
					\]
						
						\item[{--}] The remaining properties straightforwardly hold.
				\end{enumerate}

	\item {\bf rule \ruleName{pull-2}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[\tpullins][@][\aseqround][@][@][@][@][\inclient]}
			     \ \bigpar \ \iserverins[{\astate[']}][{\amxrf}] \ \bigpar\ \iclient
			              \\
			              						\inclient  & \agssegpair[{\astate[''']}][{\amxrf[_0]}]\cdot\agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]\\

					\isystemterm['] & \addid{\iclientinst[P]
						 [{\astate['']}]
						 [{\aseqround'}]
						 [@][@]
						 [{\receivebuffer}]}
						\ \bigpar \ \iserverins[{\astate[']}][{\amxrf}][\inserver\upd{\cid}{\inserver(\cid)\cdot\aseqround[']}]
						\ \bigpar\ \iclient \\
						
						
					       \astate['']  & \iapply{\astate[''']}	{\ireduce{\emptydelta\cdot\adelta[_1]\cdots\adelta[_k]}} \\	

						\aseqround['] & \filter{\amxrf[_k](\cid)} \aseqround \\
					 \end{array}
				\]
			
			
			Since $(\isystemterm,\systemterm)\in \mathcal{R}$,
				\[\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}] \]
				with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{fig:semantics-igsp}, 
				$\systemterm \arroi{\pulltran} \systemterm[']$ with
				\[\begin{array}{r@{=}l}
					\systemterm[']&  \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm['']}] \\
				  \end{array}		
				\]
		
				We  prove that $(\isystemterm',\systemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
				\item[\ref{prop_inclient}.] $\inclient$ = $\epsilon$ and $\treceivebuffer$ = 0, then it holds by 
					\refprop{prop_state_known}.
		
					\item[\ref{prop_state_known}.] By \propref{prop_inclient} we know that 
					$\astate['''] = \iapply{\initialstate}{\ireduce{\adelta[']_1\cdots\adelta[']_{z}}}$  and
				       $\astate['] \triangleleft \ \queuemessage[0 .. t - 1]$ and $t \leq \tknown+\treceivebuffer$ and  
					$\ireduce{\adelta_{1}\cdots\adelta_{k}}\triangleleft \ \flatten{ \queuemessage[t..\tknown+\treceivebuffer-1]}$.
					 Then we should build the following proof for 
						\[\iapply{\iapply{\initialstate}{\ireduce{\adelta[']_1\cdots\adelta[']_z}}}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown +\treceivebuffer- 1]} \]
					\[
						  \mathrulean{\triangapply}
						  {
							\iapply{\initialstate}{\ireduce{\adelta[']_1\cdots\adelta[']_z}} \triangleleft \flatten {\queuemessage[0..t-1]}
							\quad 
							\ireduce{\adelta[_1]\cdots\adelta[_k]} \triangleleft \queuemessage[t .. \tknown+\treceivebuffer  - 1]
															}
  						{\iapply{\astate[''']}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown +\treceivebuffer - 1]} }  
					\]
						
						\item[\ref{prop_pending}.] We have to prove that $\ireduce{\adelta[_1]\cdots\adelta[_z]} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown_i + \treceivebuffer_i + h + r -1]}$ (PENDIENTE)
		\chnote{por que ocurre lo del inserver en pull 2?}
		\henote{que se esto}
											
						\item[{--}] The remaining properties straightforwardly hold.

					\end{enumerate}
	
	
			\item {\bf rule \ruleName{accept-conn}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \server{\astate}{\inserver}{\outserver} \ \bigpar\  \iclient 	\\
					\isystemterm['] & \server{\astate}{\inserver\upd\cid\epsilon}{\update{\outserver}{\cid}{\agsprefpair}}\ \bigpar\  \iclient 
				\end{array}
				\]

				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
				
					\item[\ref{prop_inclient}.] By \propref{prop_outserver2}, when $\outserver(i)$ has a state $\astate[']$ as prefix, then $\astate = \iapply{\astate[']}{\ireduce{\adelta_1\cdots\adelta_h}}$ . In particular, there do not exists deltas in $\outserver(i)$ so that $\astate = \astate[']$. By \propref{prop_stateserver}, we know that $\astate \triangleleft \queuemessage$, hence this property holds.
											
						\item[{--}] The remaining properties straightforwardly hold.

					\end{enumerate}

			\item {\bf rule \ruleName{drop-conn}}. Then, $\isystemterm  \arroi{\tau} \isystemterm '$ with 
				\[\begin{array}{r@{=}l}
					\isystemterm & \addid{\iclientinst[@][@][\aseqround][@][@][@][@][\inclient]}
								   \ \bigpar \ \server{\astate}{\inserver}{\outserver} \ \bigpar \ \iclient 	\\
					\isystemterm['] & \addid{\iclientinst[@][@][\aseqround][@][@][@][@][\epsilon]}
									\ \bigpar \server{\astate}{\inserver \setminus\cid}{\outserver \setminus\cid}\ \bigpar \ \iclient 				
					\end{array}
				\]



				We  prove that $(\isystemterm',\systemterm) \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm}$ 
				by checking the properties in \defref{def:implementation}.	
				\begin{enumerate}
							
						\item[{--}] Properties straightforwardly hold.

					\end{enumerate}



				%
				%\item {\bf rule \ruleName{read}}. Then, $\systemterm  \arroi{\readtran{r}} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\treadins{x}{r}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					%\\
					%v &  \rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}	
				  %\end{array}
				%\]
		%
				%\henote{Ac\'a es $\systemterm['']$ porque $N$ es el que estas usando}.
				%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[ \addid{\iclientinst[\treadins{x}{r}]} \ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\readtran{r}} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[{P}\subst{x}{v'}]}\ \bigpar \ \isystemterm['']	\\
					%v' & \iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}$ by property \ref{prop_state_known};
							%\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%
						%Then, we can build the following proof for 
						%$\rvalue{r}{\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}
						%= 
						%\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}$
						%\[
						  %\mathrulean{\triangread}
						    %{
								  %\mathrulean{\lemref{lemma:apply}}
									%{
										%\mathrulean{\triangapply}
										%{
										%\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
										%\quad 
										%\mathrulean{\lemref{lemma:reduce}}
											%{
												%\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}} \triangleleft \flatten{\tpending}
												%\quad
												%\transactionbuffer \triangleleft \ttransactionbuffer
											%}
											%{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}} 
											%\triangleleft {\flatten {\tpending} \cdot \ttransactionbuffer}}
										%}
										%{\iapply{\known}{\ireduce{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}}
									%\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
									%}
									%{\iapply{\known}{{\igetdeltas\pending}\cdot{\pushbuffer}\cdot{\transactionbuffer}}  
									%\triangleleft {\flatten {\queuemessage[0..\tknown-1] \cdot \tpending} \cdot \ttransactionbuffer}}
								%}
  						  %{v'  = v}  
					%\]
											%
						%\item to 9 straightforwardly hold.
						%
%
					%\end{enumerate}
					%
					%
			%\item {\bf rule \ruleName{update}}. Then, $\systemterm  \arroi{\updatetran{u}} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tupdateins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer \cdot \tupdate}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
				  %\end{array}
				%\]
				%\chnote{Deberi\'amos cambiar la regla del update en la imple para que guarde updates con vertices como hacemos en abs}.
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
%
				%\[\addid{\iclientinst[\tupdateins]} \ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\updatetran{u}} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P][@][@][@][\iappend{\transactionbuffer}{u}]} \ \bigpar \   \isystemterm['']	\\
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the transaction buffers in client $\cid$. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%
						%Then, we can build the following proof for 
						%$\iappend{\transactionbuffer}{u}
						%\triangleleft 
						%\ttransactionbuffer \cdot \tupdate$
						%\[
						  %\mathrulean{\triangappend}
						      %{
						      %\transactionbuffer \triangleleft{\ttransactionbuffer}
						      %}
  						%{\iappend{\transactionbuffer}{u}]
						%\triangleleft 
						%\ttransactionbuffer \cdot \tupdate}  
					%\]
%
						 %\chnote{Esta prueba es m\'as inmediata, creo que aca no haria falta mostrar el detalle ya que es solo un paso. Con mencionar la regla del append tiene que alcanzar, lo dejo por si preferis que quede asi.}.
%
						%\item to 9 straightforwardly hold.
						%
%
					%\end{enumerate}
	
	
			
					%
	%
	%\item {\bf rule \ruleName{pull}}. Then, $\systemterm  \arroi{\pulltran} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tpullins}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown+\treceivebuffer}{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer {\ -1}]}{\ttransactionbuffer}{\tsent}{0}}[{\systemterm['']}]	
				  %\end{array}
				%\]
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[ \addid{\iclientinst[\tpullins][@]
						%[@]%[\aseqround\cdot{\aroundtuple}\cdot{\aseqround[']}]
						%[@][@][@][n][{\agssegpair[{\adelta[']}]}\cdot\inclient]}
								%\ \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\pulltran} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P]
						 %[\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}]
						 %[\aseqround']
						 %[@][@]
						 %[{\receivebuffer}][n][\epsilon]}\ \bigpar \ \isystemterm['']	\\
					   %\aseqround['] & filter\ (\geq \amxrf[_k](\cid)) \ \aseqround \\
						%\inclient & \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.	
						%\chnote{esta oka la regla pull1? el in del cliente no entiendo porque tiene el delta y la f, para que la usas?}
					%\begin{enumerate}
						%\item We will inspect the terms that have changed in client $\cid$ knowing as hypothesis that $\implements{\isystemterm}{\systemterm}$.
						%\begin{itemize}
							%\item By \propref{prop_state_known}, $\astate_l \triangleleft \flatten {\queuemessage[0 .. \tknown_l - 1]} \ $, however, after $\pulltran$ transition, we should build the following proof for 
						%$\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]} \ $
					%\[
						  %\mathrulean{\lemref{lemma:apply}}
						  %{
							%\mathrulean{\triangapply}
								%{
								%\known \triangleleft \flatten {\queuemessage[0..\tknown-1]}
								%\quad 
								%\adelta[_1] \triangleleft \queuemessage_A[\tknown_l] \ldots \adelta[_k] \triangleleft \queuemessage_A[\tknown_l + \treceivebuffer_l - 1]
								%}
								%{\iapply{\known}{\adelta[_1]\cdots\adelta[_k]}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}
								%}
							%}
  						%{\iapply{\known}{\ireduce{\adelta[_1]\cdots\adelta[_k]}}\triangleleft \flatten{\queuemessage[0 .. \tknown_l +\treceivebuffer_l - 1]}}  
					%\]
					  %The last step is worth by \propref{prop_inclient}.
						%\item By \propref{prop_inclient}, if $\inclient_l = \agssegpair[{\adelta[_1]}][{\amxrf[_1]}]\ldots \agssegpair[{\adelta[_k]}][{\amxrf[_k]}]$ then 
		%$\adelta[_1] \triangleleft \queuemessage[\tknown_i] \ldots \adelta[_k] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l - 1]$. After $\pulltran$ transition, $\inclient_l$['] = $\epsilon$ and $\treceivebuffer_l$ = 0, then by 
		%\triangemptydelta, this property is hold.
						%\item We have to prove that $\ireduce{\adelta[_m]\cdots\adelta[_h]} \triangleleft \flatten{\tpending \setminus \queuemessage[\tknown .. \tknown + \treceivebuffer -1]}$ (PENDIENTE)
						%\end{itemize}
		%
				%
%
					%\end{enumerate}
	
	
	        %\item {\bf rule \ruleName{confirm}}. Then, $\systemterm  \arroi{\confirmedtran} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclienti{\tconfirmedins{x}}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{{\tprogram}\subst{x}{v}}
		%{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]	
					%\\
					%v & \eval{(\tpending \cdot  \ttransactionbuffer == \epsilon)}
				  %\end{array}
				%\]
		%
		%
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[\addid{\iclientinst[\tconfirmedins{x}]} \bigpar \ \isystemterm['']\]
				%with $\implements{\isystemterm['']}{\systemterm['']}$. By inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\confirmedtran} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[P\subst{x}{v}]} \bigpar \ \isystemterm['']	\\
					%v' & (\pending  \cdot \pushbuffer \cdot\transactionbuffer == \epsilon) 
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
					%\begin{enumerate}
						%\item The only terms that have changed are the programs in client $\cid$.  We show that $v=v'$ holds. Since 
						%$\implements{\isystemterm}{\systemterm}$, the following holds
						%\begin{itemize}
							%\item $\ireduce{\igetdeltas{\pending}\cdot{\pushbuffer}}\triangleleft \flatten{\tpending} \ $ by property \ref{prop_pending};
							%\item $\transactionbuffer \triangleleft{\ttransactionbuffer}$ by property \ref{prop_transactions};
						%\end{itemize}
						%Then, we know that the value of $\pending \cdot \pushbuffer$ is related to $\tpending$, thereby, when E.$\pending$ or E.$\pushbuffer$ have any elements then $\tpending$ also has it. Finally, $\transactionbuffer$ has elements iff $\ttransactionbuffer_i$ also has any elements.
			%
					%\end{enumerate}
				%
				%
				%\item {\bf rule \ruleName{receive}}. Then, $\systemterm  \arroi{\tau} \systemterm '$ with 
				%\[\begin{array}{r@{=}l}
					%\systemterm & \tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}}[{\systemterm['']}]
					%\\
					%\systemterm['] & \tsystem{\tclienti{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer+1}}[{\systemterm['']}]	
					%
				  %\end{array}
				%\]
				%Since $(\systemterm,\isystemterm)\in \mathcal{R}$,
				%\[\addid{\iclientinst[@][@][@][@][@][@][@][\inclient]} \ \bigpar \ \iserverins[\astate['']] \ \bigpar\ \iclient['']\]
				%%with $\implements{\isystemterm['']}{\systemterm['']}$. 
				%by inspection of rules in \figref{}, 
				%$\isystemterm \arroi{\tau} \isystemterm[']$ with
				%\[\begin{array}{r@{=}l}
					%\isystemterm['] & \addid{\iclientinst[@][@][@][@][@][@][@][\inclient\cdot \aseg]} \ \bigpar \ \iserverins[{\astate[']}][@][@][\outserver\upd{\cid}\aseqseg] \ \bigpar\ \iclient[''] \\
				  %\end{array}		
				%\]
				%
				%We  prove that $(\systemterm',\isystemterm') \ \in \ \mathcal{R}$ by showing that $\implements{\isystemterm[']}{\systemterm[']}$ 
				%by checking the properties in \defref{def:implementation}.			
%
						%\begin{itemize}
							%\item[4.] By \propref{prop_outserver}, we know that the firt element in $\outserver(i)$ = $\queuemessage[\tknown_l+\treceivebuffer_l]$ when $m$ = 1. Now, we should build the following proof for 
							%
						%${\ireduce{\adelta_0\cdots\adelta_{h+1}}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l]} \ $
					%\[
						  %\mathrulean{\lemref{lemma:reduce}}
						  %{
								%\ireduce{\adelta_0\cdots\adelta_{h}}\triangleleft  \queuemessage[\tknown_l..\tknown_l+\treceivebuffer_l - 1]
								%\quad 
								%\adelta[_{h+1}] \triangleleft \queuemessage[\tknown_l + \treceivebuffer_l] 							
							%}
  						%{\ireduce{\adelta_0\cdots\adelta_{h+1}}\triangleleft  \queuemessage[\tknown_l..\treceivebuffer_l]}  
					%\]
							%\item[9.] By \propref{prop_outserver}, we know that for all natural $m$, such that $0 \leq m \leq |\outserver(i)|$ then $\outserver(i)[m] \triangleleft \queuemessage[\tknown + \treceivebuffer - 1 + m]$. Now, $|\outserver(i)|$ was decremented by one, however, this property holds.
						%\end{itemize}
					%
				
				
				%
					%
						%
%\item {\bf rule (\textsc{t-process})} If $A \arroi{\tau} A'$, then by rule (\textsc{\footnotesize{t-process}}), $A$ must be the following term: $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{[\tsenthead] \cdot \tsent}{\treceivebuffer}\ \bigpar\ \tilde{A}}{\queuemessage_A}$, therefore, the client $i^{th}$ is only one who changes. So that, $A'$ will be $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ C}{\queuemessage \cdot \tsenthead}$. Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. Analyzing cases:
					%
					%
					%
					%\begin{itemize}
						%\item If $\beta \ \in\ E_{i}.\outclient$ then, by rule (\textsc{\footnotesize{comm-client-server}}), $C \arroi{\tau} C'$, so that, $C'$ = $\clientr{P}{\update{E}{\outclient}{\tailround}} \bigpar\ \tilde{C} \ \bigpar\ \ \server{\state}{\update{\inserver}{i}{\headerround}}{\outserver}_C$ and $\delta_0 \triangleleft \beta$. Performing a new internal action by rule (\textsc{\footnotesize{batch}}),i.e., $C' \arroi{\tau} C''$, then $C''$ = $\server{\apply{\persistedstate}{d}}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}  \bigpar\ \tilde{C} \bigpar \clientr{P}{\stateclient}$. We have to prove that $(A',C'')$ belongs $\mathcal{R}$.
						%
						%\begin{enumerate}
							%\item Theirs terms do not change.
							%\item Our hypothesis is $\queuemessage_C.\state \triangleleft \queuemessage_A$ besides $\delta_0 \triangleleft \beta$, then using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item $\queuemessage_A$  has incremented by one, so that, by Hypothesis, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$, besides, $\Leftrightarrow |E_{i}.\inclient| + |\queuemessage_C.\outserver| > 0$ because of neither $E_{i}.\inclient$ nor $\queuemessage_C.\outserver$ have changed.
%\item By Hypothesis, for all element in $\tsent$, those belongs to $E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$, in particular, $\tsent$ without a element keeps these guarantee.
						%\end{enumerate}
%\item If $\beta \ \in\ E_{i}.\inserver$ then, applying rule (\textsc{\footnotesize{batch}}), we can see that we are at above case.
					%\end{itemize}
					
\end{itemize}

\end{itemize}
%
%We have prove that if $A$ perform an action, $C$ also can perform an action, the terms after both transitions are in $\mathcal{R}$. Now, we will prove the opposite side. When $C$ perform an action, then A can perform an action and the news terms are in $\mathcal{R}$.
%
%
%\begin{itemize}
   %\item{\bf n=0}. Then $C$ = $\clientr{E}{\initialstate}$ and $A$ = $\tsystem{\tclienti{0}{\emptyset}{\emptyset}{\emptyset}{\emptyset}{0}\ \bigpar\ \tilde{A}}{\queuemessage_A}$. It is analogous to the base case previously proved.
			%
   %\item{\bf n=k+1}. $\forall (C,A) \ \in \ \mathcal{R}$
	%
			%
			%\begin{itemize}
				%\item {\bf rule (\textsc{comm-server-client})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-server-client}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		%\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if ten properties introduced are keeping.				
					%\begin{enumerate}
						%\item to 6. Their terms do not changed.
						%\setcounter{enumi}{6}	
							%\item $l'$ = $(|E_{i}.\inclient| + 1)$, so that, we have to prove that $E_{i}.\inclient[l'] \triangleleft \queuemessage_A[\tknown + \treceivebuffer - 1 + l']$, however, it easy to see because by property 10. when $m$ = 0 then $\outserver(i)[0] \triangleleft \queuemessage_A[\tknown + \treceivebuffer + |\inclient|]$.
						%\item It is easy to see that $(|E_{i}.\inclient| + 1) + (|\queuemessage_C.\outserver|-1) > 0$.
						%\item It does not change.
						%\item It is easy to see, because, Property 10 is guaranteed with $0 \leq l$ therefore $1 \leq l$. 
					%\end{enumerate}
					%
					%
				%\item {\bf rule (\textsc{comm-client-server})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{comm-client-server}}), $C'$ must be the following term: $\server{ps'}{\inserver}{\notify{dom(\outserver)}{\outserver}{gs}}$, therefore, the client $i^{th}$ is the only one who has changed. We will prove that $(C',A) \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.				
					%\begin{enumerate}
						%\item to 8. Their terms do not changed.
						%\setcounter{enumi}{8}	
						%\item It is easy to see, because, we have exchanged a sequence from $\outclient$ to $\inserver$. 
						%\item It does not change.
						%\end{enumerate}
				%
%
%
				%
						%\item {\bf rule (\textsc{batch})}. If $C \arroi{\tau} C'$, then by rule (\textsc{\footnotesize{batch}}), $C'$ must be the following term: $\server{\state}{\inserver}{\update{\outserver}{i}{\gss}} \bigpar 
		%\clientr{P}{\update{E}{\inclient}{E.\inclient \cup \{\gs\}}}$, therefore, the client $i^{th}$ at C, is the only one who changed. Hence	$(C,A)$ belongs to $\mathcal{R}$ then $A$ after of internal transition $\tau$ is $\tsystem{\tclient{\tprogram}{\tknown}{\tpending}{\ttransactionbuffer}{\tsent}{\treceivebuffer}\bigpar\ S_C}{\queuemessage \cdot \tsenthead}$. We will prove that $(C',A') \ \in \ \mathcal{R}$ if the ten properties introduced are keeping.	
				%\begin{enumerate}
						%\item Their terms do not change.
						%\item Property 9 states that for all $\beta$ such that $\beta \ \in \ \tsent_i$ then $\beta \ \in \ E_{i}.\outclient \ \cup \ \queuemessage_C.\inserver$. In particular, we consider $\beta \ \in \ \queuemessage_C.\inserver$, then there exists $\delta_o$ such that $\delta_0 \triangleleft \beta$, besides by Property 2., $\queuemessage_C.\state \triangleleft \queuemessage_A$, so that using the property of the relation $\triangleleft$ between state and updates, we will get that $apply(\queuemessage_C.\state,\delta_0) \triangleleft \queuemessage_A \cdot \beta$.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item It does not change.
							%\item $\queuemessage_C.\outserver$ is updated with the new persisted state however its size does not change. By Hypothesis 9, $\tknown + \treceivebuffer + 1 \leq |\queuemessage_A| < |\queuemessage_A| + 1$.
							%\item It does not change.
							%\item It does not change.
%
						%\end{enumerate}
		%
%
				%
			%\end{itemize}
		%\end{itemize}
		
\end{proof}
