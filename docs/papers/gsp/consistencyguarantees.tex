% !TEX root = main.tex
\section{Consistency Guarantees}
\label{sec:properties-gsp}

Consistency guarantees are usually defined over abstract executions~\cite{} given as a set of 
relations between read and update events. In particular,  the following relations are used
\chnote{Aca de repente se hablan de eventos en lugar de acciones o transitions. Tal vez deberíamos hablar de eventos desde el principio o bien decir algo que los eventos estan asociados con las transiciones que puede realizar gsp} 
%
%We shall introduce a series of store-level consistency guarantees and then we shall show which 
%are captured by application written in GSP. We start identifying three kinds of relations between actions of update and read:º

\begin{itemize}
 \item {\em Session Order} (\so) describes the sequential order in which operations executed within a session (i.e., a single thread of 
 execution) are performed. This relation is a total order over the events associated with operations belonging to the same session.
 Hereafter, we will 
 associate a session with a \gsp\ client.  

 \item{\em Visibility} (\vis) indicates whether the effects of an update event are visible to a read event.

 \item{\em Arbitration} (\arb) describes the resolution strategy for concurrent update conflicts. This is a total order over update events.

 \item{\em Same Session} (\sse) ...

\end{itemize}



We extend the GSP language with a new term which capture the relations amount operation in our system. 
\begin{definition} Let $\systemterm$ be a \gsp\ system in \secref{sec:gsp}, an abstract history is a tuple 
$ \environmentterm =  \environment{\systemterm}{\op}{\so}{\vis}{\arb} $
%\[
%    \begin{array}{l@{\quad}r@{\;::=\;}l}
%			 (\textsc{Abstract Exec.}) & \environmentterm &  \environment{\systemterm}{\op}{\so}{\vis}{\arb} \\
%	    \end{array}
%  \]
where
 \begin{itemize}
     \item $\op: \verticesets\rightarrow\opset$ mapping each event to its corresponding operation;
     \item $\sse: \idset\rightarrow\verticesets$ associating each client with its executed events;
     \item $\so\subseteq \verticesets\times\verticesets$, s.t. 
     \item $\vis\subseteq\verticesets\times\verticesets$;
     \item $\arb\subseteq\verticesets\times\verticesets$;
 \end{itemize}
 
 Satisfying the following restrictions:
 \begin{itemize}
     \item for all $\cid\in\dom\sse$, $\sse(\cid) \subseteq \dom\op$;
     \item for all $\cid$, $\so\relrestriccion{\sse(\cid)}$ is a total order; \chnote{que significa esto?}
     \item if  $(\vertice[@][_1],\vertice[@][_2])\in\vis$, then $\op(\vertice[@][_1])\in\updatesets$ and $\op(\vertice[@][_2])\in\readset$;
     \item if  $(\vertice[@][_1],\vertice[@][_2])\in\arb$, then $\{\op(\vertice[@][_1]),\op(\vertice[@][_2])\}\subseteq\updatesets$;
 \end{itemize}
\end{definition}

%	 
%Let $\environmentterm$, a new term, where $\systemterm$ represents our system introduced in Definition 1.1, $\op$ is a mapping of vertices to actions, $\so$ is a session order relation defined from vertices to relations of vertices $\verticesets$ $\times$ ($\verticesets$ $\times$ $\verticesets$) and $\vis$,$\arb$ are visibility and arbitration relation.
%
%

\chnote{Regla a-update, aca no se si queda claro que S es el store del modelo. Por otra parte, no es flatten S, o [u] }

We  provide an operational approach to associate abstract executions to \gsp\ systems. They are provided 
by inference rules in \figref{fig:comp-abst-executions}



%%reglas
 \begin{figure}[t]
 \[
 \begin{array}{l}
\mathrule{a-update}
	{
	\begin{array}{l}
		\systemterm \arroi{\updatetran{u}} \systemterm' 
		\qquad \vertice \notin dom(\op)
		\qquad \op' = \op\upd \vertice u
		\qquad \sse' = \sse\upd \cid {\sse(\cid)\cup\{\vertice\}}
		 \\[2pt]
		 \so' = \so\cup (\sse(\cid)\times\{\vertice\})
		 \qquad
		 \arb' = \arb \cup (\{ \vertice[w] \ |\ \udec[@][{\vertice[w]}]\in \queuemessage \}\times\{\vertice\})
	\end{array}
	}
	{\environment{\systemterm}{\op}{\so}{\vis}{\arb} 
		  \arroi{\updatetran{u}}  
		  \environment{\systemterm'}{\op'}{\so'}{\vis}{\arb'}
	}
\\[32pt]	
\mathrule{a-read}
	{ 
	\begin{array}{l}
		\systemterm \arroi{\readtran{r}} \systemterm' 
		 \qquad \vertice \notin  dom(\op) 
		 \qquad \op' = \op\upd \vertice r
		 \qquad \sse' = \sse\upd \cid {\sse(\cid)\cup\{\vertice\}}
		 \\[2pt]
		 \so' = \so\cup (\sse(\cid)\times\{\vertice\})
		 \qquad \ \vis' = \vis \cup (\{\vertice[w] \ |\  \udec[@][{\vertice[w]}] \in \queuemessage[0..\tknown_{\,\cid}-1] \cdot \tpending_{\cid} \cdot \ttransactionbuffer_{\,\cid} \}\times\{\vertice\})
	\end{array}
	 }
	 {\environment{\systemterm}{\op}{\so}{\vis}{\arb} 
	   \arroi{\readtran{\udec[r]}} \environment{\systemterm'}{\op'}{\so'}{\vis'}{\arb}[\sse']}
\\[27pt]	
\mathrule{a-int}
	{ 
	\begin{array}{l}
		\queuemessage \bigpar \Absclient \arroi{\lambda} \queuemessage \bigpar \Absclient' 
		\qquad \lambda \neq  \updatetran{u},\readtran{r}
	\end{array}
	 }
	 {\environment{\queuemessage \bigpar \Absclient}{\op}{\so}{\vis}{\arb} 
	   \arroi{\lambda} 
	   \environment{\queuemessage\bigpar \Absclient'}{\op}{\so}{\vis}{\arb}}
\\[27pt]	
\mathrule{a-arb}
	{ 
	\begin{array}{l}
		\queuemessage \bigpar \Absclient \arroi{\lambda} \queuemessage\cdot \ublock[{\udec[{\anupd[_0]}][{\vertice[@][_0]}]}\cdots{\udec[{\anupd[_n]}][{\vertice[@][_n]}]}] \bigpar \Absclient' 
		%\hspace{2cm} \queuemessage\neq\queuemessage'
		\hspace{2cm} \lambda \neq  \updatetran{u},\readtran{r}
		 \\[2pt]
%		 \arb' = \arb \cup \{ (\vertice, \vertice[w])\ | \ \ell = |\queuemessage'|-1 \land \udec \in \queuemessage'[0..\ell-1] \land \udec[@][{\vertice[w]}]= \queuemessage'[\ell]\}
		\arb' = \arb \cup 
		\{\vertice[@][_0],\ldots,\vertice[@][_n]\}\times 
		\{ \vertice[w]\ \ |\ \  \vertice[w]\in\dom{\op}, \ \op(\vertice[w])\in\updatesets, \
		     \forall\anupd. \anupd^{\vertice[w]}\not\in\queuemessage\cdot\ublock[{\udec[{\anupd[_0]}][{\vertice[@][_0]}]}\cdots{\udec[{\anupd[_n]}][{\vertice[@][_n]}]}]\}
		     \\ \hfill \cup \{(\vertice[@][_i],\vertice[@][_j]) \ |\ \vertice[@][_i],\vertice[@][_j]\in \{\vertice[@][_0],\ldots,\vertice[@][_n]\}, i<j\}
	\end{array}
	 }
	 {\environment{\queuemessage \bigpar \Absclient}{\op}{\so}{\vis}{\arb} 
	 \arroi{\lambda}	   
	 \environment{\queuemessage\cdot \udec  \bigpar \Absclient'}{\op}{\so}{\vis}{\arb'}}
\end{array}
 \]
 \caption{Computation of abstract executions} 
 \label{fig:comp-abst-executions}
 \end{figure}
 
 
 
%  \paragraph{Notation.} Given a session order relation $\so$ from client $i$ and a vertex $v$, we shall write $\soby{\so}{v}$  meaning that $\soby{(\mathcal{V}, \mathcal{R})}{v} = (\mathcal{V} \ \cup \ \{v\}, \mathcal{R}\ \cup \ \{(x,v) / x \in \verticesets\})$. We shall refer to an update action on the queue message as $\updateinqueuemessage{n}{i}$.The arbitration relation $\arb$ is defined as $\{ (v,w) / \{v \mapsto \updateinqueuemessage{m}{h}\} \in \op \land \ \{w \mapsto \updateinqueuemessage{n}{i} \} \in \op \land \ m < n \}$. A transition $\arroi{\alpha}$ denotes the fact that action $\alpha$ is perfomed by client $i$.
 

\subsection{Ordering Guarantees}

We now study the properties enjoyed by the \gsp\ model. We focused on the hierarchy in~\cite{}. That are listed in ~\figref{}.
% now prove what ordering guarantees are assured by GSP language and what do not. 


\begin{theorem}  \label{theorem:properties}
	If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \arro{}^*\ 
		\environment{\systemterm'}{\op}{\so}{\vis}{\arb}$ 
	then

	\begin{enumerate}  [(1)]
	    	\item
		\label{theorem:read-my-writes}
	    	\textit{Read My Writes}:  $\restUR\so  \subseteq  \vis$

		\item 
		\label{theorem:monotonic-read}
		\textit{Monotonic Read}:  $\restUR{\vis;\so}  \subseteq  \vis$.
		
		\item
		\label{thm:no-circular-causality}
		\textit{No Circular Causality}: $(\so \cup \vis ) ^+$ is acyclic.

		\item
		\label{thm:causal-visibility}
		\textit{Causal Visibility}: $\restUR{(\so \cup \vis ) ^{+} } \subseteq \vis$. 

		\item 
		\label{thm:causal-arbitration}
		\textit{Causal Arbitration}: $\restUU{((\so \cup \vis) ^{+} \setminus \so)}\  \subseteq\ \arb$. 
		
		\item
		\label{thm:consistent-prefix}
		\textit{Consistent prefix}: $\arb;(\vis\setminus\sse)\  \subseteq\ \vis$. 
		
	\end{enumerate}
\end{theorem}



%\begin{theorem}[\textsc{Read My Writes}]
%\label{theorem:read-my-writes}
%% $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if
% If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \arro{}^*\ 
%     \environment{\systemterm'}{\op}{\so}{\vis}{\arb}$
%    then $\restUR\so  \subseteq  \vis$
%\end{theorem}
%
%\begin{theorem}[\textsc{Monotonic Read}]
%\label{theorem:monotonic-read}
%%Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation,
%If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \tr{} ^*\ \environment{\systemterm'}{\op}{\so}{\vis}{\arb}$ 
%then $\restUR{\vis;\so}  \subseteq  \vis$.
%\end{theorem}
%
%\begin{theorem}[\textsc{No Circular Causality}]
%\label{thm:no-circular-causality}
%If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \tr{} ^*\ \environment{\systemterm'}{\op}{\so}{\vis}{\arb}$ 
%then 
%%Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, if $\environment{\systemterm_0}{\emptyset}{\emptyset}{\emptyset}{\emptyset} \arro{} ^*\ \environment{\systemterm}{\op}{\so}{\vis}{\arb}$ then 
%$(\so \cup \vis ) ^+$ is acyclic.
%\end{theorem}
%
%\begin{theorem}[\textsc{Causal Visibility}]
%\label{thm:causal-visibility}
%If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \tr{} ^*\ \environment{\systemterm'}{\op}{\so}{\vis}{\arb}$ 
%then
%%Let $\textsc{\small{SO}}_R$ the se\cond component of the relation $\textsc{\small{SO}}$ and $\textsc{\small{VIS}}$ a visibility relation, 
%$\restUR{(\so \cup \vis ) ^{+} } \subseteq \vis$. 
%\end{theorem}
%
%\begin{theorem}[\textsc{Causal Arbitration}]
%\label{thm:causal-arbitration}
% If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \tr{} ^*\ \environment{\systemterm'}{\op}{\so}{\vis}{\arb}$ 
%then
%$\restUU{((\so \cup \vis) ^{+} \setminus \so)}\  \subseteq\ \arb$. 
%\end{theorem}
%
%\begin{theorem}[\textsc{Consistent prefix}]
%\label{thm:consistent-prefix}
%If $\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset}{\emptyset}[\emptyset] \tr{} ^*\ \environment{\systemterm'}{\op}{\so}{\vis}{\arb}$ 
%then
%$\arb;(\vis\setminus\sse)\  \subseteq\ \vis$. 
%\end{theorem}
%

The following example shows that the \gsp\ model exhibits the Dekker anomaly, hence it does 
not enjoy {\em sequential consistency}~\cite{libro}.

\begin{example}[Dekker anomaly] 
\label{no-consistent-prefix}
Consider the following system consisting of two clients and the empty store $\systemterm = \epsilon \ \bigpar\ \Absclient[_1]  \ \bigpar\ \Absclient[_2]$ where
\[
\begin{array}{lll}
   \Absclient[_1] & = & {\anabstcli[{}][{\updcmd[{\anupd_1}];\treadins{y}{r_1}}][0][\epsilon][\epsilon][\epsilon][0][0]}_{\cid_1}\\
   \Absclient[_2] & = & {\anabstcli[{}][{\updcmd[{\anupd_2}];\treadins{y}{r_2}[Q]}][0][\epsilon][\epsilon][\epsilon][0][0]}_{\cid_2}\\
\end{array}
\]



By using rule \ruleName{a-update}, we have the following transition
\[
	{\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset} {\emptyset}[\emptyset]
		  \arro{\updatetranaux{\anupd_1^{\vertice[v][_1]}}}[\cid_1]
		  \environment{\epsilon \ \bigpar\ \Absclient[_1]'  \ \bigpar\ \Absclient[_2]}{\op_1}{\emptyset}{\emptyset}{\emptyset}[\sse_1]
	}
\]
with $\op_1 = \{\asoc{\vertice[v][_1]} \anupd_1\}$,  $\sse_1 = \{\asoc{\cid_1}{\{\vertice [v][_1]}\}\}$ and
\[
   \Absclient[_1]'  =  {\anabstcli[{}][{\treadins{y}{r_2}}][0][\epsilon][{\anupd_1}^{\vertice[v][_1]}][\epsilon][0][0]}_{\cid_1}
\]
Similarly, 
\[
	{\environment{\systemterm}{\emptyset}{\emptyset}{\emptyset} {\emptyset}[\emptyset]
		  \arro{\updatetranaux{\anupd_1^{\vertice[v][_2]}}}[\cid_2]
		  \environment{\epsilon \ \bigpar\ \Absclient[_1]'  \ \bigpar\ \Absclient[_2]'}{\op_2}{\emptyset}{\emptyset}{\emptyset}[\sse_2]
	}
\]
with $\op_2 = \{\asoc{\vertice[v][_1]},{\anupd_1},\asoc{\vertice[v][_2]} {\anupd_2}\}$,  
$\sse_2 = \{\asoc{\cid_1}{\{\vertice [v][_1]}\}, \asoc{\cid_2}{\{\vertice [v][_2]}\}\}$ and
\[
   \Absclient[_2]'  =  {\anabstcli[{}][{\treadins{y}{r_2}[Q]}][0][\epsilon][{\anupd_2}^{\vertice[v][_2]}][\epsilon][0][0]}_{\cid_2}
\]
Then, by using rule \ruleName{a-read},
\[ 
	\environment{\epsilon\ \bigpar\ \Absclient[_1]'  \ \bigpar\ \Absclient[_2]'}{\op_2}{\emptyset}{\emptyset}{\emptyset}[\sse_2]
	 \arro{\readtran{\udec[r_1][{\vertice[v][_3]}]}}[\cid_1]
	\environment{\epsilon \ \bigpar\ \Absclient[_1]''  \ \bigpar\ \Absclient[_2]'}{\op_3}{\so_1}{\vis_1}{\emptyset}[\sse_3]
\]
with $\op_3 = \{\asoc{\vertice[v][_1]} {\anupd_1},\asoc{\vertice[v][_2]} {\anupd_2},\asoc{\vertice[v][_3]} {r_1}\}$,  
$\sse_3 = \{\asoc{\cid_1}{\{\vertice [v][_1],\vertice [v][_3]\}},\asoc{\cid_2}{\{\vertice [v][_2]\}}\}$,
$\so_1 = \vis_1 = \{(\vertice[v][_1],\vertice[v][_3])\}$,
$   \Absclient[_1]''  =  {\anabstcli[{}][P\subst{x}{v}][0][\epsilon][{\anupd_1}^{\vertice[v][_1]}][\epsilon][0][0]}_{\cid_1}$,
and $\iread{r_1}{{\anupd_1}^{\vertice[v][_1]}}=v$.
And similarly,
\[ 
	\environment{\epsilon \ \bigpar\ \Absclient[_1]''  \ \bigpar\ \Absclient[_2]'}{\op_3}{\so_1}{\vis_1}{\emptyset}[\sse_3]
	 \arro{\readtran{\udec[r_2][{\vertice[v][_4]}]}}[\cid_2]
	\environment{\epsilon \ \bigpar\ \Absclient[_1]''  \ \bigpar\ \Absclient[_2]''}{\op_4}{\so_2}{\vis_2}{\emptyset}[\sse_4]
\]
with $\op_4 = \{\asoc{\vertice[v][_1]} {\anupd_1},\asoc{\vertice[v][_2]} {\anupd_2},\asoc{\vertice[v][_3]} {r_1}, \asoc{\vertice[v][_4]} {r_4}\}$,  
$\sse_4 = \{\asoc{\cid_1}{\{\vertice [v][_1],\vertice [v][_3]\}},\asoc{\cid_2}{\{\vertice [v][_2],\vertice [v][_4]\}}\}$,
$\so_2 = \vis_2 = \{(\vertice[v][_1],\vertice[v][_3]), (\vertice[v][_2],\vertice[v][_4])\}$, 
$   \Absclient[_1]''  =  {\anabstcli[{}][Q\subst{y}{v'}][0][\epsilon][{\anupd_1}^{\vertice[v][_1]}][\epsilon][0][0]}_{\cid_1}$ and
 $\iread{r_2}{{\anupd_2}^{\vertice[v][_2]}}=v'$.
 Since $\iread{r_1}{{\anupd_1}^{\vertice[v][_1]}}=v$ and $\iread{r_2}{{\anupd_2}^{\vertice[v][_2]}}=v'$, 
  none of the clients reads the update performed by the other.

\end{example}
